"{\"title\":\"Kotlin Professional Certificate by JetBrains\",\"courses\":[{\"course_title\":\"Kotlin Essential Training: Functions, Collections, and I/O\",\"course_admin_id\":3008787,\"metadata\":{\"Locale\":\"en_US\",\"Course ID\":3008787,\"Project ID\":null,\"Course Name\":\"Kotlin Essential Training: Functions, Collections, and I/O\",\"Course Name EN\":\"Kotlin Essential Training: Functions, Collections, and I/O\",\"Activation Status\":\"ACTIVE\",\"Display to Public\":\"Yes\",\"Display to QA\":\"No\",\"Course Description\":\"If you\u00e2\u20ac\u2122re looking to get up and running with Kotlin, the powerful programming language from JetBrains, this course gives you the tools you need to start writing command-line programs in a matter of hours. Join instructor Nate Ebel, the author of &lt;i&gt;Mastering Kotlin&lt;/i&gt;, as he shows you the ins and out of Kotlin and walks you through its unique selling points for developers\u00e2\u20ac\u201dfrom null safety and concise syntax to Java compatibility, to full support by Google for Android development.&lt;br&gt;&lt;br&gt;Get a comprehensive overview of writing code in Kotlin, including the basics of data types, variables, statements, expressions, functions, and classes. Learn how to use the essential features of this powerful, interoperable language as well as effectively debug your code. Along the way, Nate gives you expert pointers on how to write safe and efficient multithreaded code using Kotlin coroutines to manage multiple tasks at the same time.\",\"Course Short Description\":\"Get a comprehensive overview of what you need to know as a developer to start writing command-line programs in the Kotlin programming language.\",\"Content Type\":\"TOOLS\",\"Localization Type\":\"ORIGINAL\",\"Original Course Locale\":null,\"Original Course ID\":null,\"Equivalent English Course\":null,\"Instructor ID\":20159017,\"Instructor Name\":\"Nate Ebel\",\"Instructor Transliterated Name\":null,\"Instructor Short Bio\":\"Staff Engineer, Google Developer Expert, and Podcast Host\",\"Author Payment Category\":\"NON-LICENSED\",\"Delivery Mode\":\"ALL_AT_ONCE\",\"Series End Date\":null,\"Course Release Date\":\"2022-04-29T00:00:00\",\"Course Updated Date\":null,\"Course Archive Date\":null,\"Course Retire Date\":null,\"Replacement Course\":null,\"Has Assessment\":\"Yes\",\"Has Challenge/Solution\":\"No\",\"LIL URL\":\"https://www.linkedin.com/learning/kotlin-essential-training-functions-collections-and-i-o,https://www.linkedin.com/learning/kotlin-essential-training-revision-2022\",\"Series\":\"Essential Training\",\"Limited Series\":null,\"Manager Level\":\"Individual Contributor\",\"LI Level\":\"Beginner\",\"LI Level EN\":\"Beginner\",\"Sensitivity\":null,\"Internal Library\":\"Technology\",\"Internal Subject\":\"Programming Languages\",\"Primary Software\":\"Kotlin\",\"Media Type\":\"Video\",\"Has CEU\":\"No\",\"Has Exercise Files\":\"No\",\"Visible Duration\":16948.0,\"Visible Video Count\":43.0,\"Contract Type\":\"PERPETUAL\"},\"sections\":[{\"duration\":270,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:3069676\",\"duration\":56,\"visible\":true,\"requiredForCertificateOfCompletion\":null,\"name\":\"Welcome to Kotlin\",\"fileName\":\"3008787_en_US_00_01_WX30\",\"demo\":true,\"videoCreationMetadata\":null,\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2911538,\"solution\":false,\"welcomeContent\":true,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Nate] Kotlin is one of the most popular  \\n programming languages for building mobile applications,  \\n being the default choice for Android development.  \\n It's no surprise why developers are turning to Kotlin.  \\n It's concise, flexible and includes a powerful set  \\n of modern language features.  \\n With Kotlin, developers can efficiently build  \\n robust, scalable applications that run on mobile devices,  \\n in the browser and a variety of other targets.  \\n I'm going to show you how to start building applications  \\n with Kotlin.  \\n We'll start with foundational language features,  \\n such as variables and functions,  \\n explore Kotlin's collection types,  \\n and examine the basics of File I/O.  \\n My name is Nate Ebel.  \\n I've been building mobile applications  \\n for over 10 years and have been working with Kotlin  \\n since before it's 1.0 release.  \\n If you're excited to start learning Kotlin then join me  \\n in my LinkedIn learning course on Kotlin essentials.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3067665\",\"duration\":32,\"visible\":true,\"requiredForCertificateOfCompletion\":null,\"name\":\"What you should know\",\"fileName\":\"3008787_en_US_00_02_XR30\",\"demo\":true,\"videoCreationMetadata\":null,\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":1091937,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] This course is designed to help you learn  \\n the essentials of the Kotlin programming language.  \\n To get the most out of it  \\n you should already be familiar  \\n with writing code using a modern language  \\n such as Java, Python, Swift or JavaScript.  \\n You'll want to be comfortable  \\n with object oriented programming concepts  \\n and you should know your way around GitHub.  \\n If you feel you should brush up on any of these concepts  \\n check out the course library for more resources  \\n and come back to this course when you're ready.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3066642\",\"duration\":182,\"visible\":true,\"requiredForCertificateOfCompletion\":null,\"name\":\"Using the exercise files on GitHub\",\"fileName\":\"3008787_en_US_00_03_XR30\",\"demo\":true,\"videoCreationMetadata\":null,\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":6204322,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] The exercise files  \\n for this course are stored on GitHub.  \\n There are branches for both the start and end states  \\n of each video where we work on code.  \\n You can find a list of all the branches here in GitHub  \\n in the Branch dropdown menu.  \\n For example, if you wanted to find the start state  \\n for video 03_01, basic functions,  \\n you'd change it to the 03_01b branch  \\n and the ending state would be in the 03_01e branch.  \\n There are multiple ways to work  \\n with this project in IntelliJ.  \\n One simple way is to copy the URL from the Code button  \\n and then move over to IntelliJ  \\n where we can check that code out into our working machine.  \\n Once in IntelliJ,  \\n we're going to select the Get from VCS option.  \\n VCS in this context stands for version control system.  \\n When we click that button,  \\n we'll get the Get from Version Control dialogue,  \\n where we will then paste in the URL  \\n to the repo that we copied from GitHub.  \\n In the Directory field,  \\n we can select the location that we want  \\n to copy the project into.  \\n Once you're satisfied with that working directory, go ahead  \\n and click Clone to download the project to your machine.  \\n Once you've opened the project,  \\n you may receive a few dialogues asking  \\n if you want to add the files to Git,  \\n go ahead and ignore those,  \\n but chances are, by the time you download the files,  \\n there will be updates to IntelliJ  \\n and the associated plugins.  \\n If you receive a dialogue asking you  \\n to upgrade your dependencies, please do so,  \\n then wait project to sync.  \\n It typically takes longer  \\n when the project loads for the first time.  \\n Once the sync is complete, however,  \\n you're ready to work with this version of the code.  \\n By default, we're running the code from the Main branch.  \\n As I mentioned earlier, I've created branches  \\n for each video in the course where we modify code.  \\n If you'd like to follow along,  \\n use the branches popup menu  \\n in the lower right corner of IntelliJ to change the branch  \\n to whatever branch you're looking for.  \\n As an example, let's check out the code  \\n for the start of the 03_01 video.  \\n We will choose it here from the dropdown  \\n and we can search for 03_01b.  \\n We'll select that option and click Checkout.  \\n This will checkout a copy of that branch locally.  \\n We'll then rebuild our project to ensure that we're working  \\n with the code from this newly selected branch.  \\n Once that's complete, we're now ready to work  \\n with this version of the code.  \\n If you run into any trouble checking out  \\n the different branches or with using Git in general,  \\n I recommend searching the course library  \\n for the \\\"Git Essential Training\\\" videos.  \\n \\n\\n\"}],\"name\":\"Introduction\",\"size\":10207797,\"urn\":\"urn:li:learningContentChapter:3070638\"},{\"duration\":869,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:3072721\",\"duration\":148,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Introducing IntelliJ IDEA\",\"fileName\":\"3008787_en_US_01_01_XR30\",\"demo\":true,\"videoCreationMetadata\":null,\"description\":\"In this video, learn about the program used to write Kotlin throughout the course.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":6644528,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Like most programming languages,  \\n it's possible to write Kotlin in a variety  \\n of ways, from the command line, your favorite text editor,  \\n or other more language focused programs.  \\n In this course,  \\n we're going to be using a program called IntelliJ Idea  \\n or just IntelliJ for short.  \\n By using IntelliJ,  \\n you'll better understand why it's useful  \\n for building Kotlin projects.  \\n Kotlin is an IDE or integrated development environment.  \\n IDEs combine developer tooling with a graphical  \\n interface to streamline the development process.  \\n Without a fully featured IDE,  \\n we would need to build our Kotlin projects  \\n using a combination of different text editors, terminals,  \\n and command line tools.  \\n And while this is perfectly possible,  \\n it's not usually the most efficient way  \\n to write modern software projects.  \\n IntelliJ has a robust suite of tools for Kotlin development  \\n including a fully functional text editor,  \\n syntax highlighting, and powerful refactoring capabilities.  \\n Why choose to use IntelliJ  \\n over your favorite text editor or another IDE?  \\n Well that's because IntelliJ is built by JetBrains,  \\n the creators of the Kotlin programming language.  \\n They are the industry leaders in IDE development  \\n with a long track record of terrific tooling  \\n for C#, Java and other popular languages.  \\n Because of this,  \\n and comprehensive set of functionality  \\n for building nearly any type of Kotlin project  \\n you could want, including mobile, web, or backend projects.  \\n IntelliJ comes in two flavors,  \\n community edition and ultimate,  \\n and both of these variants are available  \\n across Mac, Windows and Linux.  \\n The community edition provides full support  \\n for Kotlin development and is free to use  \\n and download.  \\n The ultimate edition is a paid product  \\n which includes additional tools and functionality  \\n not specifically related to Kotlin.  \\n For this course,  \\n the community edition is more than enough,  \\n but feel free to use ultimate if you have access.  \\n Whether using community or ultimate edition,  \\n you'll want to make sure you're using version  \\n 2021.3.1 or newer  \\n so the UI and menus match as closely as possible.  \\n This should ensure that you have no trouble following along.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3072722\",\"duration\":212,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Installing IntelliJ IDEA for macOS\",\"fileName\":\"3008787_en_US_01_02_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to download and install the IntelliJ IDEA IDE for macOS so it can be used throughout the course.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":7079240,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Before we can start writing Kotlin code  \\n with IntelliJ,  \\n we'll first need to download  \\n and install one of the available versions of the IDE.  \\n Let's walk through the IntelliJ installation process  \\n for macOS.  \\n If developing on a Windows machine, no worries,  \\n we will cover the Windows installation process soon.  \\n Whether you want to install the Community  \\n or Ultimate Edition,  \\n there are two primary ways to download IntelliJ.  \\n Directly from the browser or by using JetBrains Toolbox.  \\n If you aren't familiar,  \\n JetBrains Toolbox is an application  \\n for managing the installation and updates  \\n for any JetBrains IDE.  \\n It's a very helpful tool  \\n if you're using IntelliJ, Android Studio,  \\n or any other JetBrains IDE.  \\n We won't walk through the installation  \\n of JetBrains Toolbox itself in this course.  \\n However, if already using jet brain's toolbox,  \\n you can install IntelliJ using JetBrains Toolbox  \\n by opening JetBrains Toolbox in your machine,  \\n scrolling through the list of the available IDEs,  \\n until you find one of the available versions of IntelliJ.  \\n We see here that both the Ultimate  \\n and the Community Edition are available to us.  \\n If we click either of these to install,  \\n JetBrains Toolbox will take care  \\n of managing the installer.  \\n And from there,  \\n we can then open the IDE  \\n and continue on with the installation process.  \\n It'll even help us manage that installation in the future  \\n if we want to upgrade, downgrade,  \\n or even uninstall the application.  \\n If you prefer to download IntelliJ from the browser,  \\n the best place to start is by searching download IntelliJ  \\n from your favorite web browser.  \\n We want to access the IntelliJ download site  \\n from jetbrains.com/idea/download.  \\n This page should detect your OS version automatically.  \\n If we see here,  \\n the middle tab is selected for me,  \\n indicating that I am on macOS.  \\n Now, if you're working on a Mac,  \\n you'll want to ensure  \\n that you download an installer  \\n for the correct CPU architecture,  \\n whether that be Intel or Apple Silicon.  \\n Once you've selected the correct download option,  \\n click Download to start the download of the installer.  \\n Once the download is complete,  \\n we'll need to locate the download  \\n on our development machine.  \\n For me, that download is located in my downloads directory  \\n where I see the installer is waiting for me.  \\n Once I double click on that installer,  \\n this will kick off the download process.  \\n I'll be prompted to drag the IntelliJ icon  \\n into the applications directory,  \\n where it'll start copying over the files needed  \\n for IntelliJ.  \\n Once that's complete,  \\n we can open up the applications directory,  \\n double click the IntelliJ icon  \\n and this will continue on to prompt us  \\n to open up the IntelliJ application.  \\n And from here,  \\n we should be able to follow the wizard  \\n until we are greeted with the IntelliJ welcome screen.  \\n For this course,  \\n you should not need any additional plugins,  \\n but feel free to customize the look  \\n and feel of IntelliJ to match your personal preferences.  \\n Once your IntelliJ installation is complete,  \\n you'll be ready to create your first Kotlin project.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3070629\",\"duration\":210,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Installing IntelliJ IDEA for Windows\",\"fileName\":\"3008787_en_US_01_03_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to download and install the IntelliJ IDEA IDE for Windows so it can be used throughout the course.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":6177007,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - Before we can start writing Kotlin code with IntelliJ,  \\n we'll first need to download and install  \\n one of the available versions of the IDE.  \\n Now, let's go through  \\n the IntelliJ installation process for Windows.  \\n Whether you want to install the Community  \\n or Ultimate Edition,  \\n there are two primary ways to download IntelliJ.  \\n Directly from the browser or by using JetBrains Toolbox.  \\n If you aren't familiar, JetBrains Toolbox is an application  \\n for managing the installation and updates  \\n for any JetBrains-based IDE.  \\n It's a very helpful tool if you're using IntelliJ,  \\n Android Studio or any other JetBrains IDE.  \\n We won't walk through the installation  \\n of JetBrains Toolbox itself in this course.  \\n However, if already using JetBrains Toolbox,  \\n you can use it to install IntelliJ  \\n by opening JetBrains Toolbox,  \\n scrolling through the available list of IDEs  \\n and locating IntelliJ IDEA Community Edition  \\n or Ultimate Edition.  \\n Once located, you can click the install button  \\n and JetBrains Toolbox should manage the install  \\n of the latest version for you.  \\n It'll even help manage that version in the future  \\n if you want to upgrade, downgrade,  \\n or even uninstall IntelliJ altogether.  \\n If you prefer to download IntelliJ from the browser,  \\n the best place to start is by searching download IntelliJ  \\n from your favorite web browser.  \\n We want to access the IntelliJ download site  \\n from jetbrains.com/idea/download.  \\n This page should detect your OS version automatically.  \\n In this case, the tab furthest to the left is selected,  \\n indicating that Windows is my operating system.  \\n Once you've chosen either Ultimate or Community,  \\n select the correct download option  \\n and click the download button.  \\n This should start the download of the installer.  \\n Once the download is complete,  \\n we'll need to locate the download  \\n on our development machine.  \\n For me, I will navigate to my Downloads directory.  \\n And I will double click on the application installer.  \\n If prompted, go ahead and click Allow  \\n to allow the program to install.  \\n And from here, we can follow the setup instructions  \\n for a basic IntelliJ installation on our machine.  \\n Once we've clicked through the basic options,  \\n the installer should perform its work  \\n to install IntelliJ to our Windows installation.  \\n Now, this can take several minutes,  \\n so grab a cup of coffee or do anything else you need to  \\n while we're waiting for your installation.  \\n Once the installation is complete,  \\n we should have the option to finish the install.  \\n And if we click the Run IntelliJ button and click Finish,  \\n IntelliJ should load up on our machine for the first time.  \\n Now, once IntelliJ is open,  \\n we should not need to install any additional plugins.  \\n But feel free to customize the look and feel of IntelliJ  \\n to match your personal preferences.  \\n Now, once your installation is complete,  \\n you'll be ready to create your first Kotlin project.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3070630\",\"duration\":299,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Run your first Kotlin code\",\"fileName\":\"3008787_en_US_01_04_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to run Kotlin code using IntelliJ so code examples can be executed.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":9057822,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] To create our first Kotlin project,  \\n open the IntelliJ application.  \\n Once open, select New Project.  \\n Once the New Project window is open,  \\n we want to make sure that the Kotlin option  \\n is selected on the left side of the screen.  \\n We can create a variety of different Kotlin project types  \\n from this view.  \\n But for now,  \\n we will stick with the basic JVM console application.  \\n If you aren't familiar, JVM stands for Java Virtual Machine  \\n and is the most common runtime environment  \\n for Kotlin applications.  \\n Name your project HelloKotlin.  \\n And then in the Location option,  \\n select a project location that you're comfortable with.  \\n For me, I will navigate to this course's working directory  \\n and just update that location.  \\n For Build System,  \\n go ahead and leave the default option selected.  \\n For Project JDK, you'll need to ensure  \\n that a valid JDK is selected.  \\n JDK stands for Java Development Kit.  \\n A JDK provides the virtual machine, the compiler,  \\n and other tools needed to build and run JVM applications.  \\n JDK versions are correlated with versions of Java,  \\n and by extension, Java bytecode.  \\n Any JDK version 8.0 or newer  \\n should work fine for this course.  \\n So if we extend this JDK dropdown,  \\n we'll see that it has automatically detected  \\n a JDK version 8.0 on my machine as well as version 15.0.  \\n So because both of these are a version 8.0 or above,  \\n either one will work fine,  \\n I will go ahead and leave version 15.0 selected.  \\n If you don't have a version of the JDK installed  \\n on your machine,  \\n you could click the Download JDK option  \\n and download any available version of Oracle OpenJDK.  \\n Once you're satisfied with your project settings,  \\n go ahead and click next.  \\n On this screen,  \\n you can further customize the initial configuration  \\n of your project.  \\n For now, we will leave these settings as is  \\n and go ahead and click Finish.  \\n After clicking Finish,  \\n IntelliJ will create your new Kotlin project  \\n and prepare the project by syncing any initial dependencies.  \\n This can sometimes take a minute or two,  \\n so you may have to be patient  \\n while IntelliJ does its thing.  \\n Now that the project has finished it's initial sync,  \\n let's take a few moments to familiarize ourselves  \\n with the interface of IntelliJ.  \\n On the left side of the screen is the Project Tool window.  \\n This represents our project's file structure,  \\n and is where we can locate any build or source files  \\n for the project.  \\n Notice, if we navigate into our src, main, kotlin directory,  \\n we have a single source file named Main.kt.  \\n If we come over into the main panel of our screen,  \\n we'll see that main.kt is already open.  \\n The .kt file extension is the primary extension  \\n for Kotlin files.  \\n Within that Main.kt file,  \\n we find that we have a main function.  \\n This is the primary entry point to our Kotlin program.  \\n Finally, the toolbar at the top of the screen  \\n provides additional tools and actions,  \\n such as the ability to run or debug our project.  \\n Let's complete our initial project setup  \\n by running our code.  \\n We can run our Kotlin program in one of two ways.  \\n The easiest is to click the green Play button  \\n in the gutter next to the file line numbers.  \\n If we click that button and select Run MainKt,  \\n IntelliJ will compile our application  \\n and any program output will be written to the console.  \\n In this case, we see Hello World!  \\n And we see any program arguments.  \\n In this case, none were passed to the run.  \\n Additionally, the other way that we can run our application  \\n is by selecting the green Play button from our toolbar.  \\n Again, in this case,  \\n if we click the Run button,  \\n we'll see the same output printed out to the console.  \\n The ability to run a main function in this way  \\n is actually quite convenient.  \\n Any main function in any Kotlin file can be run this way,  \\n making it a very convenient, quick way  \\n of running some Kotlin code from within IntelliJ.  \\n Now that we've run our first code,  \\n we are ready to dive deeper  \\n into the essentials of the Kotlin programming language.  \\n \\n\\n\"}],\"name\":\"1. Setting Up Your Kotlin Development Environment\",\"size\":28958597,\"urn\":\"urn:li:learningContentChapter:3071723\"},{\"duration\":2126,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:3069677\",\"duration\":374,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Mutable and immutable data types\",\"fileName\":\"3008787_en_US_02_01_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to define both mutable and immutable Boolean variables so users can store and update values.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":11600524,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] The ability to store, update  \\n and retrieve values using variables  \\n is a core feature of most programming languages.  \\n So we're going to start our exploration of Kotlin  \\n by learning how to define both mutable  \\n and readonly variables.  \\n To create our first variable,  \\n we're going to come into our empty main function here,  \\n and we going to start by writing val.  \\n Val is a keyword denoting a readonly variable.  \\n Next, we need to type out the variable name.  \\n In this case, we will name our variable, our first variable.  \\n Now we can define a variable's type  \\n by adding a colon and then the type itself.  \\n In this case,  \\n we are going to define this as a type Boolean.  \\n This indicates that we want to store some Boolean value,  \\n essentially true or false.  \\n And lastly to finish off our variable,  \\n we need to provide a default value in this case.  \\n We can do this by adding equals true.  \\n Now we have a readonly variable named our first variable  \\n that holds the value true.  \\n And we can easily validate this by using a print function  \\n to print out the value of the variable.  \\n So we'll come a couple lines down below our variable  \\n and we will invoke the println function by typing println  \\n and we will pass our first variable to that function.  \\n Once we've added the call to println,  \\n we can run our main function by once again navigating  \\n to the green play button in the gutter  \\n and clicking Run MainKt.  \\n Once that function has been run,  \\n we should see true printed out in the output window  \\n on the bottom of our screen.  \\n Now let's say we need to change the value  \\n of our variable after we print it.  \\n How would we do that?  \\n Well, again we'll hit Enter a couple times  \\n and come down below our print statement.  \\n And now we're going to try and assign  \\n the value of false to our variable.  \\n So we'll type our first variable equals false.  \\n You should see the IDE showing a red underline  \\n underneath the variable name.  \\n This indicates a compiler error.  \\n If we place our cursor over that line,  \\n we should see the error message, val cannot be reassigned.  \\n So why are we seeing this error?  \\n Well, a central tenant of Kotlin is an explicit type system  \\n and Kotlin differentiates between mutable  \\n and readonly variables.  \\n By defining our variable using val, we made it readonly.  \\n By default, val variables must be assigned once  \\n and their values will not change.  \\n This makes it easier to reason about the behavior  \\n and the value of the variable,  \\n but also means we can't store mutable values  \\n using a val variable.  \\n To define a mutable variable,  \\n instead of using val, we can use var.  \\n So if we come back up to the definition  \\n of our first variable, we can change the val to a var.  \\n Once we've updated the val to var,  \\n the compiler error went away.  \\n Now, we can add another call to println,  \\n and if we run our program again,  \\n we can verify that the variable is in fact changing.  \\n We first see true printed out,  \\n and then we see false printed out.  \\n In addition to strong typing,  \\n Kotlin supports type inference.  \\n What does that mean for us developers?  \\n It means we don't always have to explicitly define  \\n the type of a variable  \\n if the compiler can understand the variable's type  \\n from the assigned value.  \\n Again, if we go back to the declaration  \\n of our first variable,  \\n we can remove the Boolean type declaration  \\n from our variables in initialization.  \\n Now, even though we don't explicitly declare a Boolean type,  \\n the Kotlin compiler still understands  \\n that our first variable is of type Boolean  \\n because we assigned it a Boolean value of true.  \\n To compare Boolean values,  \\n we can use the equal equals syntax.  \\n Let's add two more print statements  \\n to demonstrate equality checks.  \\n First, we will compare our first variable  \\n to the value of true,  \\n and next, we will compare our first variable  \\n to the value of false.  \\n Before running the code,  \\n take a second to think about the output.  \\n What do you expect to be printed to the console  \\n based on these equality checks?  \\n If we now run our code once again,  \\n we see true, false, false and true  \\n printed out to the console.  \\n The first two lines, true and false  \\n come from our earlier print statements.  \\n And then our two equality checks  \\n printed out false and true respectively.  \\n This makes sense since we set our first variable  \\n to false after the first print statement.  \\n As we continue learning about Kotlin,  \\n we will be building on these concepts  \\n of immutability, type inference and comparison.  \\n As a rule of thumb though,  \\n Kotlin favors immutability by default.  \\n So as we write Kotlin code,  \\n we should think about whether or not  \\n we really need a value to change  \\n before opting into mutable variables.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3073693\",\"duration\":578,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Numeric data types\",\"fileName\":\"3008787_en_US_02_02_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to use different numeric data types to accurately and efficiently represent numeric values.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":18092410,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Numeric data types are essential  \\n for writing almost any application.  \\n Let's jump in and explore examples  \\n of both integer and floating point data types in Kotlin.  \\n Integer data types represent whole numbers.  \\n The easiest example is Int.  \\n To create an Int variable,  \\n I'll once again use the val keyword,  \\n give my variable a name, in this case, aInt,  \\n and explicitly define the Int type.  \\n And then, I will assign it a value of zero to start.  \\n If we want it to be a bit more concise,  \\n we could use type inference to define another variable  \\n without needing to explicitly define the type of Int.  \\n So in this case, I could type, val anotherInt = 0.  \\n And in this case, another Int will simply be inferred  \\n to be of type Int.  \\n In Kotlin, an Int is 32 bits.  \\n If you need a smaller data type,  \\n we have several other options we can leverage.  \\n We could use aByte, which is eight bits,  \\n or we could use aShort, which is 16 bits.  \\n If you need a larger data type,  \\n you could use aLong, which is 64 bits.  \\n By default, integer values that fit within 32 bits  \\n will have an inferred type of Int.  \\n So, if I type, val inferredInt = 10,  \\n this variable will automatically have the type of Int,  \\n because it fits within 32 bits.  \\n If a value is larger than 32 bits,  \\n it will be inferred as long.  \\n So in this example,  \\n we'll type, inferredLong = some very large number here.  \\n So in this case,  \\n this value will be inferred to be of type long  \\n because it's not going to fit  \\n into the standard 32-bit integer value.  \\n Now, if we wanted to store a smaller value  \\n as a long, rather than an Int,  \\n without explicitly adding the long type  \\n to the variable declaration,  \\n we can append an L to the end of our integer literal  \\n to signify that it should be treated as long.  \\n So in this case, we'll define a variable called anotherLong  \\n and assign it to the value of 10L.  \\n This signifies that this value  \\n should be treated as a long rather than an Int.  \\n So far, these examples have all used signed integers.  \\n However, if you need an unsigned value,  \\n there're unsigned equivalents of each integer type.  \\n For example, we can explicitly declare an unsignedInt.  \\n Notice, in this case,  \\n that the Int type is pre-appended with a U  \\n to represent unsigned, and similarly,  \\n the integer literal that we assigned to it  \\n has a U appended at the end.  \\n Additionally, we could use type inference  \\n and specify our integer literal as in unsignedLong.  \\n In this case,  \\n we use both a U and an L in our integer literal  \\n to signify that we want it to be unsigned and long.  \\n Beyond integer types, we also have two floating point types.  \\n A 64 bit double,  \\n and a 32-bit float.  \\n By default, the inferred type  \\n of a floating point number will be double.  \\n So, if I create another variable here called inferredDouble,  \\n and I set it to the value of 5.5,  \\n this value will automatically be inferred to be a double.  \\n If I want my inferred value to be a float,  \\n we can specify that explicitly by adding an f  \\n at the end of the floating point value.  \\n So in this case, we'll type, val inferredFloat = 5.5f,  \\n and in this case, our type will be float.  \\n We can easily compare values between numeric types as well.  \\n We can use equal equals  \\n to check if two values are the same.  \\n So, if we do a simple println here,  \\n and check if 5 == 4, this will let us know  \\n if the value of five equals the value of four.  \\n We could also use the greater than symbol  \\n to check if a value is larger than another.  \\n So in this case, if 10 is greater the than one,  \\n notice that 10 here is explicitly defined to be a float.  \\n And similarly, we could use less than or equal to  \\n to check if a value is smaller than or equal to another.  \\n In this case, 10.1 less than or equal to 5.2.  \\n Now, if go ahead and run these comparisons,  \\n we should see the outputs of each evaluation,  \\n and notice that we see false, true, and false.  \\n This should make sense as five is not equal to four,  \\n 10 is greater than one,  \\n and 10.1 is not less than or equal to 5.2.  \\n In all of these examples, we are able to compare values  \\n without explicitly worrying about their type.  \\n The numeric types will handle any necessary conversion  \\n to ensure an accurate comparison is made.  \\n It's also easy to convert between numeric types.  \\n Most types have available conversion methods  \\n to convert from one type to another.  \\n For example, to convert a double to an Int,  \\n we could do so by using the toInt function.  \\n So, I will type, println,  \\n so we can print out the value of this conversion,  \\n and we'll say, 10.5.toInt.  \\n If we run this code, then,  \\n we'll see that 10 has been printed out to the console.  \\n The conversion from double to Int  \\n effectively drops any decimal place  \\n and gives us just the whole number value.  \\n We could also easily convert from, say, 10.9,  \\n which will be inferred to be a double,  \\n to a float representation of that value,  \\n or, as another example,  \\n we might convert from an integer five to an unsigned long.  \\n While conversion is simple, we must be careful  \\n when can converting a large type to a smaller type,  \\n as we may lose precision in the process.  \\n Let's see what happens  \\n when we try to convert 100 million to a byte.  \\n To start, I'm just going to define a literal for 100 million  \\n using a special syntax that Kotlin provides  \\n for defining numeric literals.  \\n So, I'ma type, 100,  \\n and then, rather than continuing to add more zeros  \\n to my value of 100 million here,  \\n I'm going to use an underscore to effectively represent  \\n where we would put the decimal separator  \\n if we were writing this out.  \\n So, now I'll add three more zeros,  \\n another underscore, three more zeros.  \\n This is all representation of 100 million,  \\n and makes it a little bit easier to read.  \\n And now, if I try to convert this  \\n to a byte using the toByte method,  \\n the compiler has no problems with this.  \\n Now, I'm just going to print this out,  \\n and if we look at the output,  \\n we will see that zero is the resulting value  \\n from this conversion from 100 million to a byte.  \\n This is because the resulting byte  \\n is taken from the least significant bits of the larger long.  \\n While converting from a smaller type  \\n to a larger one is generally safe,  \\n we must be careful we don't lose accuracy  \\n when doing the reverse.  \\n Throughout this course, we'll keep things simple  \\n and use mostly Int and double.  \\n But as you go on to develop more complex applications,  \\n think about the data you're representing  \\n and whether you may be able to represent that data  \\n using a more efficient data type.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3067666\",\"duration\":789,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Char and string data types\",\"fileName\":\"3008787_en_US_02_03_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to efficiently define and manipulate text data types.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":25405427,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] In addition to numeric data types,  \\n most programming languages include support  \\n for text based types as well,  \\n and Kotlin is no exception.  \\n So let's jump in and explore  \\n how to work with text in Kotlin.  \\n To represent a single character,  \\n we can use the char data type.  \\n Char variables can be used to store  \\n a single alphabet character.  \\n Or a single numeric character.  \\n We can also use char to store symbols  \\n such as an escaped new line.  \\n In each of these examples,  \\n the character was defined in a single quote literal.  \\n This is an important distinction to remember  \\n as we eventually work our way  \\n into other text-based data types.  \\n Now, what if you wanted to combine  \\n two char variables together?  \\n Is that possible?  \\n How would we do it?  \\n Let's take a quick look at a couple of options.  \\n The first thing we might try  \\n is to concatenate two chars together.  \\n So we might try that by defining a val  \\n and then saying something like concatOption1  \\n equals a literal plus b literal.  \\n This doesn't work however,  \\n as the plus operator  \\n isn't designed to work with chars.  \\n And this makes sense based on the next example here.  \\n Rather than concatenating two chars,  \\n let's simply define a char literal  \\n with two characters.  \\n So this time, we'll just define that literal to be a and b  \\n within a single, single coded literal.  \\n Again, this fails.  \\n But this time with a more helpful error message.  \\n If we hover over that error message,  \\n we'll see that it says too many characters  \\n in a character literal ab.  \\n The compiler is clearly telling us  \\n that a char data type may only store a single character.  \\n So to store multiple characters  \\n or entire sentences and paragraphs,  \\n we need another data type.  \\n And that's where strings come into play.  \\n String is the go-to data type in Kotlin  \\n for storing multiple characters together at once.  \\n To declare a string variable,  \\n we can use double quotes  \\n to define a string literal  \\n and assign it to our variable.  \\n In this case, we have a string representing the value,  \\n Hello, Kotlin!  \\n We can define two different types of string literals.  \\n The first are escape strings and are what we just saw.  \\n Within escape strings,  \\n we can use escaped characters such as new line  \\n to provide formatting to the screen.  \\n For example,  \\n if we define a string called escaped,  \\n we will be able to insert a new line character  \\n between the string, Hello  \\n and World.  \\n If we then print out  \\n this escaped string,  \\n we'll be able to see that we have a new line  \\n in between these two words.  \\n However, before we do that,  \\n we need to comment out our compiler errors here,  \\n otherwise our program won't compile and run.  \\n So let's go ahead and run our code.  \\n And we will see that Hello \\\\n World  \\n are broken up into two separate lines.  \\n This is because we were able to  \\n insert that new line character  \\n within our string literal.  \\n The second type of string literal is a raw string.  \\n These are strings defined using triple quotes.  \\n These strings allow for extra flexibility  \\n in how they are formatted.  \\n So if we write out a raw string here,  \\n we can add triple quotes.  \\n And then within that,  \\n we can use multiline text here  \\n with different formatting.  \\n By default here, the IDE is going to try and  \\n add this call to trim indent.  \\n Go ahead and remove that for now  \\n so that we can see the raw output.  \\n And once we have our raw string,  \\n we'll go ahead and print that out.  \\n And we'll see in the output here  \\n that our multiline text  \\n is being printed out to the console  \\n just like it was defined in our IDE.  \\n So all of that white space, all of that formatting,  \\n is preserved within this raw string.  \\n If we remove the indentation,  \\n let's say from our first line,  \\n we'll see that that indentation is also removed  \\n from the output.  \\n We can improve this a bit  \\n by adding some type of dilimiter character  \\n to the beginning of each line in our raw string  \\n and then calling trim margin.  \\n So if I come back here to Some,  \\n I will add just the pipe character here  \\n before a couple of our lines.  \\n And then after the trailing triple quotes,  \\n I'll add back that call to trimMargin.  \\n Once again, I'm going to run this code.  \\n And this time,  \\n we will see that the places where we added  \\n the pipe character  \\n are now no longer being printed out to the console  \\n with that prepended space.  \\n So again, this gives us extra means  \\n of formatting these raw strings.  \\n We could also customize this further  \\n by choosing a different margin character.  \\n So rather than a pipe,  \\n we could do let's say,  \\n two angled brackets here.  \\n And then when we call trimMargin,  \\n we can pass in a string literal  \\n representing what we want that margin character to be.  \\n And now if we rerun the code once again,  \\n we'll see we still get that nice trimmed margin formatting,  \\n but this time with those custom margin characters.  \\n Strings can be easily combined and formatted in Kotlin.  \\n To concatenate two strings, we simply use the plus operator.  \\n So in this case, I'll concatenate  \\n Hello plus Kotlin.  \\n If we were to print out this resulting string,  \\n we'll see Hello World printed out to the console.  \\n We can also concatenate non strings with strings.  \\n So in this case, we could create a variable called  \\n concatNumber equals  \\n a string called The number  \\n plus the value of 10.  \\n If we print this out to the console,  \\n we will see that our output has automatically taken  \\n the string representation of that number  \\n and concatenated with the first string literal, The number.  \\n This is a good time to discuss  \\n imutability in Kotlin strings.  \\n A string in Kotlin is imutable.  \\n Once defined, it can't change.  \\n So in these examples,  \\n we are actually creating two separate strings,  \\n then combining them to create a third.  \\n This isn't the most efficient way  \\n to go about this operation.  \\n The more Kotlin idiomatic approach  \\n to this type of string formatting  \\n is to use string templates.  \\n Kotlin allows us to create string literals  \\n that directly substitute in other values.  \\n So for example,  \\n let's say we have some numeric literal called aNumber  \\n holding the integer value of 10.  \\n We could rewrite our numeric concatenation  \\n using a string template this time.  \\n So we'll create a variable called  \\n concatTemplate equals, again, The number.  \\n But this time, we'll create a placeholder in the string  \\n to represent the number.  \\n We can do this placeholder by adding a dollar sign.  \\n And then we will reference  \\n that aNumber variable.  \\n If we print this out to the console...  \\n We'll once again see our expected output.  \\n However, this time,  \\n we didn't have to create multiple strings  \\n to generate this output.  \\n This string templating  \\n works for more complex expressions as well.  \\n If we wanted to, let's say,  \\n always add one to the number before printing it out,  \\n we could add curly braces after the dollar sign.  \\n And within those curly braces in the string literal,  \\n we can then exercise arbitrary expressions,  \\n meaning we can effectively run code in here.  \\n So rather than just always passing the aNumber variable,  \\n we could say one plus aNumber.  \\n If we then rerun our example,  \\n this time we'll see the number 11  \\n printed out to the console.  \\n So this gives us a lot of power and flexibility  \\n to create formatted strings in a more efficient way.  \\n Now, strings are a very common data type  \\n in Kotlin development,  \\n especially if working in user facing domains  \\n such as mobile development.  \\n To make strings easier to work with,  \\n the Kotlin Standard Library  \\n provides many useful functions for us.  \\n For example,  \\n if we define some variable called someString  \\n with the value, Hello there!,  \\n we could check whether that is empty or not  \\n by saying someString.isEmpty.  \\n If we were to print out that result,  \\n you will see false.  \\n Which is likely no surprise  \\n as the someString variable is not empty.  \\n It holds the value of Hello there!  \\n If we wanted to check the reverse of this,  \\n we could use isNotEmpty.  \\n And if we rerun our code,  \\n this time we will see our final output is true  \\n because it is not empty.  \\n If we change the value of our someString variable  \\n to be just a couple of blank spaces  \\n and rerun our code,  \\n this time we see true printed out to the console.  \\n Why do you think that is?  \\n Well it's because the space is still a valid character  \\n even if we can't see it.  \\n So in this case,  \\n multiple blank characters is still not empty.  \\n Alternatively, to isNotEmpty,  \\n we could check isNotBlank.  \\n This time we see falses printed out  \\n because the isNotBlank function  \\n checks for white space characters as well.  \\n So even if there are a hundred white space characters,  \\n isNotBlank is still going to return false.  \\n In addition to helper methods like isNotBlank or isEmpty,  \\n we can also use the contains function  \\n to check if a string contains another string.  \\n So we'll create another variable here called  \\n anotherString equals  \\n Hello Kotlin World!  \\n And if I wanted to check that that string contains Kotlin,  \\n I could do so by typing  \\n anotherString.contains  \\n and passing in the string literal of Kotlin.  \\n There are many other really useful helper functions  \\n on this string type,  \\n and as we proceed through this course,  \\n we will use examples of more of them.  \\n Char and string are our go-to types  \\n for storing any text-based values in Kotlin.  \\n In particular, strings provide a great deal of flexibility  \\n and utility through different literal types,  \\n string templating, and the Kotlin Standard Library.  \\n I encourage you to explore on your own  \\n and see what other useful string functions you can find.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3070631\",\"duration\":385,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Nullable types\",\"fileName\":\"3008787_en_US_02_04_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how Kotlin differentiates between null and non-null data types to take advantage of the null safety features in Kotlin.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":12092075,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] What do we do when we have a variable  \\n whose value is not available at declaration time?  \\n How do you represent the absence of data in Kotlin?  \\n There are a couple of approaches to handling this scenario  \\n but the most basic is the use of null values.  \\n So let's explore how Kotlin differentiates  \\n between null and non-null data types  \\n to avoid the dreaded null pointer exception.  \\n Null is a special value  \\n representing the absence of any real meaningful value.  \\n We can assign null as the value of a variable  \\n when we don't have a good initial value  \\n available to us at declaration time.  \\n Let create a new mutable string variable  \\n by typing var_aNullableString: String = null.  \\n We are attempting to use null  \\n as the initial value for this variable.  \\n However, the compiler is telling us that this is an error.  \\n Why do you think that is?  \\n Well, the answer is that Kotlin differentiates  \\n between nullable and non-null types  \\n and by default, types are non-nullable,  \\n meaning they cannot hold a null value by default.  \\n This is done in an effort  \\n to avoid using null whenever possible,  \\n as null can be the source of many errors in our code.  \\n If we really want to hold a null value,  \\n we can turn any non-null type into a nullable one  \\n by simply adding a question mark after the type name.  \\n After this update, we're now free to assign both null  \\n and non-null values to our variable.  \\n Kotlin defaults to non-null types  \\n because null has historically been the source of many bugs  \\n and headaches in the Java ecosystem.  \\n Most notably, null values can lead  \\n to null pointer exceptions when a null value is accessed.  \\n So if we're going to use nullable types,  \\n we need to be mindful about how we access those values  \\n so we don't crash our applications.  \\n Let's try to print out the length of our variable here  \\n to demonstrate a null pointer exception.  \\n We'll start by removing this line  \\n where we updated the variable value.  \\n And then we'll add a call to println  \\n and we'll access the length property of our string  \\n by typing .length.  \\n Now, if we hover over the dot here,  \\n we'll see the compilers giving us an error.  \\n And in the verbose language, it says  \\n only safe or non-null asserted calls are allowed  \\n on a nullable receiver of type nullable string.  \\n This error is basically a long way of saying  \\n that we're trying to access a possibly null value  \\n in an unsafe way.  \\n To make this code compile and run safely,  \\n there's a few options.  \\n The first option and the least safe  \\n is to add a double exclamation mark  \\n before the property access.  \\n Adding double exclamation asserts  \\n that a value is not null before accessing it  \\n and throws an exception if the value is null.  \\n This makes code easier to write, but leads to crashes.  \\n If we run this code,  \\n we'll get a null pointer exception  \\n printed out to the output here.  \\n This is because we tried to access the length property  \\n on our variable, which is still set to null.  \\n If we update the value of our string  \\n and print out the value once again,  \\n this time we correctly see the output length of that string.  \\n Another option for handling null is to use a null safe call.  \\n Null safe calls will only access a property  \\n or call a method, if the value is non-null.  \\n To demonstrate this,  \\n let's set our variable back to null.  \\n And now, instead of using the double exclamation point,  \\n we will replace it with a question mark.  \\n What do you think will happen now when we run this code?  \\n If you guessed that it would print null,  \\n congratulations, you are correct.  \\n The null safe call will prevent throwing  \\n a null pointer exception in this case  \\n and will actually return null instead.  \\n So now our code doesn't crash  \\n but instead it actually prints the word null  \\n out to the console, which maybe isn't as helpful  \\n or as interesting as we would like it to be.  \\n To improve this,  \\n and that's the Elvis operator.  \\n The Elvis operator allows us to evaluate an expression  \\n and return some default value  \\n if that expression evaluates to null.  \\n So if we place our cursor after the call to .length,  \\n we can add a question mark, colon.  \\n This is the Elvis operator  \\n and now we can provide some default value.  \\n In this case, a string saying the value was null.  \\n What we've effectively done here is told the program  \\n to try and print out the length of our variable  \\n but if the variable is null,  \\n print out this default string instead.  \\n So now if we run our code,  \\n we see the value was null printed out to the console.  \\n If we change the value of our variable to Kotlin  \\n and run it one more time,  \\n we see six, the correct length of the Kotlin string.  \\n Sometimes we have no choice but to use nullable types  \\n and in those situations,  \\n we want to be sure to handle them safely.  \\n So as you continue on with Kotlin,  \\n think carefully when introducing null values.  \\n \\n\\n\"}],\"name\":\"2. Common Data Types\",\"size\":67190436,\"urn\":\"urn:li:learningContentChapter:3069681\"},{\"duration\":2680,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:3073694\",\"duration\":582,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Basic functions\",\"fileName\":\"3008787_en_US_03_01_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn the basics of functions so you can leverage the first-class support for functions in Kotlin.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":14816584,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Narrator] How do we write self-contained  \\n reusable pieces of code that we can then invoke  \\n and reuse throughout our code bases?  \\n Well, in Kotlin we start with functions.  \\n In Kotlin functions are first class concepts.  \\n We can write and use functions  \\n without any kind of enclosing class,  \\n struct, or other obstruction.  \\n Because of this, functions in Kotlin  \\n are incredibly flexible and important.  \\n So let's start by building up our understanding  \\n of function basics.  \\n Here in IntelliJ,  \\n we have an example of our first real function.  \\n This function is our main function.  \\n We've been running this repeatedly.  \\n And in this example, it's going to print out  \\n the string hello world to the console as we've seen before.  \\n Now, let's walk through the key elements  \\n of this first function.  \\n So first off we have the fun keyword.  \\n This represents a function.  \\n This is how we know  \\n that what we are defining is going to be a function.  \\n Then we have the function name,  \\n in this case main.  \\n We have empty parenthesis.  \\n This is where we will eventually put arguments  \\n in our functions so we can pass values to them.  \\n And then we have the function body  \\n which is everything inside of the curly braces.  \\n Now let's write our own function to print out a greeting.  \\n But before we do, has anyone spotted the second function  \\n in our example so far?  \\n Println is also a function,  \\n and it demonstrates how we can call  \\n or invoke a function from within another function.  \\n So now we should be ready  \\n to create our own greeting function.  \\n So again, to create a function,  \\n we're going to start by adding the fun keyword.  \\n Then we're going to add our function name,  \\n in this case, printgreeting.  \\n It's going to take no arguments,  \\n so we'll add an open and closed parenthesis.  \\n And then we will go ahead  \\n and add an empty function body using curly braces.  \\n Now for the body, we will once again, leverage the println.  \\n So I'm going to just copy the println line  \\n from our main function and move it inside of printgreeting.  \\n And now from within main,  \\n we will go ahead and invoke printgreeting  \\n instead of using print line directly.  \\n Now if we run this code,  \\n we should see the same hello world output  \\n that we had before.  \\n However, this time it's getting there in the console  \\n from our printgreeting function that we just wrote.  \\n Now, what if we wanted to return  \\n a meaningful value from our function?  \\n The most basic way is to define a return type  \\n for our function,  \\n and then return a value from our function body.  \\n So let's refactor printgreeting to getgreeting  \\n and return a string rather than printing it.  \\n So, first off we will change the name  \\n from printgreeting to getgreeting.  \\n And now we want to explicitly define  \\n the return type of this function.  \\n To do that, we'll move our cursor after the parenthesis.  \\n And similar to defining the type for a variable,  \\n we will add a colon,  \\n and then we are going to add the string type.  \\n So this signifies that getgreeting  \\n is now going to return a string.  \\n Now within our function body,  \\n rather than printing out hello world,  \\n we're going to use the return keyword  \\n to signify that we're going to return  \\n a value from this function.  \\n And then we will explicitly return the string hello Kotlin.  \\n Now from our main function,  \\n rather than printing out to the console directly  \\n when calling printgreeting,  \\n we will call println and print out  \\n the result of calling our getgreeting function.  \\n And once again, if we run the code,  \\n we'll see hello Kotlin printed out to the console.  \\n Now, you might be asking the question,  \\n why didn't we have to define a return type  \\n for our printgreeting function or for our main function?  \\n Well, the answer is because both of those functions  \\n are inferred to return type unit.  \\n We could rewrite main here to represent this  \\n by adding a colon  \\n and then the unit type after that colon.  \\n Now unit represents a non-meaningful return type.  \\n So it can be explicitly defined as the return type  \\n like we just saw on our main function.  \\n We could also explicitly add a return unit  \\n to the end of our main function,  \\n but both can be omitted to allow for a more concise code.  \\n So you typically wouldn't define a function  \\n that returns unit or return unit explicitly.  \\n Now, another question you might have is do we always  \\n have to explicitly define the return type of a function?  \\n And the answer to this is actually no.  \\n No type is needed if the return type can be inferred.  \\n To demonstrate this we're going to refactor  \\n getgreeting once again.  \\n So rather than explicitly defining the return type  \\n and adding the function body,  \\n we can actually just add an equal sign and then  \\n provide the value we want to return from our function.  \\n So in this case, we've defined it  \\n as getgreeting equals hello Kotlin.  \\n This is known as a single expression function.  \\n And the return type of this will be inferred  \\n to be of type string because the right-hand side  \\n of the expression here will evaluate to a string.  \\n This is very similar to type inference for variables.  \\n This works for unit functions as well.  \\n If we were to once again  \\n type a printgreeting function here,  \\n we could then say println, hello Kotlin.  \\n And this function would be inferred to return unit.  \\n To round out our basic function types,  \\n let's take a look at local functions.  \\n A local function is a function defined  \\n inside of another function.  \\n So let's move our getgreeting function  \\n inside of our main function.  \\n So I'll do that simply by copying  \\n and then pasting that function within main.  \\n So if we run this code once again,  \\n we'll see that it prints hello Kotlin just as it did before.  \\n However, this time we can now longer access getgreeting  \\n outside of the main function.  \\n So if we tried to update printgreeting  \\n to print out the result of getgreeting,  \\n we'll see that we get a compiler area.  \\n It's not accessible in that scope.  \\n A local function may only be called  \\n from within its enclosing function.  \\n So in our case, like we just saw,  \\n that means only main may now call getgreeting.  \\n Why would you use this?  \\n Well, you might use it to organize reused portions of code  \\n within a function without exposing that code  \\n to other functions within the file or the application.  \\n Local functions can scope one function  \\n to only be used by another.  \\n Does that mean all other functions are open for public use?  \\n Well, the answer is kind of.  \\n By default, all functions are public.  \\n That means they are available to use within  \\n any file in the project or any project  \\n that depends on our project.  \\n If we add the public keyword to the printgreeting function,  \\n it won't impact its visibility.  \\n And in fact, if we hover over the public keyword,  \\n we'll see that the compiler gives us this warning  \\n saying redundant visibility modifier.  \\n This is because things are public by default.  \\n However, if we change it to private,  \\n that suggestion by the IDE goes away,  \\n and now only the current file  \\n can access this printgreeting function.  \\n There are additional visibility modifiers as well.  \\n In particular, there is an internal modifier  \\n that makes the function visible  \\n to only the current build module.  \\n But we won't need to rely on that during this course.  \\n As we discussed, functions are a very important part  \\n of the Kotlin language.  \\n Take some time to make sure you're comfortable  \\n writing basic functions.  \\n Try writing your own function to return your name,  \\n your favorite number, or some other simple value.  \\n Once you've written a few functions,  \\n you'll be ready to move on  \\n to even more interesting functions.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3067667\",\"duration\":467,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Function parameters\",\"fileName\":\"3008787_en_US_03_02_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to pass arguments to functions for more interesting results.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":13684407,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Narrator] Functions are more interesting  \\n and certainly more useful  \\n when we can pass values to them that can then be used  \\n within the function's implementation.  \\n With that in mind  \\n let's learn how we can pass argument values  \\n to our functions.  \\n To pass an argument to a function.  \\n We must first define a function parameter.  \\n We can do that by specifying a parameter name  \\n and a type within the functions parentheses.  \\n So let's refactor our getGreeting function  \\n to take in the thingToGreet  \\n rather than just always saying Hello Kotlin.  \\n So within the parentheses  \\n of our getGreeting function  \\n we will first define the name of the parameter.  \\n In this case, we will call it thingToGreet.  \\n And then we will use colon followed by string  \\n to indicate that the parameter should be of type string.  \\n We will then update our return value  \\n to use the past argument value when returning our string.  \\n So we will replace Kotlin with dollar sign thingToGreet.  \\n And if we remember this syntax by using the dollar sign  \\n and then the name of our parameter here  \\n we will substitute in whatever argument value  \\n is passed to the function in our returned string.  \\n And now finally, we must pass a value to getGreeting now  \\n when we invoke the function.  \\n So if we come down here into our main.  \\n If I pass in the string Kotlin and run the code  \\n we will see the same hello Kotlin Output  \\n that we've seen before.  \\n Now, we can also add  \\n more than one argument to a function as well.  \\n So let's further refactor getGreeting  \\n to take in the greeting as well as the thingToGreet.  \\n So again, here I'll come into the parentheses.  \\n I'm going to hit space once  \\n just to give myself a little bit of room.  \\n And I'm going to name this new parameter greeting  \\n and it will also be of type string.  \\n And now I separate my parameters by using a comma.  \\n And then once again here now I will replace the  \\n hard coded Hello string  \\n and use a substitution here  \\n with the greeting parameter value.  \\n And now I will also update the invocation of getGreeting.  \\n And this time I will pass the string hello.  \\n And go ahead and run the code one more time.  \\n And we'll see again that we have preserved our same  \\n Hello Kotlin greeting,  \\n but using our new refactored function.  \\n Now just before moving on, let's look at what we've done.  \\n Notice that the syntax is generally the same here  \\n whether we're using one parameter or multiple.  \\n The only real difference is we separate the parameters  \\n with a comma,  \\n and then we have to pass both values  \\n when invoking that function.  \\n Sometimes a parameter may have a sensible default value.  \\n For example  \\n maybe our default greeting should always be Hello.  \\n For situations like this  \\n Kotlin allows us to provide a default argument value  \\n for a parameter.  \\n Parameters with default argument values can be omitted  \\n when invoking the function.  \\n Let's update getGreeting  \\n to use world as the default thing to greet.  \\n So to add a default parameter  \\n we're going to come to the parameter definition in our list.  \\n And after the type  \\n I'm going to add an equals  \\n and then the string literal World.  \\n Once we do this, we can now remove  \\n the passing of Kotlin to our getGreeting function below.  \\n And if we run the code,  \\n we'll now see that it prints out Hello World,  \\n rather than Hello Kotlin.  \\n If we give a default value to both parameters  \\n then we can invoke getGreeting without passing anything.  \\n So we will update getGreeting to have  \\n a default for the greeting as well.  \\n And I'm just going to refactor this a little bit  \\n to make it easier to follow here.  \\n I'm just going to split the arguments onto their own lines.  \\n And now after the greeting parameter type  \\n I will add equals Hello  \\n as the default greeting.  \\n Now I can remove any argument value  \\n being passed to getGreeting,  \\n and run this again.  \\n And this time we will see Hello World  \\n printed out to the console.  \\n If I instead passed in Hey,  \\n and ran this again.  \\n Now I see Hey World.  \\n With our current getGreeting function.  \\n What would happen if we only wanted to change the value  \\n of thingToGreet?  \\n We could pass a single string to our function  \\n like we just did,  \\n but how would the compiler know  \\n that we want that value to be associated  \\n with thingToGreet rather than greeting?  \\n The short answer is that  \\n the compiler doesn't know that by default,  \\n if we were to pass let's say World  \\n to our function here,  \\n the output is going to be World World  \\n which isn't what we want.  \\n To solve this problem  \\n Kotlin supports a feature called named arguments.  \\n Named arguments let us pass values for specific arguments  \\n by referencing the parameter names directly.  \\n If we want to use the default value for our greeting  \\n but a custom value for the thingToGreet parameter,  \\n we can update our code to reference thingToGreet directly.  \\n So in to do that,  \\n I'll come into the invocation of getGreeting  \\n and I will type thingToGreet  \\n equals.  \\n Now if I run this  \\n rather than printing World World  \\n it prints Hello World.  \\n It now recognizes  \\n that the World string that we're passing to it  \\n should be assigned to the thingToGreet parameter  \\n which means that the default greeting value  \\n will be used for the greeting parameter.  \\n Using named arguments were also then free  \\n to provide argument values  \\n in any order we want,  \\n as long as they're named.  \\n So even though the order of the parameters  \\n is greeting thingToGreet,  \\n we could use named arguments to change the order.  \\n So I could now pass greeting  \\n equals  \\n hey there.  \\n And if we run this again,  \\n we'll see Hey There World printed out to the console.  \\n This combination of default parameter values  \\n and named arguments is really powerful.  \\n It can enable us to write a single function  \\n that can be invoked in many different ways.  \\n Reducing the need for overloaded functions.  \\n Like so many things in Kotlin  \\n function parameters are flexible and feature rich.  \\n By leveraging this functionality  \\n we can write more expressive and powerful functions  \\n with fewer lines of code.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3067668\",\"duration\":686,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Functional types\",\"fileName\":\"3008787_en_US_03_03_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to define functional data types to build a foundation for working with higher-order functions.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":18809314,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Functions in Kotlin  \\n don't require any kind of enclosing class.  \\n They stand on their own  \\n as top-level constructs of the language.  \\n This has interesting implications  \\n for how we write and organize our Kotlin code.  \\n One way in which this is made apparent  \\n is by the fact that functions can be used as data types  \\n in the same way we might think to use string, int,  \\n or any other type.  \\n To illustrate this point  \\n we'll explore how to define variables with functional types,  \\n and how to invoke those function variables.  \\n We can define a variable with a functional type.  \\n Rather than using an explicitly-named type, such as string,  \\n we must describe the function signature  \\n for the function type we want to work with.  \\n Specifically, we must specify what arguments  \\n are needed by the function  \\n and what the return type should be.  \\n So, here in our Main KT file I'm going to hit Enter  \\n a couple times to give myself some space.  \\n I'm going to define a new top-level variable here.  \\n So, we're going to use var so that we can reassign this value,  \\n and we're going to name the variable greetingFunction.  \\n And so, now we need to give this variable a type.  \\n So, again, we'll use a colon  \\n like we have with other variable declarations,  \\n and now we want to define a functional type.  \\n So, like we said, the first thing we need to specify  \\n for this function signature are the parameters.  \\n And in this case, we can specify that this function  \\n should take no parameters  \\n by using open and closed parentheses.  \\n And then next, we need to add a dash and the arrow,  \\n signifying this arrow symbol here.  \\n And then we can specify the desired return type,  \\n in this case, Unit.  \\n So, now greetingFunction is defined to represent  \\n the function that takes no parameters and returns Unit.  \\n Now, for the moment we're not going  \\n to initialize this function.  \\n Instead, we're going to come down into our main  \\n and demonstrate how we would actually call this function.  \\n So, we can invoke our function  \\n in a couple of different ways.  \\n First, we could invoke it just like a regular function  \\n by referencing the name of the variable  \\n and open and closed parentheses.  \\n Or alternatively, we could use a special invoke method  \\n that gets added to any functional type.  \\n These two are equivalent,  \\n and most of the time you'll likely use the first syntax  \\n where you simply invoke the function variable  \\n like it was any other named function.  \\n Now, like we've already said, in both of these cases  \\n we will get an error here  \\n because the function has not been initialized.  \\n This is because we haven't yet defined  \\n what this function should actually reference,  \\n or what it should actually do.  \\n We've simply defined a variable  \\n that will hold a function in the future.  \\n To go ahead and initialize our function variable  \\n we'll come back up to our line here,  \\n and we'll add an equal sign  \\n and then open and closed curly braces  \\n defining the function body.  \\n These curly braces are what's known as a lambda.  \\n Essentially, it represents some function,  \\n some function body that will be executed  \\n when this function is called.  \\n And in this case, this function body  \\n does nothing at the moment.  \\n We could change that by adding a call to println,  \\n and printing a Hello Kotlin greeting.  \\n And now, if we run our code,  \\n we will see Hello Kotlin printed out to the console twice.  \\n If instead of printing it out twice we print it once  \\n and then reassign the function stored by that variable,  \\n in this case, we'll assign it a function  \\n that will say Hello World.  \\n Now, if we print this out we will see  \\n that the first function is run when we invoke  \\n greetingFunction the first time, and we see Hello Kotlin.  \\n Then we reassign the greetingFunction variable  \\n using this lambda here that prints Hello World instead.  \\n And then when we invoke greetingFunction again,  \\n this time we see Hello World printed out to the console.  \\n Notice that when we reassign the value  \\n we don't need to respecify the arguments or the return type.  \\n Those are all already defined in the function signature  \\n when we declared the variable.  \\n Now, like any other function,  \\n we can define functional types that include parameters  \\n and-or return values.  \\n So, let's update greetingFunction to take in a string  \\n for the thing to greet.  \\n So, first, we will update the parameter list  \\n to include the string type,  \\n and then we will update our return type here  \\n to return a string as opposed to returning Unit.  \\n So, now, we want to update the function body here,  \\n and instead of printing out a string  \\n we're going to return Hello $it.  \\n Now, this might look a little bit confusing.  \\n What is this it we are referencing here?  \\n Well, this it parameter here, or this it variable,  \\n is implicitly given name for the parameter  \\n passed to the function.  \\n Any argument passed will be available as it.  \\n However, this isn't always very readable.  \\n And instead, we can often override this naming.  \\n Within the lambda we can introduce thingToGreet  \\n as a named parameter by defining thingToGreet  \\n right after the open curly brace,  \\n and then specifying the arrow operator again here.  \\n So, what this effectively does is renames  \\n that string parameter from the implicitly named it  \\n to this more explicitly named thingToGreet.  \\n And so, now, when defining our string literal here  \\n we will reference thingToGreet directly.  \\n Now, with this in place when we invoke our function  \\n we can pass different argument values  \\n each time we invoke the function.  \\n So, we could pass World the first time,  \\n or we could pass let's say Kotlin an additional time here.  \\n Now, notice below as well  \\n that when we are reassigning our variable here  \\n we have a compiler error.  \\n And again, this is because this is using the old signature  \\n that is returning Unit as opposed to a string.  \\n So, to replace this we could simply change it  \\n from printing the string to implicitly returning the string.  \\n And now notice, in both of these cases  \\n when assigning the function variable  \\n we're returning a string without an explicit return.  \\n This is a special property of lambdas.  \\n Within a lambda you don't have to explicitly return  \\n the value using the return key word.  \\n Whatever the last value is within the lambda  \\n will be implicitly return.  \\n And the last thing to just notice here before moving on,  \\n is that in addition to calling the greetingFunction variable  \\n like a regular-named function  \\n where we pass in the parameter values,  \\n when we call it using invoke  \\n we also have to specify the parameter values as well.  \\n So, any parameters that we add must be passed  \\n whether invoking it directly or using the invoke method.  \\n So, to just illustrate what we've done here,  \\n if we go ahead and run our code one more time  \\n we'll see that nothing is actually printed out.  \\n And this is because we changed our function  \\n to return a string as opposed to printing out a string.  \\n So, if we just update a couple invocations here  \\n we will wrap these calls in println calls.  \\n And now, if we run this one more time  \\n this time we will see Hello World the first time,  \\n Hello Kotlin the second time, and then lastly,  \\n Hello World once again.  \\n Now, just something interesting to notice here,  \\n in our very last invocation  \\n when we called the invoke method we passed in World.  \\n And when we see the output we actually see Hello World!.  \\n So, there's a small, subtle difference here.  \\n When we reassign the value of greetingFunction  \\n we actually are no longer using  \\n the parameter passed into it.  \\n If we changed Hello World! to Hello there  \\n and rerun, it'll be more noticeable  \\n that that second greetingFunction  \\n is not using the parameter passed to it.  \\n So, to update that we could once again use  \\n either the implicit it parameter  \\n made available within the lambda.  \\n Now, we see Hello World! printed out.  \\n And like we did the first time  \\n we defined our function value,  \\n we could make this a little bit easier to understand  \\n by renaming the it parameter as thingToGreet,  \\n adding our arrow operator here,  \\n and renaming the parameter reference within our function.  \\n So, this time if we run this one more time  \\n we see Hello World!.  \\n And if we change this to Kotlin Programming,  \\n run it one last time, we'll see Hello Kotlin Programming.  \\n So, this is a good means of highlighting the fact  \\n that we are reassigning the implementation of that function  \\n every time we update the value of the variable.  \\n So, if we're going to be using functions in this manner  \\n we need to be careful that we implement them consistently  \\n and assign them consistently,  \\n otherwise we might end up with unexpected results.  \\n The ability to store functions as variable values  \\n can be quite useful.  \\n Imagine allowing a user to remap input handlers  \\n to suit their preferences.  \\n The variables holding each input handler could be swapped  \\n to different functions based on user preferences.  \\n This won't be the last time we work with functional types.  \\n Functional types are the foundation  \\n of another powerful feature of Kotlin,  \\n higher-order functions.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3068667\",\"duration\":505,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Higher-order functions\",\"fileName\":\"3008787_en_US_03_04_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to pass a function to another function. This helps you understand how much of the standard library in Kotlin works.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":15210077,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Functions can be used  \\n as explicitly defined types  \\n and functions can take in other typed values as parameters.  \\n So by extension, it might come as no surprise  \\n that we can pass functions as arguments to other functions.  \\n This type of function is known as a higher order function  \\n and is an integral part of the flexibility and power  \\n of the Kotlin standard library.  \\n To help build our understanding of both functions  \\n and the Kotlin standard library,  \\n let's dive in and explore  \\n how to pass a function to another function.  \\n So, in our IDE here, let's define a function  \\n that prints out some calculated value.  \\n So we'll come above our main function,  \\n hit return a couple times to give ourselves some space  \\n and we can start by defining a function  \\n named printCalculatedValue,  \\n and it'll take no parameters to start  \\n and we'll just give it an empty function body.  \\n Next up, we want this function  \\n to take in two integer values.  \\n So we will update our parameter list  \\n to add value1 of type int and value2 of type int.  \\n And again, still leaving the function body blank for now.  \\n Ultimately, these values are going to be used  \\n to calculate some result  \\n that will be printed out to the console.  \\n Next, we want to define a function argument  \\n that will control how the values are calculated.  \\n We do this similar  \\n to how we would define a functional variable.  \\n So within our parameter list,  \\n I'll add another comma after value2,  \\n and I'm going to first define the name  \\n of this functional parameter  \\n and I'll just name it calculator for now.  \\n And then we need to define the functional type  \\n like we would with functional variables.  \\n So, this function signature is going to take in two ints  \\n and then it is going to return some integer value.  \\n You might notice some symmetry here  \\n where we are passing two ints  \\n into the printCalculatedValue function  \\n and then our calculator parameter function  \\n is also going to take in two ints.  \\n Now that we have our parameter list setup,  \\n we can use those parameters to implement the body  \\n of our higher order function.  \\n So like I mentioned before,  \\n we're going to print out some value calculation.  \\n So we'll start with a call to println,  \\n and then we want it to say the value is,  \\n and then now we're going to use a string substitution here,  \\n so I'll use dollar sign, open and close curly brace.  \\n And now within the substitution,  \\n we want to make use of the past calculator function  \\n to calculate the value and then print that out  \\n in our string here.  \\n So to do this within our template here,  \\n we can use the name of the calculator function  \\n and just like we did with function variables,  \\n we can pass in value1 and value2  \\n to this calculator function.  \\n So now, when printCalculatedValue is invoked,  \\n we are going to print out the value is,  \\n and then whatever the result  \\n of that calculator function might be.  \\n This will make much more sense in a moment,  \\n once we see how we would actually call this function.  \\n Once our function is implemented, we can start using it  \\n and this is where it gets fun.  \\n In the most straightforward invocation, we need four things.  \\n We need to use the name of the function to invoke it  \\n and then we must pass in the first and second value.  \\n So to start, we'll pass in two and two  \\n and then finally we need to pass in a Lambda  \\n that matches the function signature  \\n that we define in printCalculatedValue.  \\n So remember that function signature says  \\n that our function argument  \\n must take in two int arguments and return an int.  \\n So, I will add a comma here.  \\n I'm going to add open and closed curly braces for my Lambda.  \\n And then within that Lambda,  \\n I'm just going to rename those parameters as value1, value2  \\n and then I will use the arrow symbol here.  \\n And now we can define the calculation.  \\n We can actually define the body of this function  \\n that we're passing to printCalculatedValue.  \\n So in this case, we're going to do value1 plus value2.  \\n So this function that we're passing to printCalculatedValue  \\n is going to add up the two values passed  \\n to printCalculatedValue.  \\n And now if we run this code,  \\n we see the value is four, print it out to our console.  \\n So we passed in two and two  \\n and the function that we passed as well,  \\n added those two values  \\n and then that calculation was used  \\n to print out the string the value is four.  \\n So that is a pretty basic example  \\n but what if we wanted to instead subtract the values  \\n rather than adding them?  \\n Well, we could invoke this function again  \\n but with a different implementation of the Lambda this time.  \\n So again, we'll call printCalculatedValue,  \\n pass in two and two.  \\n And this time within our Lambda,  \\n we will say value1 minus value2.  \\n And if we run it, this time we see the value as four  \\n from our first invocation  \\n and for the second invocation, we see the value as zero  \\n because two minus two is zero.  \\n This is the power of higher order functions.  \\n Being able to define this one printCalculatedValue function  \\n by giving it the flexibility  \\n to take in another function  \\n that actually determines how the calculation is performed.  \\n This makes it very flexible for us to define strategies  \\n or how certain pieces of algorithms should behave  \\n while being able to customize  \\n other portions of those algorithms.  \\n Now, the current invocations of these functions  \\n is a little bit verbose.  \\n It requires making sure the Lambda  \\n fits nicely within the parentheses  \\n when calling printCalculatedValue.  \\n While this is very easy for simple functions,  \\n it breaks down for more complex ones  \\n where we might have more lines of code.  \\n It makes it harder to read.  \\n This is where trailing Lambda syntax comes into play.  \\n Trailing Lambda syntax allows us to move  \\n the final Lambda of a parameter list  \\n outside the parentheses.  \\n Now, what does this mean in practice?  \\n Well, if we were to refactor the invocation  \\n of printCalculatedValues,  \\n what we could do here is actually move the final parentheses  \\n after the second integer value we passed in  \\n and pass the Lambda outside of those parentheses.  \\n So we can see here, the difference  \\n between the first invocation of printCalculatedValue  \\n and the second one.  \\n In the second one, the parentheses only include two and two  \\n and then the Lambda goes after.  \\n In the second one, the Lambda goes within the parentheses.  \\n The first version here is trailing Lambda syntax  \\n and it makes it feel a little bit more fluent  \\n when we're writing out these functions  \\n that take a function argument.  \\n By applying this trailing Lambda syntax,  \\n we moved the function Lambda outside those parentheses  \\n which makes it look more like a traditional function body.  \\n This often makes the Lambda more readable  \\n and easier to understand.  \\n Higher order functions are a very common pattern  \\n within the Kotlin standard library  \\n and within idiomatic Kotlin code in general.  \\n As you work through this course or read other Kotlin code,  \\n keep an eye open for examples of higher order functions  \\n and think about how they support flexible expressive code.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3071718\",\"duration\":55,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Challenge: Write a name formatter function\",\"fileName\":\"3008787_en_US_03_05_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"This video challenges you to produce a practical example of a higher-order function.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":1830501,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" (upbeat music)  \\n - To help reinforce the concepts of functions,  \\n functional types and higher order functions,  \\n here's a challenge for you.  \\n Write a function to print formatted names to the console.  \\n This function should take two strings  \\n representing first and last name,  \\n and it should take a function format parameter  \\n that controls how the actual formatting is done.  \\n Your function should use the result  \\n of the formatting function parameter to print  \\n out the formatted name to the console.  \\n When testing your code, try calling your function  \\n more than once using different format functions each time.  \\n This should help highlight how higher order functions  \\n can help extract specific decision making  \\n out of a function's core algorithm,  \\n allowing for more reusable functions.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3068668\",\"duration\":385,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Solution: Write a name formatter function\",\"fileName\":\"3008787_en_US_03_06_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, explore the solution to the challenge: write a name formatter function.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":12839956,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" (bright upbeat music)  \\n - [Instructor] How did the challenge go?  \\n Were you able to write your Name Formatter?  \\n There's plenty of ways we could implement such a function.  \\n So let's just explore one such implementation  \\n of a Name Formatter higher order function.  \\n First, I like to start by just stepping  \\n out the implementation by defining the function name.  \\n So in this case,  \\n I'll define my function name as printformattedname.  \\n And I'll start with empty parameter list  \\n and an empty function body.  \\n Then we can start to think about  \\n how we want to use this function.  \\n We want to format a first and last name  \\n so it makes sense to include  \\n both a first and last name parameter to our function.  \\n And because names are commonly text we'll use string types.  \\n So we'll add a first parameter of type string  \\n and a last parameter of upstream.  \\n Now we're ready for the interesting bit.  \\n We want to pass a function that will format  \\n our first and last names  \\n and then return that formatted value.  \\n So what should our formatting parameter type be?  \\n Well, I'll start by just adding the name  \\n for that formatting function parameter.  \\n And then when we think about the parameters,  \\n we probably should have two inputs,  \\n one for first name and one for last name,  \\n and both of these will be of type string.  \\n And we want to format these in some way  \\n and return a value to print out to the console.  \\n In reality, we could return any type we wanted  \\n but since we're working with names and console output,  \\n a string return type is appropriate.  \\n So I'll finish off the function type definition here  \\n by indicating that it should return a string.  \\n So putting all these pieces together,  \\n we're now ready to implement the body of our function.  \\n We will use a call to print ln,  \\n and we will simply pass in the result  \\n of calling the formatter function  \\n and passing in first and last to that formatting function.  \\n So whenever print formatter name is called,  \\n the formatting function passed to it will be invoked  \\n passing first and last name to that function.  \\n That formatter will return a string and print formatted name  \\n will print that string to the console.  \\n Let's now test our function by creating  \\n two different format functions, and we're going to store them  \\n as variable and then invoke our function using each one.  \\n So let's start by defining a basic formatter  \\n of type function, taking two strings and returning a string.  \\n And now we'll define our Lambda and I'll name the parameters  \\n first and last, just to be consistent.  \\n In our basic formatter, we will return first space last.  \\n And now we'll define one more function variable here  \\n and we will call this one Fancy formatter.  \\n And again, it will take two strings  \\n and return a string.  \\n And this time again,  \\n we'll name the parameters first and last.  \\n And for this one's body  \\n we want this one to be a little bit more interesting.  \\n So this one, we will say first name is $first  \\n and last name is $last.  \\n So this will give us a much more verbose output  \\n to demonstrate.  \\n Once our formatter variables are defined,  \\n we can use those to call our name formatter function.  \\n So we'll come down into main,  \\n and we will call print formatted name  \\n and I will use my first name, Nate, my last name Ebel,  \\n and I will pass in basic formatter.  \\n Because we stored basic formatter  \\n as a variable representing a function,  \\n we can pass it in to print formatted name  \\n because the function types match.  \\n And if we wanted to demonstrate  \\n with the fancy matter again,  \\n I can pass in my first and last name.  \\n And this time I'll pass in fancy formatter.  \\n If we run this code now, we will see that  \\n for the first invocation using basic formatter,  \\n it simply prints first and last name.  \\n And for the second invocation  \\n when we passed in fancy formatter,  \\n we can see the more verbose output printed to the console.  \\n And just to round out the example here,  \\n we don't have to predefine the functions  \\n that we're going to pass to print formatted name.  \\n If we wanted to, we could once again  \\n call print formatter name.  \\n But rather than passing a function  \\n in that we predefined like basic formatter  \\n or fancy formatter, we could use trailing Lambda Syntax  \\n once again, and we could pass in a function on the fly.  \\n So I will name the parameters here first and last.  \\n And now when I return the string for this formatting  \\n maybe we'll do it in reverse order.  \\n So we'll do last, comma first.  \\n And if we run this now,  \\n we see that our third example successfully prints out  \\n last name, comma, first name.  \\n So this shows off the power of higher order functions.  \\n We defined one print formatted name function  \\n and can now use it in a variety of ways  \\n to control how that formatting is done  \\n without impacting the core logic  \\n of printing out that formatted name.  \\n \\n\\n\"}],\"name\":\"3. Working with Functions\",\"size\":77190839,\"urn\":\"urn:li:learningContentChapter:3068673\"},{\"duration\":3236,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:3073695\",\"duration\":775,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"if and when statements\",\"fileName\":\"3008787_en_US_04_01_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to change control flow using both if and when statements so conditional logic can be defined and run.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":21956797,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] How do we define conditional logic in Kotlin?  \\n For this problem, we have two primary tools: if and when,  \\n both of which can be used as both a statement  \\n or an expression.  \\n An expression returns a values,  \\n whereas a statement does not.  \\n To better understand that this distinction  \\n between statement and expression,  \\n and to learn more about conditional logic,  \\n let's take a look at the basics of both if and when.  \\n If in Kotlin behaves pretty much  \\n just like any other language.  \\n We provide some Boolean expression.  \\n In this case, we could say if true  \\n and if it evaluates to true, which this always will,  \\n some line or block of code will be run.  \\n So in this case, we will print out The condition  \\n was true if this condition evaluates to true,  \\n which it will.  \\n So when we print out this code,  \\n we see the condition was true printed out to the console.  \\n Now, if statements can be written with  \\n or without curly braces.  \\n If we want to run multiple lines of code  \\n in response to some condition,  \\n curly braces can help us organize that code  \\n and make it more readable.  \\n So let's just refactor our if statement here  \\n and after the parentheses  \\n where the Boolean expression lives,  \\n we'll go ahead and add open and closed curly braces.  \\n Now, within those curly braces,  \\n now we are free to define whatever logic we want.  \\n So I could create a variable called message  \\n and assign it the value of complex logic here.  \\n And then we could go ahead  \\n and print that message out.  \\n And again, if we run our code,  \\n we'll see complex logic here printed out to the console.  \\n Within the if, we can perform various logical comparisons  \\n or evaluate any arbitrary expression  \\n as long as it evaluates to a Boolean value.  \\n So again, let's create a variable here.  \\n We'll call this someVariable  \\n and we'll assign it the value of zero for now.  \\n And now within our if, we could check that someVariable  \\n is greater than three.  \\n And then if it is greater than three,  \\n we will print out the value was greater than three.  \\n So if we run this,  \\n we see nothing because someVariable  \\n is in fact not greater than three.  \\n If we change someVariable to the value of five,  \\n and run again,  \\n this time we see the value was greater than three.  \\n If we want to run some code  \\n if the conditional evaluates to true,  \\n and some other code if it doesn't,  \\n we can use an else block.  \\n So after the curly braces of our if condition,  \\n we could add an else  \\n and we could print not greater.  \\n So if we run with a value of five,  \\n we see the value was greater than three.  \\n And if we change our variable back to zero and rerun,  \\n we see not greater printed out.  \\n And just like with the if condition,  \\n the else block can also be wrapped in curly braces  \\n to make it easier to read  \\n and to support adding more complex logic down the line.  \\n We don't have to stop at a single if condition either.  \\n We can combine multiple ifs together using else if.  \\n So we could print out the value was greater than three  \\n if someVariable is greater than three.  \\n We could also print out using else if someVariable  \\n greater than two.  \\n We could say the value was greater than two.  \\n So now we have three conditions.  \\n One thing if the value is greater than three,  \\n another if it's greater than two,  \\n and an else if neither of those is true.  \\n So let's try this again.  \\n We'll start with zero.  \\n We see not greater printed out.  \\n If we change someVariable to one,  \\n we still see not greater.  \\n If we change it to three,  \\n this time we see the value was greater than two  \\n because three is not greater than three,  \\n so the first condition is not met.  \\n However, the second one,  \\n someVariable greater than two is met.  \\n And finally, if we change someVariable  \\n to five and run this one more time,  \\n now we see the value is greater than three.  \\n And this time, the first if is evaluated to true,  \\n which means it's printed out.  \\n And notice that even though technically multiple conditions  \\n would be true here because five is greater than two  \\n and it's greater than three,  \\n only one branch will be evaluated.  \\n So the first matching Boolean expression  \\n is the one that will be used in this if,  \\n else if, else block.  \\n Aside from if else,  \\n the other conditional construct Kotlin provides  \\n is that of when.  \\n When can be used in a couple of different ways.  \\n First off, when can be used  \\n as a replacement for if else.  \\n So we'll just demonstrate that now  \\n by removing the if else statements  \\n that we just created and now we're going to use a when instead.  \\n So to use a when, we'll start with the when keyword  \\n and we'll add open and closed curly braces here.  \\n And then we can add different expression values to evaluate,  \\n similar to the if else.  \\n So we could say when someVariable  \\n is greater than three,  \\n followed by the arrow operator here.  \\n So this will say if someVariable is greater than three,  \\n do what is ever on the right-hand side of the arrow.  \\n In this case, we will print out the value  \\n was greater than three.  \\n And then just like before, we'll add another one here  \\n that says someVariable greater than two.  \\n Println, the value was greater than two.  \\n And lastly, we can add else conditions as well,  \\n and we could print out not greater.  \\n So now again, before we run this,  \\n let's just take a moment to review  \\n what we've done here.  \\n Conditions are supplied on the left side  \\n of the arrow and then the code to run  \\n if the condition is a true  \\n is applied on the right-hand side.  \\n And these conditions, just like with if else,  \\n are evaluated from top-down  \\n and only a single one will be evaluated and run.  \\n This is very analogous to switch statements found  \\n in languages like C# or Java.  \\n And similar again to if else,  \\n we could wrap any of these code blocks in curly braces  \\n if we needed more complex logic.  \\n So now if I go ahead and run this code a couple times  \\n for the value of five,  \\n we see the value is greater than three printed  \\n to the console.  \\n And if we just change someVariable to zero,  \\n we'll see not greater printed to the console.  \\n The other form of a when statement allows us  \\n to pass in an argument directly.  \\n So that looks something like this.  \\n When someVariable  \\n and then we can define our conditions here.  \\n Why is this syntax useful?  \\n Well, in cases where we might  \\n be supplying multiple conditionals,  \\n all operating on a single variable,  \\n passing the variable into the when allows us  \\n to implicitly reference the variable, saving us code.  \\n So once we pass an argument value to the when,  \\n in this case, someVariable,  \\n we can simplify how we write our conditionals.  \\n To compare the argument value to specific values,  \\n we can simplify specify the target value  \\n on the left-hand side of our when conditional.  \\n So if we wanted to check if the value was exactly two,  \\n we could simply write two  \\n with the arrow and then we will print out the value  \\n is two in that case.  \\n And as with our other examples of if and when,  \\n we can provide multiple conditional cases as well.  \\n So we could also check if the value was three  \\n and if so, print out the value is three.  \\n And if we wanted to handle multiple cases  \\n in the same way, we could combine them  \\n into a single condition using a comma.  \\n So if we wanted to treat let's say zero  \\n and one the same way,  \\n we could do that by putting zero, one  \\n and printing out the value was zero or one.  \\n When working with numeric types,  \\n we can use a when in conjunction with ranges  \\n to check if a value is within some range.  \\n So if we just look at what we've done here,  \\n we've checked if the value is zero or one,  \\n two or three, so now let's say we hand some case  \\n that handles if the value is four,  \\n all the way up to let's say the maximum integer value.  \\n So to do this,  \\n we might think to do something like greater than  \\n or equal to four here.  \\n However, this syntax does not work within this from of when  \\n because we need to have a value on the left-hand side  \\n of that evaluation operator.  \\n So instead, we can use the range here.  \\n So we could say if someVariable is in,  \\n and then we're going to create a range  \\n using a special syntax.  \\n So to start, we will provide the first value of our range  \\n and then two periods and then we define the maximum end  \\n of our range.  \\n In this case, by referencing Int.MAX_VALUE.  \\n So what we've just done here is basically said  \\n if someVariable is in the range of four to MAX_VALUE.  \\n And notice that the IDE is providing some hints here.  \\n It is giving us these little suggestions  \\n that say the range of four  \\n is less than or equal to the value  \\n is less than or equal to Int.MAX_VALUE,  \\n basically calling out that four  \\n and Int.MAX_VALUE are inclusive of this range.  \\n So now we can finish this off  \\n by defining what to do if it's in this range,  \\n in which case, we will print out the value  \\n was greater than three.  \\n So now let's run this new version of our when  \\n or comment out the old version first.  \\n And run our code.  \\n And we see the value was zero or one  \\n when someVariable equals zero.  \\n If we change it to say three,  \\n and run again, we see the value is three.  \\n And let's say if the value was 100,  \\n we see the value was greater than three.  \\n So we're able to hit these different expression values,  \\n whether they be specific values like a two or a three,  \\n a combination of values like zero  \\n and one being handled the same way  \\n or a range of values  \\n as with the final case of four up to max int.  \\n If and when are vital tools  \\n in our Kotlin development toolbox.  \\n We've only just started  \\n to cover the functionality they provide  \\n and we will continue to build on this foundation.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3069678\",\"duration\":439,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Statements vs. expressions\",\"fileName\":\"3008787_en_US_04_02_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how an expression differs from a statement. This helps you to write more concise code.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":12110977,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] If and when can both be used both  \\n as statements and expressions.  \\n So how do we know the difference  \\n in when should we use one form or the other?  \\n To understand the difference and why it's important,  \\n we're going to examine the use of if  \\n and when as expressions to demonstrate  \\n how we can write safer, more concise code.  \\n A statement doesn't return any value.  \\n An expression, on the other hand,  \\n will either have its value returned  \\n from a function or assigned to a variable.  \\n We can use an if-expression  \\n to conditionally assign a variable's name.  \\n So let's create a variable called message,  \\n and then we can use our equals,  \\n and now when we go to assign the value of this variable,  \\n rather than just assigning a static constant here,  \\n we could use an if-expression to change the value assigned,  \\n depending on some variable value.  \\n So let's create a variable, var someVariable equals.  \\n Let's just say zero for now.  \\n So now when we go to assign the value to message,  \\n we could say if, someVariable, greater than three,  \\n \\\"The value was greater than 3,\\\"  \\n else, \\\"The value was not greater than 3.\\\"  \\n Notice that the syntax here doesn't look too dissimilar  \\n from how we've assigned variables or used if in the past.  \\n We create our variable as normal  \\n and after the equal sign, we define our if-expression.  \\n The key difference is  \\n that if-expressions must provide a value.  \\n So they must always include both if and else.  \\n If we tried to remove the else here,  \\n we would get a compiler error on the if, saying,  \\n \\\"if must have both main and else branches  \\n if used as an expression,\\\"  \\n and the reason for this is  \\n that if someVariable is not greater than three,  \\n we have to have some backup valuable to assign to message.  \\n So I'll just put the else back here,  \\n and if we were to just quickly print out the value  \\n of message here, we'll see that if someVariable is zero,  \\n we see \\\"The value is not greater than 3\\\" printed out.  \\n If we change someVariable to five,  \\n we see \\\"The value is greater than 3\\\" printed out.  \\n In addition to variable assignment,  \\n if-expressions can be used when returning  \\n a value from a function.  \\n So let's to demonstrate this  \\n by creating a function called getMessage.  \\n It's going to take an input parameter called Int,  \\n and it is going to return a string,  \\n and so now we could use the return keyword  \\n and use an if-expression to define  \\n what value should be returned here.  \\n So we could say if, input greater than three,  \\n return the value \\\"Greater than 3,\\\" else,  \\n return the value \\\"Not greater than 3.\\\"  \\n So again, this is very similar to the previous example,  \\n but when we go to return the value,  \\n we have to have some return value.  \\n So we define our input greater than three condition  \\n and then an else to ensure  \\n that we always have some fallback value.  \\n Now, this syntax here, this use of if-expressions,  \\n can be combined with single-expression functions  \\n to create a multi-condition function  \\n with a single expression.  \\n So we could refactor this very easily  \\n to a single-expression function  \\n by adding the equals after the parameter list  \\n and then defining our if-expression directly.  \\n So again, now getMessage is a single-expression function,  \\n and that single expression is an if-expression  \\n with multiple conditional branches.  \\n So now let's switch gears,  \\n and let's look at when-expressions.  \\n So I'm just going to clear out the code  \\n in main here for now.  \\n Now, similarly to if-expressions,  \\n when can also be used as an expression.  \\n So I could say val, message equals when.  \\n So now within this when, I could reference  \\n some value or some variable and again,  \\n define different conditional blocks.  \\n So I'll go ahead and, once again,  \\n create a variable called someVariable  \\n and now within my when, I'll say when someVariable is three,  \\n I'll return \\\"The value is 3,\\\"  \\n and notice here that I have a compiler error  \\n over the when, saying, \\\"when-expression must be exhaustive.  \\n Add necessary else-branch.\\\"  \\n So this is the same thing as with the if-expression.  \\n When using \\\"when\\\" as an expression,  \\n we have to return some value.  \\n So in this case, we only have defined a return value  \\n if someVariable is three.  \\n So to complete this,  \\n we need to make this exhaustive by adding an else.  \\n In this case, \\\"The value is not 3.\\\"  \\n Once we've handled that else, or once  \\n we've defined conditions that handle all possible values  \\n of someVariable, then the when will be exhaustive  \\n and the compiler will be happy.  \\n To round out our examples of when-expressions,  \\n we can use when-expressions when returning from functions,  \\n just like we could with if-expressions.  \\n So for example, we could define another function here.  \\n We'll call this fun, getMessageWithWhen.  \\n It'll also take an Int input,  \\n and we can use a when-expression to make this  \\n a single-expression function by saying when, input,  \\n and now we can define our conditional options again.  \\n So we'll say if the value is three,  \\n return \\\"Value is 3,\\\"  \\n else, \\\"Value is not 3.\\\"  \\n This can be a very useful way to concisely implement  \\n a function that needs to map from some input  \\n to very specific output cases and to help make sure  \\n that we handle all of those possible output cases.  \\n Using if and when as expressions allow us  \\n to unify assignment or return with the logic  \\n that determines the value.  \\n This can help us consolidate the conditional logic  \\n and helps us enforce imutability  \\n by allowing the conditional assignment of read-only values.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3068669\",\"duration\":385,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"try/catch as control flow\",\"fileName\":\"3008787_en_US_04_03_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to write safer code using the try/catch expression.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":9786040,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] I don't know about you,  \\n but sometimes, maybe even most of the time,  \\n my code has bugs in it.  \\n Sometimes those bugs throw exceptions  \\n which may crash our programs.  \\n These can stem from things like  \\n trying to perform an operation on a null value  \\n or trying to divide by zero.  \\n There are many ways to work towards preventing these errors  \\n and one of which is try catch.  \\n We're going to continue  \\n by looking at how we can use try catch as an expression  \\n to write more concise, error safe code.  \\n So let's take a look at an example here.  \\n Val message = \\\"the value is ${10 / 0}\\\".  \\n What do you think will happen if we run this?  \\n If you guessed that our code will crash,  \\n you are correct.  \\n Dividing by zero throws an arithmetic exception  \\n which crashes our application when we run it.  \\n Try catch lets us catch these thrown exceptions  \\n without crashing and respond to them in some useful way.  \\n If we wrap this code in a try catch,  \\n so we'll type try with open and closed curly braces,  \\n then go ahead and place our variable assignment  \\n within that again  \\n and then we will add catch.  \\n So within catch, we can define a specific error  \\n such as an arithmetic exception  \\n or in this case, I'll catch any throwable  \\n thrown by the code.  \\n So in the case of an error,  \\n we want to do something with that,  \\n so we will print out error was thrown.  \\n Now, if we run this code,  \\n we don't crash.  \\n Instead, we see our error message, error was thrown.  \\n There's an issue here though.  \\n Handling the error in this way,  \\n branches the normal execution of our code.  \\n Sometimes a potential error  \\n might be expected and recoverable.  \\n In cases like that, we can use try catch  \\n as an expression to streamline the error handling  \\n and reduce the number of logical branches in our code.  \\n So let's refactor this to use try catch as an expression  \\n to reduce the branching here.  \\n So let's delete this for now  \\n and we're going to rewrite this  \\n using try catch as an expression.  \\n So again, I'll use the same message variable name  \\n and this time when we go to assign the value,  \\n we'll say equals  \\n and then we're going to use the try catch here.  \\n So within the try, we'll say the value is,  \\n and once again, we will perform  \\n our invalid divide by zero calculation here.  \\n And then now, when we catch the error,  \\n we will say error was thrown  \\n and below this, we will print out the message.  \\n So what we've done here is sort of unified  \\n the logical branches in this code.  \\n So now we're always going to assign a single value  \\n to our message variable.  \\n If the division did not throw an exception,  \\n then we would see the value is  \\n and whatever that successful value was.  \\n And in the case where we do get some error,  \\n we're always going to get a consistent error message.  \\n So now when we go to print out our message,  \\n we can be sure that it's always going to have a value,  \\n either the successful calculation or the default.  \\n And if we run this,  \\n we will see that error is thrown is called.  \\n And if we just update that calculation,  \\n this time we'll just say 10 / 1 instead of zero,  \\n this time we see the value is 10 printed out.  \\n Now, before we round out this section,  \\n I just will highlight the fact  \\n that in this case, we are catching any throwable,  \\n even if we know that we expect an arithmetic exception.  \\n So just to demonstrate  \\n that we could catch a more specific exception here,  \\n we'll change throwable to ArithmeticException  \\n and we will change back our one to a zero  \\n so that our exception will be thrown again.  \\n And once again, if we run our code,  \\n we'll see that error is thrown.  \\n Now, if we want to throw some other exception here,  \\n we'll just say IllegalStateException, just for fun.  \\n Now, if we run our code,  \\n we still see an exception being thrown.  \\n This is because our catch  \\n is no longer catching all exceptions.  \\n So if we changed this back to any throwable and reran it,  \\n we would once again see error is thrown.  \\n If we wanted to still treat ArithmeticException differently,  \\n we could also catch multiple exception types here.  \\n So we could say error, IllegalStateException  \\n and in this case, we could say error was IllegalState.  \\n Now, if we run, this time we see  \\n the more specific error message printed out.  \\n So this is often a good practice  \\n to not catch all exceptions  \\n and handle them all the same way.  \\n Often we want to think about specific exceptions  \\n and handle them differently,  \\n depending on how we may or may not  \\n be able to recover from them.  \\n As you write your code,  \\n think about what errors you might expect.  \\n Are there places where rather than crashing  \\n or generically catching the crash,  \\n you could provide a sensible default value  \\n if one of these errors occurs?  \\n If so, you might consider  \\n whether you can use a try catch expression  \\n to streamline this error control flow.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3071719\",\"duration\":704,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Smart casting\",\"fileName\":\"3008787_en_US_04_04_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how smart casting can help you to write more concise, safer code.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":20181165,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Sometimes we may want conditional logic  \\n that runs only for certain data types.  \\n Perhaps we want to print one message  \\n if our variable is an int,  \\n and another message is our variable is of type string.  \\n In a production code base,  \\n having to repeatedly make these kinds of type checks  \\n can result in verbose, difficult-to-follow code.  \\n To help alleviate this issue,  \\n Kotlin includes the notion of smart casting.  \\n To help us understand the power of smart casting,  \\n we're going to first look at how to cast a value  \\n to a specific type  \\n and then we'll see how the Kotlin Compiler  \\n can help do this for us in some situations.  \\n So if we come into our IDE here,  \\n to understand smart casting,  \\n we must first understand the concept of casting in general.  \\n To cast a value means that we explicitly change the type  \\n of the variable or property  \\n to some new specific type.  \\n So let's say that we have a variable here  \\n called aGenericVariable  \\n and it is going to be of type Any  \\n and we will assign it a value of five.  \\n Now, we know this value is always five.  \\n So we might want to assign this value  \\n to an int variable so it's easier to work with,  \\n specifically as an int.  \\n So we could say val anIntVariable  \\n equals aGenericVariable.  \\n Notice, however, that when we do this,  \\n we get a compiler error.  \\n If we hover over the error,  \\n we see type mismatch.  \\n Required:int, Found: Any.  \\n To make this assignment work,  \\n we need to cast the Any to an int.  \\n We can make this kind of cast  \\n by using the as keyword  \\n and then specifying the type that we want to cast it as.  \\n So now we're assigning a generic variable  \\n as type Int to our anIntVariable.  \\n Now we can work with our int variable  \\n as the more specific integer type.  \\n Now, you might ask yourself  \\n what happens if we try casting from incompatible types.  \\n Well, let's take a look.  \\n Instead of casting the value five to an int,  \\n we will change aGenericVariable  \\n to be some string value.  \\n Now, after changing the value to a string,  \\n notice that the code still compiles.  \\n However, if we run this code,  \\n we'll see that the code crashes due  \\n to a thrown ClassCastException.  \\n This is happening because we cannot cast string  \\n to an int.  \\n So now that we have some basic understanding  \\n of casting, let's explore the reverse.  \\n How can we check the type of a value?  \\n Well, let's start  \\n by stubbing out a simple function called checkType.  \\n checkType will take one parameter called input of type Any.  \\n And we'll leave an empty function body to start.  \\n Now, let's say we want to print out a specific message  \\n if the input argument is a string data type.  \\n How do we do this if the parameter type  \\n is not specifically of type string?  \\n To perform a type check,  \\n we can use the is keyword.  \\n When combined with a conditional,  \\n we can run code only if our input is a string data type.  \\n So within our checkType function body,  \\n we could say if input is String,  \\n println Input is a String.  \\n Similarly, we could check if input  \\n is not an int, for example.  \\n If input not !is Int,  \\n println Input is not an Int.  \\n So now we'll come back down to our main function  \\n and we will go ahead and just remove this second line here  \\n that was throwing the exception before.  \\n And now we will call checkType.  \\n And so we will pass in our GenericVariable to checkType,  \\n and we're going to run this code  \\n and see what's printed out.  \\n So notice when the code prints out  \\n that it says input is a string.  \\n Input is not an int.  \\n So let's just change the value of our GenericVariable here.  \\n Let's change it to be five.  \\n And run the code again.  \\n And this time, we see nothing printed out  \\n because it's not a String  \\n and it is an Int.  \\n So by combining the use of as to cast values  \\n from one type to another,  \\n or is to check if a value is some type or another,  \\n we have a lot of power here  \\n to be able to query and manipulate types as needed.  \\n However, like we said at the beginning,  \\n this can be verbose and error prone.  \\n So now we're ready for smart casting.  \\n Let's say that if our input value is a String,  \\n we want to print the string's length.  \\n If we try to get the length of a string  \\n before the type check,  \\n we won't be able to since the type  \\n at that point is still Any.  \\n So if we just try to do input.length, that'll fail.  \\n That gives us a compiler error  \\n because at this point, input is still of type Any.  \\n Within the conditional, however,  \\n we can access the length property without an issue.  \\n So we could update our message here  \\n to say input is a String with length,  \\n and we can use our template here,  \\n and say input.length.  \\n And now within this conditional that checks  \\n whether input is of type String,  \\n we have no problems accessing the length property.  \\n How does this work.  \\n Why can we access this length property  \\n even if the type of input is still technically any?  \\n Well, the answer is smart casting.  \\n Within our type check,  \\n the compiler knows that the type of input is string.  \\n So it will automatically cast input to type string  \\n wherever it's used within that conditional scope.  \\n So effectively, the compiler here is doing the work for us  \\n of using that as keyword to cast input to type string.  \\n Smart casts work for nullability checks as well.  \\n Let's update our function  \\n to allow for null input parameters.  \\n And our type check to look for nullable strings.  \\n So we will add the question mark to our Any parameter.  \\n So now we can pass null into this if we wanted.  \\n And similarly, we could check if input  \\n is of type nullable string.  \\n You might notice that we now have an error  \\n in our output code.  \\n Input might be null,  \\n so the compiler tells us  \\n that we must now make a null safe call  \\n when accessing input.length.  \\n Smart casting can help with this scenario as well.  \\n Before we print our value,  \\n we're going to return from the function  \\n if input equals null.  \\n Now, notice, as soon as we make  \\n that conditional check for null  \\n and return from the function early,  \\n the compiler now no longer is giving us  \\n the error telling us we need to make a null safe call  \\n when accessing input.length.  \\n The compiler is smart enough  \\n to recognize that if the conditional branch is ever reached,  \\n it means that input is not null  \\n and it will cast it as such for us  \\n so that we don't have to do it.  \\n The same concept would apply  \\n if we were to use an if-else  \\n rather than returning early.  \\n So let's remove our early return here  \\n and then within the conditional  \\n that is checking if the input is a nullable string or not,  \\n we can say if input equals null, else.  \\n So now within the input equals null branch,  \\n we can say println Input was a null String  \\n and we'll come down here.  \\n We'll fix our typo here.  \\n And we'll bring this statement up  \\n into our else branch.  \\n And now as soon as we bring that into the else branch,  \\n we again no longer have any type of null safe warning  \\n on the call to input.length.  \\n So again, the compiler here  \\n is smart casting in a couple of ways.  \\n First, it's helping us ensure that input is of type string  \\n and it's also helping us ensure the input is not null.  \\n And to round out this discussion,  \\n smart casting works with when statements as well.  \\n So we could remove the code in our checkType function here  \\n and we're going to redo some of that now with a when.  \\n So we could say when input  \\n and the first condition we'll check here  \\n is whether the value is null.  \\n And if it is null, we will print out Input was null.  \\n Then next up, we can check if input is String,  \\n in which case we will print out Input was a String  \\n of length input.length.  \\n So again here, when we make our check  \\n that input is of type nullable string,  \\n we no longer have to do any type of null safe call  \\n on input because smart casting  \\n will help us ensure that that is going  \\n to be a non-null string.  \\n And if we go ahead and just run our code one more time,  \\n we can verify this.  \\n So with an input of five,  \\n we see nothing printed out.  \\n If we were to pass null to our check input call,  \\n we see input was null printed out.  \\n And if we pass in a string,  \\n in this case, a string saying null,  \\n we see input was a string of length four.  \\n So all of these different conditional branches  \\n are working as expected  \\n and in a null safe and type safe way.  \\n Smart casts are an incredibly helpful feature  \\n of the Kotlin programing language.  \\n By automatically inferring and casting types for us,  \\n the compiler helps us ensure type safety,  \\n while also allowing us to write less code.  \\n As we continue through this course,  \\n smart casts will crop up from time to time.  \\n See if you can notice where they are used.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3070632\",\"duration\":317,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"while loops\",\"fileName\":\"3008787_en_US_04_05_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to execute repeated tasks using a while loop.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":8215892,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] In nearly any complex application  \\n the need will arise to perform some repeated operation.  \\n This could be repeating a task a certain number of times  \\n or repeating for every item in some range or a collection.  \\n Let's explore one mechanism for this type  \\n of repeated operation, the while loop.  \\n While loops in kotlin behave very similarly  \\n to other programming languages.  \\n First, we need to define some counter value.  \\n So in this case, we'll create a variable called counter  \\n and assign it the value of zero to start.  \\n Next we set up the looping condition.  \\n In this example, we'll set up our loop to run five times  \\n by checking whether our counter is less than five or not.  \\n So we can do that by using the while keyword  \\n and then our condition in this case is going to be,  \\n counter less than five,  \\n and then within open and close curly braces  \\n here we can define what we want to do  \\n on each iteration of the loop.  \\n If we were to run this code now,  \\n our loop would never terminate  \\n since we never update the value of our counter variable.  \\n So we must be careful to increment  \\n the value of the counter within our loop body.  \\n This will ensure that eventually the counter  \\n becomes equal to five and the loop will terminate.  \\n Now that our loop should properly terminate,  \\n let's add before the incrementing of the counter,  \\n a print statement that will print out  \\n the value of that counter.  \\n So now if we run our code,  \\n we should see the values from zero to four  \\n printed out to the console.  \\n Sometimes we might want to break out of a loop early.  \\n If we're within a function,  \\n we could possibly just return our desired value to break  \\n out of the loop, but that doesn't apply to all situations.  \\n For a more general approach,  \\n we can use the break keyword to terminate our loop early.  \\n We can quickly demonstrate this by breaking out of our loop  \\n once our counter is equal to three.  \\n Now if we run this, we'll see that we only get  \\n the first three values of our loop printed out.  \\n As soon as that counter value hits three  \\n we break out of the loop and return from our main function.  \\n Using break effectively can be a good way  \\n to avoid doing unnecessary data processing in our code.  \\n The while loops we've been working with so far  \\n evaluate their condition before ever executing  \\n the loop body.  \\n If we need to ensure a loop is run once  \\n this form of while loop requires setting up a counter  \\n that always evaluates to true at least one time.  \\n This isn't overly difficult but it's potentially error prone  \\n and semantically doesn't match the intention of a loop  \\n that must always run at least once.  \\n For scenarios like this  \\n we can use a do while loop  \\n instead of the regular while loop.  \\n So let's just go ahead and clear out  \\n this existing implementation of our loop  \\n and we're going to leave our counter for now.  \\n So now instead of starting the loop by defining  \\n the when keyword in our looping condition,  \\n we instead start using the do keyword  \\n and then the body of the loop itself.  \\n So in this case again  \\n we will print out the value of counter  \\n and then we will increment our counter by one.  \\n This time using a plus equals operation,  \\n as opposed to using the plus plus operation  \\n that we used before.  \\n This body that we've just defined after do  \\n will always run at least once.  \\n Lastly, we now need to set up our loop condition.  \\n So we get do that by adding while again  \\n and we can define the condition we want to check.  \\n So let's say we want to run this loop  \\n while counter is greater than one.  \\n So intuitively here, if counter is starting at zero  \\n we might not expect this loop to run.  \\n However if we go ahead ahead and run our code  \\n we'll see that it runs one time.  \\n And this is because in the do while version of a loop,  \\n the loop body will always execute at least once.  \\n So, in this case we'll start with zero.  \\n We'll print zero to the console,  \\n increment the counter by one.  \\n And at that point, one is not great than one,  \\n so the loop will terminate.  \\n If we update our condition to check that the counter is  \\n say less than five, we'll see that our output  \\n now matches the basic loop implementation  \\n that we saw in our very first example.  \\n While loops are a straightforward way  \\n to repeat blocks of code times.  \\n And like many things in kotlin  \\n there are multiple forms of a while loop  \\n to help fit different types of looping use cases.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3072723\",\"duration\":229,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"for loops\",\"fileName\":\"3008787_en_US_04_06_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to execute repeated tasks using a for loop.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":5792664,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] For loops are one of the most common  \\n programming language constructs across all languages  \\n for repeatedly running a block of code.  \\n In Kotlin, we can use four loops in a variety of ways,  \\n depending on our specific use case.  \\n Let's start off with the basics  \\n and explore how to repeat tasks  \\n using some simple for loops.  \\n In the most basic of for loop,  \\n we're typically iterating over some range of values.  \\n And in Kotlin,  \\n generating a range of values is quite simple  \\n using several available functions and operators.  \\n Let's start by creating a loop to iterate from zero to five.  \\n So we'll start off by using the for keyword.  \\n And in this case,  \\n we are going to define I as our counter variable,  \\n which will automatically be incremented  \\n based on the specific range.  \\n That range is then going to be defined  \\n using the until function.  \\n So we'll first say,  \\n I in to specify that we want I to be iterated  \\n over the values in the upcoming range.  \\n And now,  \\n we will define that range by saying zero until five.  \\n Until is a special type  \\n of function called an infix function.  \\n We'll dive deeper into how we can write  \\n our own infix functions in a little while.  \\n For now,  \\n it's enough to know that the until function  \\n creates a range of values from zero to four.  \\n And so now,  \\n after we've defined the set of values  \\n that we will iterate over,  \\n we need to define what to do each time it's iterated.  \\n So in this case, we will simply print out the value of I.  \\n If we run our code,  \\n we'll see the values zero through four print out  \\n to the console.  \\n If we wanted to include five in our range,  \\n we could replace the until function call  \\n with another syntax, which is to use two periods.  \\n This syntax also creates a range,  \\n but this time, it is inclusive on both sides.  \\n So both zero  \\n and five will be include in the range of values  \\n that we iterate over.  \\n If we run the code,  \\n we'll now see that five is print out  \\n to the console as well.  \\n We could also configure our range to count down  \\n if we would like.  \\n So we could say,  \\n for I in the range of 10 down to zero.  \\n Now we see all the values from 10 down to zero.  \\n Ranges also let us control how to increment  \\n our counter by using the step function.  \\n So in this case,  \\n if we wanted to count from 10 down to zero by three  \\n as opposed to the default of one,  \\n we could come back inside our parentheses.  \\n And after we define the range, we can say step three.  \\n So now, what we've done here is defined a loop.  \\n We say 10 down to zero by three effectively.  \\n And again, step is another infix function here.  \\n If we run this, now we'll see 10, seven, four, and one.  \\n So again,  \\n of values from 10 down to zero,  \\n but this time, we're jumping three each time.  \\n This only scratches the surface  \\n of iterating with for loops in Kotlin.  \\n As we continue through this course  \\n and learn more about arrays, lists, and other collections,  \\n we'll revisit different forms of for loop  \\n for iterating over these data types.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3072724\",\"duration\":72,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Challenge: Replace an if/else expression with a when expression\",\"fileName\":\"3008787_en_US_04_07_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"This video challenges you to produce a practice example of how control flow in Kotlin may differ from other languages, such as Java.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2540715,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" (upbeat music)  \\n - [Instructor] Time for another challenge.  \\n This time, we want to get some hands-on practice  \\n with using when expressions  \\n as a more Kotlin idiomatic way of writing conditional logic.  \\n Examine the provided function, getOutput.  \\n This function takes in some input value  \\n of type nullable Any  \\n and returns an output string  \\n to later be printed to the console.  \\n This function is implemented  \\n as a single-expression function using an if/else expression  \\n to provide a return value.  \\n If we run this code,  \\n we will see various outputs printed out to the console,  \\n telling us useful information  \\n about all the different input types  \\n provided to the getOutput function.  \\n Your challenge is to refactor this getOutput function  \\n so that instead of an if/else expression  \\n as the function body, it uses a when expression.  \\n When you're done,  \\n the output resulting from running the main function  \\n should be unchanged.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3069679\",\"duration\":315,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Solution: Replace an if/else expression with a when expression\",\"fileName\":\"3008787_en_US_04_08_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, explore the solution to the challenge: replace an if/else expression with a when expression.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":10866333,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" (gentle upbeat music)  \\n - [Instructor] How did the challenge go?  \\n Did you find when expressions any easier  \\n or more difficult to use than if else expressions?  \\n Let's walk through one approach  \\n for refactoring the given function to a when expression.  \\n The easiest way to convert  \\n the if expression to a when expression  \\n is actually to use the IntelliJ tooling  \\n and have the IDE perform the refactor for us.  \\n If we move our cursor  \\n and click on the if in the if else expression  \\n of our getOutput function  \\n and then hit Alt + Enter,  \\n we'll see that there is an option  \\n to replace if with when.  \\n If I hit Enter on that,  \\n it will actually automatically convert  \\n the if else expression to a when expression for us.  \\n How does this solution look  \\n compared to the one you came up with?  \\n While the IDE tooling is the easiest way  \\n to refactor the code,  \\n it's not the most instructive.  \\n So we're going to go ahead and just revert that change  \\n and walk through a manual refactoring  \\n so we can talk through some of the details.  \\n So I'm actually going to start out  \\n by commenting out the existing function.  \\n (keyboard clicks)  \\n We'll save it here as a reference  \\n of what we need to build towards,  \\n but this will let us build out a new getOutput function  \\n without having to worry about changing names  \\n or anything like that.  \\n Next, I want to set up a new version of the function  \\n using a when expression  \\n as the single expression function body.  \\n So we're just going to stub this out.  \\n So again, we'll say fun_getOutput.  \\n We'll take in our single input here.  \\n (keyboard clicking)  \\n We will define our String return type,  \\n and this time we'll say equals when (input)  \\n and now we have our when expression,  \\n but no conditions in it yet.  \\n At this point,  \\n the compiler is going to complain to us  \\n that we must provide an else block.  \\n This is because a when expression must provide some value.  \\n So we have to ensure  \\n that there is at least some fallback value  \\n if no conditions are met.  \\n So let's go ahead and add our base case  \\n to match what was present in the if else version.  \\n So we'll say else \\\"Input didn't match target inputs\\\"  \\n So now we will have at least some value  \\n always returned when getOutput is called.  \\n Now that our base case is accounted for,  \\n we can go down the list of if else cases  \\n and translate them into our when expression.  \\n We'll start by adding a condition  \\n to check for the number type.  \\n We'll do this by saying is Number  \\n within that conditional block,  \\n we can still use the if else expression  \\n from the old code.  \\n So we can copy that over.  \\n So I will just grab this.  \\n I'm going to uncomment it,  \\n copy it, comment it again,  \\n (keyboard clicking)  \\n and add that to our is Number condition.  \\n (keyboard clicking)  \\n Next up we have the String case.  \\n So we'll say is String.  \\n And in that case, we will return  \\n \\\"Input was a String with ${length input.length}\\\"  \\n And notice again here we're accessing input.length.  \\n Smart casting is kicking in for us  \\n so that we don't have to worry about validating  \\n whether input is null or not.  \\n And lastly, we can check for null explicitly  \\n by adding a null case  \\n and returning the string \\\"Input was null\\\"  \\n So we'll just kind of compare this to the old version.  \\n We've handled the non-Int case,  \\n we've handled the non-Int Number case.  \\n We copy that code directly over.  \\n We've also handled the String case,  \\n the null case, and the base case.  \\n So now we'll just go ahead and remove that old function.  \\n And if we run our main function once again,  \\n we should see the same outputs that we expected  \\n from the original implementation of getOutput.  \\n So what do you think about when expressions?  \\n There's no hard and fast rule  \\n for when to use a when expression  \\n over an if expression.  \\n Both can be used to accomplish the same things  \\n and it largely comes down to personal preference.  \\n However, when expressions do have some additional benefits  \\n for exhaustively enumerating close types,  \\n which we'll explore soon  \\n when we dive into object-oriented programming with Colin.  \\n \\n\\n\"}],\"name\":\"4. Control Flow Structures\",\"size\":91450583,\"urn\":\"urn:li:learningContentChapter:3068674\"},{\"duration\":1181,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:3070633\",\"duration\":327,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Setting breakpoints\",\"fileName\":\"3008787_en_US_05_01_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to set breakpoints to pause and inspect execution of code at a specific point.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":10405195,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] How do we fix our code  \\n when something isn't working right?  \\n Usually, we need to start by understanding  \\n which lines of code might be causing the problem.  \\n While we sometimes might intuitively understand the issue,  \\n we often find ourselves needing  \\n to debug our code line by line  \\n to track down those hard-to-squash issues.  \\n Thankfully, IntelliJ has a number  \\n of built-in tools to help this debugging process.  \\n We're going to start building up our debugging toolbox  \\n by learning how to set breakpoints in our code  \\n and run the bugger to inspect the execution of code  \\n at those breakpoints.  \\n Now, before we dive too deeply into the tooling,  \\n let's make sure we are all on the same page  \\n when we say debugging.  \\n For me, debugging is anything I can do  \\n to help understand why my code isn't working.  \\n That might be reading through code line by line,  \\n talking through my code with my rubber duck,  \\n or using my debugging tools such as Logging  \\n or other IDE tooling.  \\n That then brings us to the debugger.  \\n Most modern IDEs have some form of debugging toolset.  \\n These tools are designed to help us find  \\n and fix issues in our code.  \\n These tools might help us inspect a local database,  \\n examine the value of a variable  \\n at a specific point of execution in our program  \\n or pause the entire execution of the program.  \\n One of these common tools are breakpoints.  \\n Breakpoints tell the debugger  \\n to suspend execution of our program  \\n at a specific line of code.  \\n When the program is suspended,  \\n we can then examine the current state of our application.  \\n So let's set our first breakpoint.  \\n And before we do, let's go ahead  \\n and examine this code that we'll use to test this concept.  \\n So we have a loop here iterating  \\n from the range of zero up to four.  \\n And on each iteration, we're generating a random int  \\n and then we are calculating whether that random value  \\n is even if or not.  \\n And then we will print out  \\n whether the value is even or odd.  \\n Now, there's a bug in this code  \\n that is likely readily available  \\n as soon as we run that code.  \\n So let's go ahead and run that code now.  \\n And if we examine the output here,  \\n we see that we have a value ending in five,  \\n which is marked as even,  \\n a value ending in seven, marked as even,  \\n a value ending in six marked as odd,  \\n another ending in six, odd,  \\n and one ending in eight, which is odd.  \\n So as we see this, we can see pretty obviously  \\n that our logic for calculating  \\n whether the value is even or not is backwards.  \\n To help understand what's going on in this code,  \\n we're going to set a breakpoint on the line  \\n where we define our isEven property.  \\n This will let us pause execution of our program  \\n after our random number is generated.  \\n To set the breakpoint,  \\n move your cursor to the left-hand gutter  \\n in between the line number and the code,  \\n and click in that gutter space.  \\n This should result in a red circle icon being added.  \\n So we want to place that breakpoint  \\n on the line six here  \\n where we're calculating our isEven value.  \\n If we start our application then with the debugger,  \\n when we hit this breakpoint,  \\n or any other breakpoint,  \\n that line of code in the application  \\n will be suspended.  \\n To hit our breakpoint then and examine the code,  \\n we need to run our code  \\n with the debugger attached.  \\n The easiest way to do this  \\n is to hit the Debug button in the toolbar.  \\n Here it is in between the two sort  \\n of green play icons.  \\n If I hover over it, it says Debug MainKt.  \\n Now, you can also find it by going  \\n to the menu at the top, go to Run and select Debug.  \\n Once the code starts,  \\n the debugger tool window has opened down  \\n at the bottom of the screen here  \\n and it should show the line  \\n with our breakpoint being highlighted.  \\n So this blue line here is indicating  \\n that the code has suspended on that particular line.  \\n If we look down at the tool window,  \\n we'll then see two main items of interest.  \\n We can see a stack trace on the left side  \\n of that tool window showing which points  \\n in the application have been hit so far.  \\n We also see the value of all our in-scope variables  \\n on the right hand of that tool window.  \\n In this case, we see the value of our counter  \\n and we see the current random value.  \\n The debugger and breakpoints are extremely valuable tools  \\n for Kotlin developers  \\n and there's even more functionality to leverage  \\n when debugging our code.  \\n We'll see later how we can build  \\n on this concept of breakpoints  \\n to inspect our code  \\n and to learn more information  \\n about how our code is behaving.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3068670\",\"duration\":552,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Stepping through code\",\"fileName\":\"3008787_en_US_05_02_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to step through code execution to better diagnose and fix issues.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":16860281,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Speaker] Okay, once we've stopped execution  \\n of our code at a break point, what next?  \\n How can we efficiently inspect our code  \\n and walk through the execution of our program  \\n to find the issue?  \\n Let's take a closer look at the debugger tools  \\n to understand how to step through code line by line,  \\n and how to set conditional break points  \\n that only pause execution under specific circumstances.  \\n So again, we will use this same loop function here  \\n to test out these debugging tools.  \\n And again, just as quick review,  \\n this code will iterate over a range from zero to four,  \\n generate a random number,  \\n and should ideally print out correctly whether  \\n that number is odd or even.  \\n And we also still have a single break point  \\n in this code here placed on the line where we determine  \\n whether our value is odd or even.  \\n If we now run our code with the debugger attached,  \\n we'll see that the debugger stops at that break point  \\n when calculating whether the value is odd or even.  \\n Now, what if we want to pause execution  \\n at more than one place in our code?  \\n Let's say we want to pause only  \\n in the true branch of our win statement.  \\n We can set another break point just on that line  \\n with the true conditional.  \\n Then down in the debug window,  \\n along the left-hand side of the menu,  \\n we can click the green resume program button.  \\n This will allow the code to continue running  \\n until the next break point is hit.  \\n And now we see that that second break point is highlighted  \\n in the execution window.  \\n By placing break points at specific points  \\n throughout our code, you can repeatedly resume execution  \\n and hit new break points to better understand the flow  \\n of your system.  \\n Now, what if we want to examine every line  \\n of code in our application?  \\n Do we need to set a break point on every single line?  \\n Thankfully, the answer is no.  \\n Let's clear out our old break points  \\n and add a new one at the very first line within our loop.  \\n So here where we're generating the random integer.  \\n Now, we'll go ahead and run the code again  \\n with the debugger.  \\n And that first break point should be hit  \\n in that first line within the loop.  \\n If we want to execute this one single line  \\n without setting another break point,  \\n we can step over that line  \\n by clicking the step over button in the debug tool window.  \\n That button lives here towards the top  \\n of that tool window next to several arrows.  \\n If we look at the first option,  \\n this is the step over option.  \\n If I click that first icon there,  \\n we'll see the execution has run that first line  \\n of code to generate the next int,  \\n and has now paused on the next line,  \\n which is determining whether that value is odd or even.  \\n By stepping over a line, we allow that line to be executed.  \\n Notice how now in our variables window at the bottom,  \\n the random variable exists in that variables panel  \\n and we can examine the value that was just generated.  \\n We can also do more than just step over things.  \\n So let's pause our program and now we're going  \\n to quickly create a function to extract the logic  \\n of generating our random value.  \\n So I'll just come above the main function,  \\n generate a function called get random int,  \\n and I will simply copy  \\n and paste the random number generation,  \\n and then update the loop to use this new function.  \\n Now, let's run the debugger again  \\n so that once again we stop  \\n at our break point when generating the random integer value.  \\n If we click step over again, we will jump  \\n to the next line and see what the generated value is.  \\n But instead, what if we want to see how  \\n that value is generated?  \\n So I'm going to go ahead and click resume program again,  \\n which will keep running  \\n until the next time the loop comes back  \\n and hits that random number generation.  \\n So this time, instead of clicking step over,  \\n we want to click step into,  \\n which is the second arrow function here  \\n in that debug tool menu.  \\n By clicking step into, we will follow the call stack  \\n and be taken to the body of the get random int function.  \\n So effectively, rather than just calling get random int  \\n and moving to the next line,  \\n we actually move into get random int.  \\n We can then use the step out debug option  \\n to return back to the line  \\n where we were generating the random int.  \\n And now from there, we can go ahead and step over once again  \\n and see what the random number is.  \\n Now, so far, in each of these examples, we've started  \\n by running our program with the debugger attached.  \\n This then results in our first break point being hit.  \\n And we start debugging from there.  \\n But what if our bug only occurs under certain circumstances?  \\n What if we only want to start debugging  \\n once our counter is greater than two?  \\n We could simply run the debugger  \\n and click resume multiple times  \\n until we get to the counter value of two.  \\n Or we could set a conditional break point.  \\n Conditional break points are break points  \\n that only pause our application  \\n if a certain condition is met.  \\n In this case, if our counter is greater than two.  \\n So to set a conditional break point,  \\n let's start by setting our break point as usual.  \\n So in this case, I am going to remove the one  \\n on the random number generation  \\n and set a break point instead where we determine  \\n whether it is odd or even.  \\n Next, I'm going to right-click that break point  \\n and this brings up this tool window here,  \\n which will allow us to define a condition  \\n for this break point.  \\n So within this condition box here,  \\n we can define the conditional logic and we have access  \\n to all the variables and properties  \\n that are within the same scope of this break point.  \\n So in our case, we want the condition to be I greater than  \\n or equal to two.  \\n So our break point will only stop then  \\n as soon as our I counter from the loop is greater than  \\n or equal to two.  \\n Once we're satisfied with the condition, we can click done.  \\n And now, if we run our code again with the debugger,  \\n we'll see that our break point is hit,  \\n but it's only hit once I equals two.  \\n If we click resume again, we'll see I equals three.  \\n I equals four.  \\n And the program terminates.  \\n Now, to round out this discussion  \\n of conditional break points, we're going to right-click  \\n on our break point once again.  \\n And we'll see that in this menu here,  \\n there are several other options.  \\n We could choose to enable or disable the break point  \\n by clicking the enabled box.  \\n We can also choose whether to suspend all threads  \\n when a break point is hit, or just a particular thread.  \\n By default, all threads are selected, which makes it easier  \\n to debug application in a multi-threaded program.  \\n However, there are situations where you might not want that  \\n and you could customize that here if needed.  \\n These debugging tools give us the flexibility to step in  \\n and out of function calls, step over lines of code,  \\n and repeatedly pause  \\n and run our code under specific conditions  \\n so we can understand where things went wrong.  \\n Have you ever been in a situation  \\n in the past where you wished you could pause  \\n and inspect your code?  \\n Would any of these tools have helped?  \\n Knowing how  \\n to efficiently use these tools will make a huge impact  \\n on how quickly you can diagnose problems in your code.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3066643\",\"duration\":302,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Evaluate expressions and add watches\",\"fileName\":\"3008787_en_US_05_03_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to evaluate arbitrary expressions and add them as watches to speed up the debugging process.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":9205402,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - As we debug our code  \\n we're often inspecting values and calculations  \\n to understand if they are working as expected.  \\n Sometimes we might have questions  \\n that the current code can't answer  \\n as it's currently written.  \\n In these cases, we might wish  \\n that we could quickly perform a calculation or query  \\n using the current frame of the application  \\n without having to actually make a code change and redeploy.  \\n We can address this exact scenario  \\n by using the evaluate expression tool and by adding watches.  \\n So to demonstrate both of these tools,  \\n let's rerun our code to the first break point once again.  \\n And then we we are going to step over our code  \\n to the point where the random value is generated.  \\n And in this case,  \\n we've actually already set our break point to that point  \\n so we see the random value down here  \\n in our debug tool under the variables section.  \\n Now, we have a line of code at this point  \\n that already checks if the generated random value  \\n is even or not.  \\n But what if we wanted to check  \\n if the value is divisible by three or by five,  \\n if the value is divisible by three or by five,  \\n do we have to update the code again  \\n and redeploy it and then check?  \\n Thankfully, no.  \\n We can use the evaluate expression tool.  \\n So in the debug tool window, in the upper toolbar,  \\n there should be a little icon  \\n that looks something like a calculator.  \\n And as a hover over here,  \\n we'll see that it says, evaluate expression.  \\n We're going to open up this tool.  \\n And now within this, we have access to all the variables  \\n and everything else within the scope of the application  \\n at this point of suspension in the debugger.  \\n And then we can use this tool  \\n to calculate the value of random expressions  \\n that we might want to evaluate  \\n and see how our code might behave  \\n under different circumstances.  \\n So by default here, we see random is entered in  \\n and if we click evaluate,  \\n we will see what the current value of random is.  \\n If I type random.rem(3)==0 and click evaluate,  \\n If I type random.rem(3)==0 and click evaluate,  \\n I can see result equals false.  \\n So, this suggests that the random value  \\n is not divisible by 3.  \\n This tool can dramatically speed up debugging  \\n by allowing us to evaluate expressions like this  \\n and answer questions that might come up  \\n as we step through our code.  \\n All without needing to actually update the code,  \\n redeploy it and get back to this current debugging state.  \\n If we find ourselves performing  \\n the same evaluations repeatedly,  \\n we can turn that expression into what is known as a watch.  \\n The watch will become a part  \\n of the current debugging session  \\n and be updated accordingly  \\n anytime a dependent value changes,  \\n it's kind of like creating a virtual variable.  \\n So let's take the case of checking  \\n whether our random value is divisible by 3 or not.  \\n So we can come down into our tool window  \\n and in the variable section  \\n where it says evaluate expression or add a watch,  \\n I'm going to place my cursor  \\n and I'm going to type in that same  \\n random.rem(3)== 0 expression.  \\n random.rem(3)== 0 expression.  \\n So again, checking whether the current random value  \\n is divisible by 3 or not.  \\n But this time, I'm going to come over to the right  \\n and where this little plus icon is  \\n that says add to watches,  \\n I'm going to click this.  \\n We see, as soon as I add that to watches,  \\n now this expression is showing up in our variable section.  \\n And so now, if I resume execution of the code,  \\n each time I hit this break point,  \\n we'll see that our random value changes  \\n and then by extension, our watch changes as well.  \\n So this is why I said earlier, it's like a virtual variable.  \\n So this lets us continuously see  \\n as we run through our code with the debugger  \\n whether or not these random values are divisible by 3.  \\n So I'll click it again.  \\n We'll see this one is not,  \\n again, this one is also not.  \\n And we'll just click through until the code finishes  \\n and that's it.  \\n Both of these tools,  \\n whether it's evaluating an expression  \\n or adding an expression to be a watch  \\n and seeing it update every time we hit a break point  \\n are incredibly useful.  \\n And it's good to practice with them  \\n and to understand when and where to use them  \\n during your debugging sessions.  \\n However, it's perfectly okay to pick one or two  \\n of these debugging tools that we've covered to start with  \\n and get more familiar with new ones  \\n as you practice and as you need them.  \\n \\n\\n\"}],\"name\":\"5. Debugging Kotlin Code\",\"size\":36470878,\"urn\":\"urn:li:learningContentChapter:3070639\"},{\"duration\":3564,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:3068671\",\"duration\":836,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Arrays\",\"fileName\":\"3008787_en_US_06_01_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn basic and advanced arrays and when to use them.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":23941270,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Let's discuss how we store  \\n collections of data in Kotlin.  \\n The most basic data structure  \\n for this is an array,  \\n which behaves very similarly  \\n to arrays in other programming languages.  \\n Let's take a look at how to create  \\n and work with arrays in Kotlin.  \\n An array is a collection of values,  \\n typically of the same type.  \\n Let's say we wanted to store five integer values,  \\n we could do so using the arrayOf function.  \\n If we passed in five comma separated values here,  \\n this will create an array of size five  \\n with the elements 1 through 5,  \\n the type of the array  \\n will be inferred to be array of non-null int.  \\n If we replace the last value 5  \\n and instead use null,  \\n then the inferred type of the array  \\n will be nullable int.  \\n The array of function is smart enough  \\n to recognize whether we are mixing nullable  \\n and non-null values.  \\n If we want to create an array  \\n of some given size,  \\n and initialize it with all null values,  \\n we can use array of nulls.  \\n So we could say, val nulls  \\n = arrayOfNulls,  \\n and we want that to be nullable ints,  \\n and we say 5 initial values.  \\n So calling arrayOfNulls here,  \\n specifying the int type,  \\n and passing 5,  \\n will create an array  \\n of size five with five null values,  \\n and it will support us adding int values in the future.  \\n So this will let us hold nulls or ints.  \\n Alternatively, if we want to initialize an array  \\n in some other way,  \\n so another way besides specifying every value upfront  \\n or making everything null upfront,  \\n we can call the array constructor,  \\n and provide an initialization Lambda  \\n to define how each value should be initialized.  \\n So in this case,  \\n we'll create a variable here called custom,  \\n and we will call the array constructor  \\n with 5 as the size of the array  \\n and then we will define the open  \\n and closed curly braces here  \\n to define our Lambda.  \\n This Lambda is going to let us initialize  \\n the array however we want  \\n Within that Lambda,  \\n it's going to pass us an integer value  \\n representing the index in the array.  \\n So for us, with an array of size 5  \\n we will get indexes zero through four,  \\n and in this case,  \\n with values zero through four,  \\n so we will just return  \\n the index value itself  \\n and that'll be our entire Lambda here.  \\n So this will initialize the array  \\n with 5 values from zero through four,  \\n essentially creating the same array  \\n as we did in our very first example.  \\n To access the size of an array,  \\n we can use the .size property.  \\n So if we created a variable called  \\n sizeOfArray,  \\n we could set that equal to ints.size,  \\n and that would return 5.  \\n To access values in array  \\n we can use get and set methods on the array.  \\n So, if we wanted to get the firstValue  \\n we could call ints.get  \\n and pass 0.  \\n We passed zero because collections in Kotlin  \\n including arrays are zero based,  \\n meaning the first index in any collection is zero.  \\n And similarly,  \\n if we wanted to set a value in the array  \\n we could say ints.set,  \\n we specify the index of the value  \\n we want to set and then a comma,  \\n and then we pass in the value we want to set.  \\n So in this case, I'll pass in 99  \\n and we would set the first value  \\n of that array to be 99.  \\n Now, one of the fun things about Kotlin  \\n is that it provides a lot of syntactic sugar,  \\n to make common operations a little bit easier,  \\n often trying to make them a little bit more concise  \\n or easier to read.  \\n Now, one of these is that Kotlin provides  \\n an index access syntax for working with arrays  \\n that bypasses the need to call  \\n the get or set directly.  \\n So instead of saying ints.get 0  \\n to access the first element in array,  \\n we could actually used square brackets here  \\n and pass in the index that we want.  \\n And similarly, rather than saying  \\n ints.set 99,  \\n we could say ints[0] = 99.  \\n So this are equivalent,  \\n they're going to use the same code underneath the hood,  \\n but it's just a little bit of syntactic sugar  \\n that the compiler provides to us  \\n to make it a little bit easier to read  \\n and quicker to write.  \\n If we need an array of some primitive types  \\n such as int or short,  \\n Kotlin provides additional array types  \\n specifically designed for storing values as primitives,  \\n rather than storing them  \\n as their larger complex object types.  \\n Now, why is this helpful?  \\n It comes down to the size of each type  \\n a primitive int takes up less memory  \\n than int the object.  \\n Most of the time we work with the complex type,  \\n but if we know we will be working  \\n with an array of a primitive,  \\n and we think that array might be rather large,  \\n we can take advantage  \\n of this more efficient array.  \\n So to create an array of primitive ints,  \\n we could use the function intArrayOf,  \\n and again we will pass in our same five values.  \\n And similarly, we could create an array  \\n of let's say, unsigned shorts,  \\n and to do that,  \\n we will use ushortArrayOf,  \\n and again, pass in  \\n five unsigned short values.  \\n And here I will just fix my variable typo  \\n before heading on.  \\n This pattern for creating primitive specific arrays  \\n applies not just to int or you ushort,  \\n but to really all the other primitive types as well.  \\n Now, when we create these arrays,  \\n we often then want to process them in some way,  \\n and this often looping over an array,  \\n iterating over all the elements in that array,  \\n and doing something with the values.  \\n So to iterate over items in array,  \\n we have several options.  \\n We can use a basic for loop,  \\n so we could say for i in 0,  \\n until ints.size,  \\n and we will then use that counter i  \\n to access each individual value in the array.  \\n And if we run this code now,  \\n we will see the five values set to our array.  \\n So remember we see 99  \\n because we set the first value in our ints array to 99,  \\n then we see 2, 3, 4,  \\n and null which again we set as the initial value.  \\n Now, alternatively, we can also use  \\n a special element syntax  \\n that allows to iterate over each item directly  \\n without having to manage a counter.  \\n So in this example,  \\n we would say for element in ints,  \\n element is going to be the name  \\n of each value in the array.  \\n So we can call it element,  \\n we could call it index, value, whatever you want.  \\n And now within this,  \\n rather than having to use a counter  \\n to look at the value into the array,  \\n we simply say println element,  \\n and if we run our code one more time,  \\n now we see our list duplicated again  \\n in the console output.  \\n Now our last option for iterating over an array  \\n is a functional option  \\n from the Kotlin Standard Library.  \\n We can use the, forEach function  \\n from the Kotlin Standard Library  \\n to operate on each element of the array,  \\n or any other collection type for that matter  \\n as we'll see elsewhere in the course.  \\n So in this case,  \\n we would say ints.forEach,  \\n and now within this Lambda  \\n we get access to every element in the array implicitly  \\n using it as we often do within a Lambda,  \\n so we could print out it  \\n in this case to print each value,  \\n to make this more readable however,  \\n we could rename that implicit reference  \\n to something like the previous example  \\n where we call it element,  \\n and once again we would print out element.  \\n Now, before moving on,  \\n we're just going to comment out  \\n these last three examples,  \\n just so that we don't confuse ourselves,  \\n when we're looking at the at the output  \\n from our next samples here.  \\n Now, one way in which arrays  \\n are commonly encountered in Kotlin,  \\n is when writing functions  \\n that take a variable number of arguments.  \\n Let's say we want to write a function  \\n that takes in some greeting,  \\n and then prints out a variable number of greetings  \\n based on the arguments passed to it.  \\n So we will write such a function now,  \\n and then play with it a little bit here.  \\n So we will call this function, greetThings,  \\n it will take in a single greeting  \\n of type string,  \\n and this will be kind of our basic stub out function.  \\n So now, how could we finish this function  \\n to allow us to print out  \\n a greeting for multiple things?  \\n Well, one way in which we could do this,  \\n would be to pass an array directly to the function.  \\n So we could do something like  \\n items as a parameter name,  \\n and it could take in an Array of type Any,  \\n and now within the function body  \\n we could say  \\n for item in items,  \\n println,  \\n and here we would substitute in  \\n our greeting argument value  \\n and the item value.  \\n Now this would work fine,  \\n and in fact, if we come up into our Main function,  \\n we could call greetThings,  \\n with a greeting of let's say, Hey,  \\n and we could create an array of things to greet.  \\n In this case, we might say Kotlin  \\n and Programming.  \\n So this works great,  \\n but it requires us to create  \\n a new instance of an array  \\n anytime we call our function.  \\n To simplify this,  \\n we can use the varargs modifier.  \\n So let's look at how  \\n that is implemented first,  \\n and then we'll talk a little bit it more  \\n about what that means.  \\n So down here on our items parameter,  \\n which is an Array of Any,  \\n we're going to add vararg  \\n as a parameter modifier here,  \\n and now instead of items being Array of Any,  \\n we're going to change it to simply Any.  \\n And now notice that the function body here  \\n didn't change at all,  \\n we can still iterate over all of the items  \\n in that it's parameter,  \\n vararg parameters are treated  \\n as arrays by the compiler,  \\n but when we call our function  \\n we can pass the array values directly to the function  \\n without having to create a new array first.  \\n So up here where we have greetThings,  \\n we can pass that array indirectly, if we want,  \\n or we could say greetThings,  \\n this time we'll say Hello,  \\n and this time we can pass in  \\n the things that we want  \\n to greet separately.  \\n So notice in this case,  \\n it's much more fluent.  \\n We don't have to separate out the greeting  \\n and then pass in this separate array  \\n that needs to be instantiated.  \\n We can pass in all of the arguments very fluently,  \\n and the compiler will recognize  \\n that everything after the first argument  \\n belongs to that array of things to greet.  \\n Arrays are a fundamental data type  \\n in any programming language,  \\n and it's important to have  \\n before moving on to other  \\n more complex data structures in Kotlin.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3071720\",\"duration\":597,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Lists\",\"fileName\":\"3008787_en_US_06_02_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to create lists and explore the difference between mutable and immutable collection types. \",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":17944876,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Tutor] Lists are a core data structure  \\n of many programming languages and Kotlin is no different.  \\n Let's dive into some code  \\n and learn to create lists in Kotlin.  \\n Along the way,  \\n we'll work to understand  \\n the difference between mutable  \\n and immutable collection types.  \\n We can create lists in Kotlin in several ways.  \\n The most basic is to use the listOf function.  \\n We can call listOf  \\n and pass in the items that we want to include in the list.  \\n In this case, I'll pass in three strings,  \\n Kotlin, code and puppy.  \\n ListOf is a generic function  \\n allowing us to infer the type of the list items  \\n based on whatever we pass in.  \\n In this case, this will be inferred to be a list of string.  \\n So if we explicitly call this out  \\n we could call this stringList  \\n and it would have a type list of string just like that.  \\n If we wanted to have a listOfInt,  \\n we could say val listOfInt  \\n equals listOf,  \\n and if we pass in all Ints  \\n then the type will be inferred to be listOfInt.  \\n Similarly to arrays, if we then pass a null value here  \\n this would be inferred to be a listOf nullable Int.  \\n If we need more complex initialization logic  \\n for our first elements of the list,  \\n we can use another list builder function  \\n that takes a list size  \\n and an initialization Lambda.  \\n So here,  \\n we'll say listOfInt of size five  \\n and we'll pass in an initialization Lambda.  \\n This is very similar to how we can initialize an array.  \\n So within the Lambda, we will get access  \\n to the index of that element in the list.  \\n I'm going to rename the implicit argument value to index  \\n to make it a little bit easier to understand,  \\n and then to initialize our values,  \\n I want to double the index.  \\n So I will say two times index  \\n and use that as that initial value in the list.  \\n If we assigned this to a variable called doubledValues,  \\n and we then say doubledValues.forEach,  \\n println, it.  \\n If we then print this out,  \\n we will see 0, 2, 4, 6, and eight  \\n all of the indices doubled.  \\n And finally, if we need a simple emptyList of some type,  \\n say, as a default placeholder value  \\n we can call the emptyList function.  \\n So if we wanted a collection called emptyStringList,  \\n we could assign it the result of calling emptyList  \\n of type string.  \\n By specifying the string type explicitly  \\n when calling emptyList,  \\n our empty stringList variable will be inferred  \\n to be a list of string.  \\n If we have this type explicitly defined on the variable  \\n we actually then don't need it when we call emptyList.  \\n So whether it is on the variable type itself  \\n or when calling emptyList,  \\n we can define the type.  \\n We don't have to do it in both places.  \\n Accessing list elements is very similar  \\n to accessing elements from an array.  \\n We can use available getter  \\n and an index to look up a value.  \\n So here we'll define a variable called firstInt equals  \\n listOfInt.get  \\n and we'll pass them the index of zero.  \\n So we're using the getter on our list  \\n passing in the index for the first value,  \\n and we should be able to pull out  \\n that first integer from our list.  \\n Lists also support direct index access using brackets.  \\n So if we wanted to get, let's say the second Int,  \\n we could a listOfInt  \\n and we could use brackets and pass in a one.  \\n So under the hood, this will still use the getter  \\n but this provides us a little bit more concise syntax  \\n to access the elements directly  \\n as opposed to having to call that getter.  \\n We'll explore some additional functions  \\n from the Kotlin Standard Library  \\n for querying and accessing elements  \\n from a collection a little later on.  \\n Now we've seen how to access an element from a list,  \\n but what if we want to update an element  \\n or even add an element to our list.  \\n Let's try adding an Int to our list ofInts.  \\n So if we did something like listOfInt.add,  \\n we'll see that we get a compiler error here.  \\n The IDE can't find any such method add.  \\n Similarly, if we tried to use  \\n say, direct index access  \\n and try to update  \\n the first value in that list to a nine,  \\n same thing, we also get a compiler error.  \\n So what's going on here?  \\n Why can't we modify this list?  \\n Well, the answer is that Kotlin differentiates  \\n between mutable and immutable collection types.  \\n By default list is an immutable type.  \\n It does not allow for updating of values  \\n or for adding and removing of items.  \\n To create a list that can be modified,  \\n we need to use a mutable list.  \\n To create a mutable list,  \\n we can use the mutable list of function.  \\n So let's create a mutable list of programming languages.  \\n So I've got my languages variable,  \\n and now I will say mutableListOf,  \\n and just like before  \\n now I can pass in the items in my list.  \\n So I could say Kotlin and Java to start.  \\n So now I have a mutable list of size two.  \\n But because this is a mutable list,  \\n I can update this however I want.  \\n So I could change  \\n the first item in my list  \\n to be Kotlin with an uppercase K.  \\n Notice here we're using direct index access  \\n and assigning a value directly.  \\n We could also have done languages.set,  \\n and passed in zero  \\n and the value like this,  \\n we can also add an element to the end of our list  \\n by saying languages.add  \\n and passing in whatever string  \\n we want to add to the collection.  \\n So in this case, we'll say JavaScript.  \\n Now there are other types of add methods available to us.  \\n We don't always have to add to the end of a list.  \\n If we wanted to add something to a specific index  \\n we could pass in the index  \\n so that we one add an update  \\n and then pass in the value.  \\n So in this case, we've added C++  \\n as the second item in our list,  \\n by using that one for our index value.  \\n And contrary to adding items  \\n we can remove specific elements as well.  \\n So if we type languages.remove,  \\n we could pass in the specific string  \\n that we want to remove from our collection.  \\n Or if we wanted to remove based on a specific index  \\n we could say removeAt,  \\n and in this case maybe we want to remove  \\n the first item in the list,  \\n we could pass in an index of zero.  \\n Now let's talk a little bit about type compatibility.  \\n Mutable list extends list.  \\n This means if we want to have  \\n some generic list variable here.  \\n So we have aList of type list of string,  \\n we can assign it  \\n the value created by a mutable list function.  \\n So in this case,  \\n I will create a mutable list of values, dog and cat,  \\n and I can assign it to a list variable.  \\n Notice though that once we've done this  \\n we've masked the underlying mutable list type.  \\n We can no longer manipulate our list directly  \\n when working with the aList variable.  \\n If I tried to say aList.add,  \\n we get a compiler error here,  \\n again because the variable itself  \\n is stored as the immutable type.  \\n This is important to remember when deciding  \\n whether to use list or mutable list.  \\n Often we want our public ABI to be immutable.  \\n And so we would choose list.  \\n Whereas within the implementation details  \\n of our class are function,  \\n we might want to manipulate the list,  \\n and so we would choose a mutable list.  \\n Lists are one of the most  \\n common collection types in Kotlin.  \\n And thanks to their API design  \\n and the Kotlin Standard Library,  \\n developers have access to a concise syntax  \\n and a great deal of helper functions for working with them.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3072725\",\"duration\":767,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Sets and maps\",\"fileName\":\"3008787_en_US_06_03_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to create sets and maps and how to write more concise code when working with each.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":24537107,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Now it's time to introduce  \\n two more common data structures,  \\n sets and maps.  \\n Both these data structures are incredibly useful  \\n and widely used.  \\n We're going to explore how to create  \\n and work with both of them.  \\n Like with lists,  \\n the easiest way to create a set in Kotlin  \\n is to use a builder function.  \\n So let's define a variable called languages,  \\n and we want this to hold a set  \\n of programming language strings.  \\n So I will use the setOf function here  \\n and then I need to pass in the strings  \\n that I want to be a part of this set.  \\n So in this case, I'll pass Kotlin, Java and C++.  \\n Oops. Need to make sure that last one is wrapped in quotes.  \\n There we go.  \\n So we have a set of Kotlin, Java and C++,  \\n and because of type inference here,  \\n we don't have to explicitly define the type.  \\n But if we did, that type would look like this  \\n setOf non nullable string.  \\n Now, let's remember what is special about sets.  \\n They don't allow for duplicate elements.  \\n So if we pass Kotlin twice when creating our set,  \\n the final set will only contain one instance  \\n of the string Kotlin.  \\n So if we come back here to our invocation  \\n of the setOf function and we pass Kotlin a second time,  \\n the languages variable will only have one instance  \\n of that Kotlin string.  \\n And we could verify this by printing out each element.  \\n We can print out each element  \\n in much the same way as we can with lists.  \\n So we could use the element for loop syntax here.  \\n And we could say for language in languages,  \\n println language.  \\n Now, if we run this code, we see Kotlin, Java  \\n and C++ printed out to the console.  \\n And notice we only have one copy of Kotlin,  \\n which is exactly what we would expect when using a set.  \\n Like all collections in Kotlin,  \\n we can access the size of our set  \\n by using the size property.  \\n And we can check if an element is contained within this set  \\n by using the contains function.  \\n If we print out the result of this contains invocation,  \\n we see true printed out  \\n because the string Kotlin is present in our set.  \\n If we want to manipulate our set after it's been created,  \\n we need to use a mutable set.  \\n We can create a mutable set  \\n by calling mutableSetOf instead of setOf.  \\n So if I come back up here to our declaration  \\n of our languages variable,  \\n I'll change setOf to mutableSetOf.  \\n With a mutable set,  \\n we can now add elements using the add method.  \\n So if I type languages.add,  \\n here we actually see that we have a compiler error.  \\n This is just a good reminder of the fact  \\n that just because we call mutableSetOf,  \\n it doesn't mean the type of our variable  \\n is automatically immutable set.  \\n Remember, up here,  \\n we explicitly specified that the languages variable  \\n should be of type set, as opposed to mutable set.  \\n So if we change set to MutableSet,  \\n now our add call is recognized by the compiler  \\n and we are free to pass in another language string here.  \\n So if we come back up here,  \\n we could actually simplify this a little bit more  \\n by simply removing that explicit type declaration  \\n and relying on the compiler's type inference for us.  \\n And to mirror the add ability,  \\n we can remove from our set as well, using the remove method.  \\n And in this case,  \\n I will remove that string that we just added.  \\n Our next data structure is map.  \\n A map allows us to store key value pairs  \\n for efficient lookup.  \\n Maps and their different implementations  \\n are one of the most useful data structures available to us.  \\n To create a map,  \\n we'll use the mapOf function and create a read only map.  \\n So to start,  \\n I'm going to create a variable called testScores,  \\n and then we will use the mapOf function.  \\n So this is going to eventually create our immutable map.  \\n And now we need to pass in key value pairs to this function,  \\n and then that will help the compiler infer  \\n the type of the map.  \\n So the most explicit way to pass in these key value pairs  \\n is to create instances of the pair type  \\n and pass those to the function.  \\n So we can do that by writing pair  \\n and then open and close parentheses  \\n to invoke the pair constructor.  \\n And then we simply pass in the key and the value.  \\n So in this case, let's say I pass 123 as a student ID  \\n and 91.2 as a test score.  \\n And then maybe we want one more pair of ID to score in here.  \\n So I'll type pair again.  \\n This time the ID will be 456 and this score will be 84.5.  \\n So now if I hover over test scores here,  \\n we see that its type is inferred to be a map  \\n with keys of type int and values of type double.  \\n Now, creating a new instance of the pair each time  \\n to pass them into the mapOf function is a little verbose.  \\n So the Kotlin standard library includes a helper function  \\n to more concisely create pairs.  \\n We can use this infix function called to,  \\n to create a pair associating the value on the left  \\n and the right.  \\n Now what this looks like is us defining  \\n 789 for a student ID again here,  \\n then writing to and then defining the test score here.  \\n So effectively what we've done with this invocation  \\n is created a new pair and passed in 789 and 79.1 to it.  \\n However, to is an infix function.  \\n So really what we've done here is called the to function  \\n on the value 789 and passed 79.1 to it.  \\n We will look in more depth at infix functions later on.  \\n Once our map is constructed,  \\n we can work with it in several ways.  \\n We can use index to look up  \\n to access the value for a given key.  \\n So if we typed println here and then we said test scores,  \\n we used brackets and we pass in a key value here,  \\n this will print out the value for key 123.  \\n And if we just print that out,  \\n we will see 91.2 as the last output in our console.  \\n And this does map to the test score  \\n that we defined for key 123 in our map.  \\n If we use a standard element loop,  \\n we can access each key value pair individually  \\n and we can get the key or value for that pair.  \\n So we can say for record in testScores  \\n println score for user $,  \\n and now this is where it gets interesting.  \\n So record here is actually returned to us  \\n as a pair, effectively,  \\n or really it's an entry in the map.  \\n So if we type record,  \\n it's not going to be the value itself,  \\n it's going to be an entry representing the key value pair.  \\n So if I want to then get the key for that record,  \\n I would say record.key  \\n and now we can continue on building my output string here.  \\n So we say score for a user.  \\n We substitute in the user ID  \\n was and then this time we'll say record.value.  \\n If we print this out,  \\n we will see each of those key value pairs  \\n printed out to the console in our formatted string.  \\n Having to iterate over each pair  \\n and then dereference both the key and the value  \\n can be a bit repetitive,  \\n so we can make use of destructuring syntax  \\n to extract both the key and the value  \\n into named variables when defining our loop.  \\n So what this looks like,  \\n is rather than saying for record in testScores,  \\n which will give us a single value  \\n that ends up having to hold both the key and the value,  \\n we can define some parentheses here,  \\n and instead of one named variable,  \\n we'll define two, ID and score.  \\n So what this is going to do  \\n is it's going to assign the key to our variable called ID  \\n and it's going to assign value to our variable named score.  \\n So now in our string,  \\n rather than having to dereference the element in the loop,  \\n we simply replace in the named variables  \\n that we just defined.  \\n Now, if we print this out,  \\n we'll see that same output that we saw before.  \\n If we want to check that a map contains a specific key,  \\n in this case, a specific student ID, for example,  \\n we can use the .containsKey method.  \\n So we could say testScores.containsKey  \\n and I could pass in a student ID key value here.  \\n And similarly,  \\n if we wanted to check for the presence of a specific value,  \\n we can use the containsValue function  \\n and pass in a value that we want to look for within the map.  \\n If we wanted to get a collection  \\n of all the keys in the map,  \\n we could do so by accessing the keys property.  \\n This will give us back a set of all of the keys,  \\n and then we could print each of those out if we wanted to,  \\n for example.  \\n So now if we run this,  \\n we'll see this last three lines of output here  \\n is simply printing out each key available in the map,  \\n in this case, each student ID that we've stored.  \\n To round out our look at map,  \\n let's talk about mutable map for a minute.  \\n If we want to modify our map after it's created,  \\n we'll need to use the mutable variant  \\n of our builder function.  \\n So instead of mapOf, we will use mutableMapOf.  \\n Now that we are working with a mutable map,  \\n we can add new values using index access syntax.  \\n So, we'll write testScores and then we'll use brackets here.  \\n And now we can specify a specific key  \\n and assign a value to it.  \\n So if this key does not exist,  \\n we will add the key and specify that value for it.  \\n Or we will simply update the value of that key,  \\n if it already exists.  \\n If we didn't want to use index access syntax,  \\n we could use the put method to do the same thing.  \\n We can remove a value by saying remove  \\n and passing in the key that we want to remove  \\n within the map.  \\n Or we could explicitly update a value by calling replace  \\n and passing in the key that we want to replace  \\n and the updated value that we want to use.  \\n Now, you should have a basic understanding  \\n of how to start working with both set and map,  \\n and both of these will come in very handy  \\n as you continue to build your Kotlin applications.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3071721\",\"duration\":563,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Working with collections\",\"fileName\":\"3008787_en_US_06_04_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to transform and query collections to take full advantage of the Kotlin standard library.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":18524673,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] While collections such as list, set,  \\n or map are useful in their own right,  \\n the Kotlin Standard Library provides many useful  \\n helper functions that add even greater programming power  \\n to these collection types.  \\n We're going to explore how to take full advantage  \\n of the Kotlin Standard Library  \\n as we learn to transform and query common collection types.  \\n There are a number of common patterns  \\n across collection types  \\n that help make the collections easier  \\n to learn and work with.  \\n Need to create a read only data structure,  \\n we can use our listOf, setOf, and mapOf functions.  \\n So like we've seen, we could create a readOnlyList  \\n by invoking the listOf function.  \\n We could create a readOnlySet by invoking a setOf  \\n or readOnlyMap by using the mapOf function.  \\n And like we've seen if we need immutable versions  \\n of these common data structures,  \\n there are builder functions for those as well.  \\n If we simply copy these first three examples,  \\n we will pace them down here  \\n and change these to mutableList.  \\n And instead of listOf,  \\n we will use the mutableListOf function.  \\n Similarly, we can use mutableSetOf  \\n to create a mutableSet variable  \\n and mutableMapOf to create a mutableMap.  \\n And again, continuing in the pattern of consistency  \\n across collections, we can access the size of any of these  \\n using the size property.  \\n We can check if a collection isEmpty or not  \\n by using the same isEmpty or isNotEmpty functions.  \\n So in this case, we could check if our,  \\n let's say mutableSet.isEmpty by calling isEmpty  \\n or if our readOnlyList.isNotEmpty  \\n by calling the isNotEmpty function.  \\n And we can also iterate  \\n over these different collection types  \\n using both the item based for loop  \\n as well as the forEach function.  \\n So we could say for element_in readOnlySet, println element.  \\n Or we could use the, forEach variant  \\n and say something like mutableMap.forEach.  \\n In this case we can rename the lambda parameters  \\n to key and value.  \\n And we could, let say, print out just the value.  \\n And if we go ahead and just run this code,  \\n we'll see from our readOnlySet,  \\n we see the values one, two, and three printed out.  \\n And from our immutable map,  \\n we see the values A and B printed out to the console.  \\n Now, let's say we want to query for elements  \\n in a collection and maybe retrieve some of those elements.  \\n We could use the first function which is available  \\n on several of the common collection types.  \\n So for example, if we wanted to get the first element  \\n out of our readOnlyList, we could call the first function.  \\n And similarly, if we wanted to work with our mutableSet,  \\n we could get the first item out of our mutableSet.  \\n Maybe we want to take not just the first item  \\n but N number of items,  \\n we could use the take function for that use case.  \\n So we could say mutableLis.take,  \\n and let's say we'll just take the first three items,  \\n or maybe readOnlySet.take two items.  \\n Another really helpful method  \\n out of the Kotlin Standard Library  \\n for working with conventions is to use the filter function  \\n to filter a collection using some predicate.  \\n This will then return a copy of the collection  \\n whose values satisfy the boolean condition.  \\n So for example, let's say we want to work  \\n with our mutableMap here, and we want to filter out  \\n any of the key value pairs where the key is less than two.  \\n So we could say mutableMap.filter.  \\n This filter function is going to give us back  \\n each entry from that collection.  \\n And remember a map entry includes a key and a value.  \\n So we will name that implicit lambda parameter entry.  \\n And for our boolean condition,  \\n the thing that we will use to to filter out values  \\n will say entry.key less than two.  \\n For a different filter, maybe in our readOnlyList,  \\n we want to filter out values that are not greater than one.  \\n So in this case, we could say it greater than one.  \\n Now, remember it is the implicit name  \\n for the perimeter passed to a lambda.  \\n So in this case,  \\n it would represent each value in that readOnlyList.  \\n And as always, we could change the name  \\n of that it parameter to make it a little bit more meaningful  \\n and we could name it something like value,  \\n and then change our conditional expression  \\n to value greater than one.  \\n Sometimes we may have one collection of data,  \\n and want to transform that into some other collection.  \\n So take this map of programming languages for example.  \\n So we're mapping the language name to some integer value.  \\n Let's say in this hypothetical scenario,  \\n the higher the value,  \\n the more popular the programming language.  \\n Now, let's say that we want to transform this list  \\n into just an alphabetized list of strings  \\n representing the languages that score a four or better.  \\n For this type of used case,  \\n we can combine these different types of collection functions  \\n that we've been working with  \\n to make this type of transformation very straightforward.  \\n First, we can use filter to filter only languages  \\n whose value is greater than four.  \\n So we can reference languages.filter, it.value  \\n greater than or equal to four.  \\n Then we could use the map function to turn our collection  \\n of key value pairs into a list of strings.  \\n So in this case, we'll say map, it.key.  \\n So what we've done here is converted our map entries  \\n which contain a key and a value  \\n and we've simply converted that into simply the key.  \\n So after calling the map function here  \\n rather than having a map of key to int,  \\n we will have a list of just strings representing those keys.  \\n Then we could use the sorted method to sort the strings  \\n by their natural sort ordering.  \\n And finally, we could print out each of these values  \\n by using forEach and calling println  \\n and passing in that string.  \\n Now, if we go ahead and run this,  \\n we will see JavaScript, Kotlin and Python here.  \\n And if we notice that those are in order,  \\n JavaScript having a value of four,  \\n Kotlin having a value of five,  \\n and Python having an order of six.  \\n This type of data transformation  \\n leverages these powerful functions to enable developers  \\n to write complex code  \\n in a very concise, easy to follow syntax.  \\n And these functions are written to be generic  \\n so they can be used  \\n regardless of which type of collection we're working with.  \\n Think of a time you've needed  \\n to transform a collection of data,  \\n would any of these standard library functions  \\n have been a helpful?  \\n As you continue working with Kotlin,  \\n you'll likely find that you turn  \\n to the Kotlin Standard Library often.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3072726\",\"duration\":424,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Sequences\",\"fileName\":\"3008787_en_US_06_05_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to more efficiently process collections using sequences.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":11421174,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - The Kotlin Standard Library  \\n provides many helpful functions  \\n for working with iterable collections such as List.  \\n These functions make  \\n complex processing of collections quite easy.  \\n However, there are performance considerations  \\n to be aware of.  \\n Let's start with sequences  \\n and, and discuss when to use sequences over  \\n other collection types.  \\n When we work with iterable collections such as List or Set  \\n processing the collection with functions like filter or map  \\n create intermediate collections.  \\n So let's just imagine that we have  \\n a variable here called languages  \\n and it is holding a list of programming languages.  \\n There we go.  \\n So we have a list holding Kotlin C++ and Java.  \\n Now, let's say that we want to do something like a filter  \\n where we maybe want to filter out any languages  \\n whose length is not greater than four  \\n and then maybe we want to map this  \\n from the string to let's say simply the length  \\n of that string instead.  \\n So each of these functions  \\n that we're applying to our collection here  \\n create an intermediate collection.  \\n These intermediate collections are eagerly process  \\n meaning the filter or the map is carried out  \\n for every element in the collection,  \\n before the next function is applied.  \\n For small collections like our example here,  \\n this might not be a big deal.  \\n But for large collections  \\n or for collections that are going to undergo  \\n a lot filtering or other processing,  \\n the eager application of these functions  \\n can be computationally wasteful.  \\n To help with this scenario,  \\n Kotlin introduces the concept of sequences.  \\n Sequences are an iterable container  \\n providing much the same functionality as iterable  \\n which is what backs most of our common collection types  \\n but sequences have different performance traits.  \\n Rather than eagerly applying a transformation to every item  \\n in the iterable container  \\n sequences apply all processing steps  \\n to each individual item.  \\n You could think of sequence as being a depth first approach  \\n whereas iterable are more of a breath first approach.  \\n So let's take a look at how we could actually  \\n create a sequence  \\n and there are several ways to create a sequence  \\n like with most things in Kotlin.  \\n The most common way of creating a sequence  \\n is very similar to that of a List.  \\n So we could say val_LanguageSequence = sequenceOf  \\n and we could pass in our same collection  \\n of language strings.  \\n Another option for creating a sequence  \\n would be to do something like this:  \\n We could say val fromiterable = list of(1, 2, 3)  \\n and then once we have a collection,  \\n we could use the as sequence function  \\n to convert that collection into a sequence.  \\n Now, when working with sequences,  \\n we have access to many of the same helper functions  \\n as we do with our other standard iterables.  \\n We could filter out items again in this case any string  \\n whose length is not greater than four  \\n we could also then map out the values  \\n and convert into the length integer  \\n as opposed to the language string itself.  \\n And we could also let's say take the  \\n first two items out of this processed collection.  \\n Now, this is where the difference between  \\n sequences and iterables gets really interesting.  \\n If we were working with an iterable,  \\n then in this process here  \\n where we're working with language sequence,  \\n both the filter and the map would be applied  \\n to every element in the original collection  \\n before the final call to take is made.  \\n With sequences however,  \\n each element is transformed and evaluated  \\n until a terminal operator is reached.  \\n So with an iterable,  \\n each filter is applied,  \\n then each map call and then finally  \\n the take two result is taken.  \\n For large collections,  \\n this could be potentially very wasteful.  \\n Imagine we have a collection of a million items  \\n and we only wanted to take two of those items  \\n having to do that filter and that map on every item  \\n only to then take two  \\n is wasting a lot of processing potentially.  \\n So for large collections in this type of situation  \\n using sequence potentially  \\n has significant performance benefits  \\n when processing can be avoided  \\n for large portions of the collection.  \\n So in the example of our language sequence here  \\n we're going to perform the filter and the map  \\n on each item individually  \\n before then coming back to the next item.  \\n So we would call filter on the first item,  \\n then map on the first item  \\n and then take on that item,  \\n if it passes our filter.  \\n Same thing we would get to the second item  \\n we would check if it passes the filter if it does,  \\n we would call map on it and then take it  \\n and then at that point we would be done.  \\n Once we have two items  \\n there's no need to process any of the other items  \\n in the underlying and collection.  \\n So when should you use a sequence as opposed to an iterable?  \\n That's a great question.  \\n There's not an exact science to it  \\n but there are some general guidelines to follow.  \\n If you're working with smaller collections  \\n on the order of tens or hundreds  \\n then you're probably fine to use iterable.  \\n If the size of your collections  \\n starts to grow into the thousands or more,  \\n you could consider a sequence  \\n especially if you're going to do a lot of filtering  \\n after applying transformation functions  \\n such as map or filter.  \\n Don't stress too much about  \\n premature optimization of your code though.  \\n If you think you might have a good use case for sequences  \\n but aren't sure?  \\n You could always profile the performance of that code  \\n and compare the results to make an informed choice.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3070634\",\"duration\":72,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Challenge: Filtering a list of data\",\"fileName\":\"3008787_en_US_06_06_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, explore a common use case when working with collections.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2526341,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" (upbeat music)  \\n - [Instructor] Let's take on another challenge.  \\n This time we're going to work with collections processing.  \\n So back in IntelliJ, we're going to start  \\n by reviewing the collection of the provided data here.  \\n We've created a map  \\n and stored it in a variable called test scores.  \\n Each string value in this map represents a student ID  \\n and each double value represents a test score.  \\n For this challenge,  \\n you're tasked with identifying the three students  \\n with the lowest test scores.  \\n You're free to use any collection transformation functions  \\n you need such as filter, map, et cetera.  \\n And here's a hint.  \\n You may find it helpful to convert the map to a list  \\n to simplify the sorting and filtering of the data.  \\n Now within IntelliJ, the scores are defined  \\n in testscores.kt, just to help keep them out of the way  \\n and easy to find.  \\n You'll want to write your code within main kt.  \\n And you should be able to access that test scores map  \\n without any trouble.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3073696\",\"duration\":305,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Solution: Filtering a list of data\",\"fileName\":\"3008787_en_US_06_07_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, explore the solution to the challenge: filtering a list of data.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":8809389,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" (upbeat music)  \\n - [Instructor] How'd that challenge go?  \\n There's honestly a lot of ways we could go  \\n about solving this one.  \\n So let's just chat through the thought process  \\n behind one such solution and you compare your results  \\n with this solution.  \\n So I'm back here in IntelliJ and I've got my main.kt file  \\n where we're going to write the solution, but just to start,  \\n I want to take a look at test-scores.kt,  \\n and just review our data once again.  \\n So we have our test scores variable holding a map of data  \\n and we have string values representing the student IDs  \\n that we want to ultimately identify.  \\n And then we have these test score values.  \\n So I'm going to come back over to main.kt.  \\n And the first place that I would start is  \\n by wanting to filter the data.  \\n We ultimately want to find the three lowest scores.  \\n So filtering the data will be a must.  \\n Now we can't easily filter a map by its values.  \\n We could use the toSortedMap function,  \\n which I'll just write out here.  \\n ToSortedMap would help us filter the keys in the map  \\n but it's not the most helpful thing here.  \\n So the first step that we could use would be  \\n to actually take our test scores variable  \\n and convert that to a list.  \\n Now the resulting list will include pairs of the student ID  \\n and the test score.  \\n Now that we have a list of our test data,  \\n we can more easily sort the list based on the test scores.  \\n For this, we can call the sortedBy function.  \\n SortedBy takes a Lambda that we can use  \\n to determine what value should be used  \\n in the sorting comparison.  \\n In our case, we want the test score  \\n which we can access as the .second property on each pair.  \\n So we will name the implicit Lambda parameter pair  \\n and then we will access pair.second.  \\n And just to help us identify what we've done here,  \\n we'll just say sort by test score.  \\n Once we sorted the IDs and test scores,  \\n we really don't need the test score anymore.  \\n So in this case, we could convert the pairs of ID and score  \\n to just a list of IDs.  \\n And we'll do that by using the map function.  \\n And again, we'll name the Lambda parameter pair.  \\n And this time we will say pair.first.  \\n So this will map to just the student ID.  \\n Now that we have a sorted list of student ID numbers,  \\n we want to select the three lowest scores.  \\n Since we sorted our collection, based on the score already  \\n all we need to do is take the first three elements  \\n from the collection.  \\n And again, just for our note here,  \\n we'll leave a comment saying  \\n take three lowest values from the sorted list.  \\n And now just to cap things off,  \\n we will print out each element  \\n in this final collection by using forEach  \\n and printing out that string representing the student ID.  \\n So now to check our work,  \\n we'll print out the result of this code  \\n and we see three IDs printed out to the console.  \\n So now if we open up our test-scores.kt file,  \\n we can just kind of visually check our work here.  \\n So if we scroll through this,  \\n we see the lowest score here being a 62.1  \\n which has an ID of 385agc.  \\n And sure enough, we see that printed out as the first item  \\n in our console output.  \\n For our second lowest, we have 66.1 which we see printed out  \\n as the second item in our output.  \\n And the third lowest we have 72.1,  \\n which again is printed out to the console.  \\n So how did your solution compare to this one?  \\n Did you make use of any other functions?  \\n Can you think of other ways  \\n we might accomplish this same result?  \\n As with most things in programming,  \\n there's no perfect right or wrong answer.  \\n In Kotlin, there's often many ways  \\n to accomplish the same task.  \\n To help us pick the best solution to our problem,  \\n it's helpful to explore the Kotlin standard library  \\n and to look for helpful functions  \\n that might come in handy next time we need them.  \\n \\n\\n\"}],\"name\":\"6. Working with Collections\",\"size\":107704830,\"urn\":\"urn:li:learningContentChapter:3068675\"},{\"duration\":1754,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:3068672\",\"duration\":400,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Command-line arguments\",\"fileName\":\"3008787_en_US_07_01_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to pass command-line arguments to a Kotlin program so runtime behavior can be customized.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":11258020,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] When we run and deploy our programs,  \\n sometimes we might want to control the runtime behavior  \\n by passing arguments to the program  \\n when it's executed.  \\n This makes our programs more flexible  \\n and easier to adapt to different situations.  \\n We're going to explore how to do this in Kotlin  \\n by passing command line argument to our main function.  \\n So we've seen many examples of main functions so far  \\n in this course.  \\n A basic main function may be defined with no parameters  \\n and has to have the name of main, like we see here.  \\n And you'll notice that in this form,  \\n we have the green play button next to it  \\n and if we click that button,  \\n our main function will be run  \\n and in this case, nothing will actually happen  \\n because nothing has been told to happen  \\n inside of the main function body.  \\n So in this form, the main doesn't allow us to pass  \\n and get access to any arguments  \\n when the function is called.  \\n To support passing command line arguments to our program,  \\n we can update our main function  \\n to take in an array of strings.  \\n So we do this like we would define  \\n any other function parameter.  \\n So first I'm going to name the parameter args  \\n and then it will take in an array of string.  \\n Now, it could also take in a vararg parameter,  \\n so we could change this to be vararg  \\n and we could call this args of type string.  \\n And this will work as well,  \\n because any vararg parameter will be treated  \\n as an array of the given type under the hood.  \\n So now, each value in our argument's array  \\n will represent an individual argument passed  \\n when our program is run.  \\n And because those arguments are passed in an array,  \\n we can treat them as such,  \\n so we could access an individual argument.  \\n So if we wanted to print out what the first argument was  \\n we could do something like this, where we call println.  \\n We say, first arg is  \\n and then now we could say args  \\n and use index access to ask for the first item in the array.  \\n Or we could iterate over every item in the array  \\n and so we could say something like  \\n for arg in our args, println arg.  \\n So, in both of these cases,  \\n in the first one we're accessing the first element  \\n of the args directly,  \\n in the second case here,  \\n we are just trying to iterate over each passed argument.  \\n Now, if we run this code,  \\n we actually see an exception printed out  \\n to the console here.  \\n In particular we see an array index  \\n out of bounds exception.  \\n Now, why do we think that might be?  \\n Well if you guessed that it's  \\n because we haven't actually passed any arguments  \\n to our main function yet,  \\n you're correct, congratulations.  \\n When working in IntelliJ,  \\n we can pass arguments to our main function  \\n by editing the run configuration for our application.  \\n So to do that there's a couple ways,  \\n we could go to the run menu  \\n and then navigate down to edit configurations.  \\n Or from within IntelliJ's toolbar,  \\n we could come up to this dropdown here next  \\n to the run button.  \\n And in that dropdown button,  \\n we should also see edit configurations.  \\n So I will just go ahead and select that.  \\n And within this new popup  \\n there should be a field here called program arguments.  \\n So within this, I can enter any command line arguments  \\n that I would like to be passed to my main function.  \\n So in this case, I'm going to type Kotlin, Java and Go.  \\n Now notice that these are simply separated by a space.  \\n So now that we've defined our three parameters,  \\n we hit okay.  \\n Now if we run our code again,  \\n we see first arg is Kotlin printed out  \\n and then we see Kotlin, Java and Go each printed out.  \\n So this time when we've updated our run configuration,  \\n we've passed in those arguments,  \\n those arguments are then getting passed to our main function  \\n and we can access them through this args array.  \\n Now, like we saw the first time we tried to run our code,  \\n if we're going to possibly take arguments  \\n we want to build in error handling.  \\n So if our program requires arguments in some cases  \\n but none are passed,  \\n we could provide some type of useful feedback message  \\n to the user  \\n and try to prevent any such crash.  \\n So, we could come up here  \\n to the beginning of our main function  \\n and we could check if the arguments array is empty  \\n and call println with some useful default message.  \\n So we could say, if args.isEmpty  \\n print, please pass at least one argument  \\n and then we could return from our main function early.  \\n So now if we run our code,  \\n again we still see the arguments printed out  \\n because we're still passing them to the main function.  \\n But if we go back to our configurations  \\n and we remove those three parameters.  \\n Now if we run our code, rather than crashing  \\n we see the output, please pass at least one argument.  \\n So in this case our program's not doing  \\n anything particularly useful,  \\n but it's also not crashing,  \\n so it's an overall better experience for the end user.  \\n By leveraging command line arguments,  \\n our programs can be configured  \\n to work in different environments  \\n and operate on different files or directories.  \\n However, by opening up our program  \\n to take in those external arguments,  \\n we also have to account for additional error scenarios  \\n like empty arguments or invalid arguments.  \\n So to help provide that great end user experience,  \\n we want to make sure that we're handling both the happy path,  \\n where we get the arguments we want  \\n and the error scenarios where might go wrong.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3070635\",\"duration\":381,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Receiving user input\",\"fileName\":\"3008787_en_US_07_02_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to make a Kotlin program interactive by receiving user input.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":11033777,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Receiving user input can make our programs  \\n much more dynamic and useful.  \\n Let's look at how to receive input from the user  \\n and validate that input  \\n to ensure it represents a valid file.  \\n The primary way of receiving input from the user  \\n is by calling readLine.  \\n Let's first start by printing a prompt  \\n to enter a valid filename.  \\n So we could do that by typing, print.  \\n Now notice we're using print this time  \\n instead of println, this is just a small difference  \\n that will allow us to enter input  \\n on the same line as the prompt.  \\n If you wanted the prompt to be on one line  \\n and enter the value on the next line,  \\n you could use println here.  \\n Now the prompt itself will say, enter a filename  \\n and I'll add a colon just as a separator there,  \\n and then a space.  \\n Now we can then receive input  \\n from the user by calling readLine  \\n and assigning the entered value to a variable.  \\n So in this case, I'll say Val filename equals readLine.  \\n And then we could print out the entered value  \\n to indicate that we did in fact receive the correct input.  \\n So here, I'll type println, you entered $filename,  \\n there we go.  \\n So before we go any further, let's just print this out  \\n and test out how this is working so far.  \\n So here, we've gotten our prompt to enter a filename  \\n and we can see our cursor here.  \\n And now I might enter a filename.  \\n Maybe I will call this file.kt and I'll hit Enter.  \\n And then the program prints out,  \\n You entered file.kt and the program finishes.  \\n So that's perfect.  \\n Everything so far is working as we hoped.  \\n Now, once we have our input,  \\n we can validate that the input  \\n is actually a valid file or not  \\n within the project's root directory.  \\n To do that,  \\n we can create an instance of a file  \\n and check whether that file is valid or not.  \\n So I'm going to create a new variable here called isValidFile.  \\n And then I'm going to sign that the result  \\n of creating a new file using the file constructor.  \\n When you type file and add the parentheses,  \\n you may be prompted to import the file.  \\n You may notice here that now at the top of the file  \\n I see import java.io.File.  \\n This is going to pull in that file type  \\n from the standard set of Java components  \\n which we have full access to via Kotlin.  \\n So to finish off creating my file then  \\n I want to pass in the filename that was entered  \\n by the user.  \\n And now to check whether or not that is a valid file,  \\n we can access isFile here.  \\n So if this is a valid file  \\n within the project's root directory, this will return true.  \\n Otherwise it will return false.  \\n Now the IDE here is actually giving us a helpful warning.  \\n If I hover over filename here,  \\n it's saying type mismatched.  \\n File expects a non-nullable string,  \\n but we've actually passed a nullable string.  \\n So why is that?  \\n Well, it's because readLine is not guaranteed  \\n to return us a non-null string.  \\n So to fix this, we could come back up here  \\n to our call the readLine,  \\n and we could use the Elvis operator here.  \\n And remember, the Elvis operator is a question mark, colon.  \\n And what this will do,  \\n is that if the result of readLine returns, no,  \\n then we will instead substitute in  \\n whatever's on the right hand side of the Elvis operator.  \\n So now filename will either be a valid string  \\n from readLine or the default empty string.  \\n And now if we come back down to creating our file,  \\n we see that the warning has gone away  \\n because now filename is guaranteed to be non-null.  \\n So once we have a file  \\n and we know whether or not that file is valid,  \\n we can use that information to provide useful feedback  \\n to the user.  \\n So we could do something like  \\n if is valid file println, it is a valid file,  \\n else println it is not a valid file.  \\n So now if we run our code again,  \\n we'll once again be prompted for a filename.  \\n So again, I'll just use a placeholder filename here for now,  \\n and I'll just call this file.kt and hit Enter  \\n and we'll see you entered file.kt,  \\n it is not a valid file.  \\n So that is actually exactly what we would expect here.  \\n Now let's try the happy path.  \\n Let's open up our project directory window here  \\n and let's just look for the name  \\n of a file in our root project directory.  \\n So again, the root project here is this one at the very top.  \\n If I open this back up,  \\n we'll see a number of top level files here.  \\n So for example, we could check  \\n for the existence of gradle.properties.  \\n So I'm going to run the code again here,  \\n and this time when prompted to enter a filename,  \\n I will type great gradle.properties and I'll hit Enter,  \\n and this time it says that it is a valid file.  \\n By prompting a user for input,  \\n receiving that input validating it and operating on it,  \\n we can build much more interactive applications  \\n that adapt to the needs of the individual user.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3071722\",\"duration\":369,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Read and write to files\",\"fileName\":\"3008787_en_US_07_03_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to read and write from files, as is common in both mobile and desktop development.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":10315431,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] How do you read a list of test scores  \\n from a file or save processed data to a file for later use?  \\n Let's explore how we can work  \\n with file inputs and outputs in Kotlin.  \\n Let's start with reading from files.  \\n To get started, we'll create a new text file  \\n in our root project called scores.txt.  \\n So to do that from IntelliJ,  \\n I'll open up the project directory window here.  \\n And within the root project directory,  \\n I'm going to right click,  \\n go to new  \\n and file.  \\n And I'm going to name this file scores.txt and hit enter .  \\n In that file, we'll add a list of data  \\n representing user IDs and test scores separated by a colon.  \\n So I'm just going to paste in some example data here.  \\n So here we have seven pairs of ID and test scores.  \\n So now back within our main.kt file,  \\n we want to read that file in and store it as a variable.  \\n So to do so, we will create a variable called scoresFile  \\n and then we're going to create an instance of the file.  \\n And when prompted by the IDE to import that,  \\n we can move our cursor over the file name  \\n and hit Alt + Enter  \\n and that will import the file type for us.  \\n And now within the file constructor,  \\n we want to pass the name of the file.  \\n So for us, that will be scores.txt.  \\n Now, we have a reference to our scores file.  \\n Once we have a valid file,  \\n there are a couple of ways to read from that file.  \\n The easiest is to call for each line  \\n which will read the file and call us back  \\n with each mine in that file,  \\n while also automatically closing the file for us.  \\n So that would look something like this.  \\n Where we would reference the scoresFile variable  \\n and we would call four each line  \\n and then pass a Lambda to that function.  \\n To print out each line of that file,  \\n we could simply use println.  \\n So to start, we will do that like this, println,  \\n and we pass in it as the implicit Lambda parameter  \\n representing each line of the file.  \\n And to just be a little bit more explicit here,  \\n we will rename that implicit Lambda perimeter as line.  \\n That way it's more clear,  \\n that we are iterating over each line in the file  \\n and printing out individual lines.  \\n So, now if we run our program here,  \\n we will see the output of that scores TXT file,  \\n printed out to the console.  \\n Now, let's say we want to take those lines  \\n that we read in from the file,  \\n sort them and write them out to a new file.  \\n For that, we could use another useful function  \\n called read lines, to go get a list of all lines  \\n in the input file  \\n and we'll then call to sorted on that list  \\n to sort out all those lines.  \\n So we'll create a new variable here called sorted lines  \\n equals scoresFile.readLines  \\n and then we will call sorted on that list.  \\n So now that we have this sorted list  \\n of lines from that file, we want to write that out.  \\n And to write output to a file,  \\n we need to set up the file that we want to write to.  \\n So we're going to write out to a file called sortedscores.txt.  \\n So we'll create a variable to hold this output file.  \\n And again, we'll create a new instance.  \\n A file passing in the name of that output file,  \\n sorted-scores.txt.  \\n Now, once we have this output file setup,  \\n there are a number of different ways  \\n we could go about actually writing to that file.  \\n But perhaps the easiest for our use case,  \\n is to convert our file to an instance of path.  \\n And we can do that by simply calling topath  \\n on that file once it's created.  \\n By converting to a path,  \\n we open ourselves up to some specific APIs  \\n that make writing lines out to a file path quite easy.  \\n So once we have that output file variable,  \\n storing the path instance pointing to sorted-scores.txt,  \\n all we have to do is say, outputFile.writeLines  \\n and we can pass in our sorted list of lines  \\n that we want to be written out to that file.  \\n Now, if we check our route directory here,  \\n we'll see at the moment,  \\n that there is no sorted-scores.txt file.  \\n However, if we run our code,  \\n we see our output from printing out each line.  \\n But more interestingly,  \\n if we open up the project directory viewer again,  \\n we now see sorted-scores.txt.  \\n And if we open that up,  \\n we will see in fact that the scores have been sorted  \\n based on the user IDs.  \\n We've only touched the surface  \\n of file input and output in Kotlin.  \\n But with these fundamentals,  \\n you have everything you need  \\n to start working with file I/O in Kotlin.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3070636\",\"duration\":65,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Challenge: Parsing a list of data from a file\",\"fileName\":\"3008787_en_US_07_04_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, explore a practical example of working with file I/O.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2121403,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" (upbeat music)  \\n - [Instructor] Here's the challenge to help reinforce  \\n the concepts of user input in File IO.  \\n You are tasked with writing a program that helps the teacher  \\n find the students with the highest test scores.  \\n Within IntelliJ, the test scores will be available  \\n within a scores.txt file.  \\n Back within IntelliJ,  \\n test scores are located within scores.txt  \\n and have the following structure, user ID colon score.  \\n Each ID score pair is on its own unique line.  \\n When you run your program,  \\n it should prompt the user to enter the name  \\n of the file containing the test scores.  \\n The program should then read each line  \\n from the file,  \\n sort the scores from highest to lowest,  \\n pick the three highest scores  \\n and write the user ID score pairs  \\n to a new file named sorted.txt.  \\n Back in IntelliJ.  \\n you'll write the code to complete the exercise  \\n within main.kt.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3069680\",\"duration\":539,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Solution: Parsing a list of data from a file\",\"fileName\":\"3008787_en_US_07_05_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, explore the solution to challenge: parsing a list of data from a file. This mirrors use cases common in mobile or back-end development.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":18219263,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" (upbeat music)  \\n - Let's take a look at one way  \\n which we could solve this challenge  \\n to build our test score processing program.  \\n To start, let's build the user input  \\n To start, let's build the user input  \\n so we can read the file name from the user.  \\n We'll prompt the user to enter the name of the scores file  \\n and then read that input from the user  \\n storing it in a variable.  \\n So the very first thing we'll do here  \\n is to prompt the user to enter the name of the file.  \\n So I'll say, enter the name of the file containing scores.  \\n So I'll say, enter the name of the file containing scores.  \\n And then, we will create a variable called input file name  \\n and assign it the value of read line.  \\n and assign it the value of read line.  \\n And because read line m  \\n And because read line might be no,ight be no,  \\n we'll use the Elvis operator here  \\n and provide a default of empty strength.  \\n Next, let's add in a little error handling  \\n to prevent against any type of empty input.  \\n So we can check if the file name is null or empty  \\n and if it is, print a message to the user  \\n and end our program.  \\n So we'll say, if input file name is null or empty  \\n So we'll say, if input file name is null or empty  \\n println  \\n not a valid file name  \\n not a valid file name  \\n and return.  \\n Now, notice here that with isNullOrEmpty,  \\n it's highlighted by the IDE.  \\n And it's saying that the call on the not null type  \\n may be reduced to simply is empty.  \\n Now, the reason for this  \\n is that we've already checked  \\n the input file name is not null up above  \\n when we provided a default value.  \\n So we could solve this in a couple ways.  \\n We could move our cursor over the is null or empty call,  \\n hit alt+enter  \\n and then hit enter on the option to change call to is empty.  \\n So this will would be one way to simplify things.  \\n Or  \\n we could continue to use is null or empty  \\n and skip the use of the Elvis operator  \\n on the read line call.  \\n So, either of these will work.  \\n In this case, I'm going to go with the basic read line.  \\n And then down below, I will check for both the null case  \\n and the empty case.  \\n At this point, we know that we should have  \\n a non-empty string representing the file  \\n that we want to read in.  \\n So now, we can create a file from the file path  \\n and check if that file is valid.  \\n So we'll create a variable called inputFile = File  \\n So we'll create a variable called inputFile = File  \\n will pass in that input file name.  \\n We will be sure to import the file type.  \\n And now, if input file is not a valid file,  \\n And now, if input file is not a valid file,  \\n And now, if input file is not a valid file,  \\n we'll go ahead and simply return.  \\n Next, we want to set up a variable to read in the  \\n ID score pairs from the input list.  \\n ID score pairs from the input list.  \\n So let's say, val rawScores=inputFile.readLines  \\n So let's say, val rawScores=inputFile.readLines  \\n So let's say, val rawScores=inputFile.readLines  \\n So this should read in each individual line.  \\n And if we remember from scores.txt,  \\n And if we remember from scores.txt,  \\n each line then is formatted in a particular way  \\n with the ID, separate by the colon  \\n and then the actual score.  \\n So, to be able to complete our challenge  \\n and figure out which scores are the highest,  \\n we'll want to parse these scores and split out the values.  \\n So I'm going to create a variable called parsedScores  \\n So I'm going to create a variable called parsedScores  \\n and then we're going to work with the raw scores input here.  \\n So we're going to say rawScores  \\n and we're going to map each line  \\n and we're going to map each line  \\n and we're going to convert each streamline  \\n into a pair containing the ID and the score.  \\n And so to do that,  \\n we're going to make use of a couple of functions here.  \\n So first, we'll create a variable called elements  \\n and we'll assign it the result of saying line.split  \\n and we'll use a colon as our delimiter here.  \\n So what this is going to do  \\n is take in each line that we read in  \\n and then split this string based on that colon.  \\n Now what we can do is access the different elements  \\n Now what we can do is access the different elements  \\n of this split array  \\n and use that to create our pair of ID to score.  \\n So in our map here,  \\n we will return the result of saying elements 0  \\n we will return the result of saying elements 0  \\n which will represent the ID  \\n to elements 1  \\n to elements 1  \\n which will represent the score.  \\n Now that we have access to the actual score values,  \\n we can use that data to sort the results  \\n and take the highest three.  \\n So we'll set up a variable called final scores  \\n and that will be equal to parsedScores.sortedByDescending  \\n and that will be equal to parsedScores.sortedByDescending  \\n and that will be equal to parsedScores.sortedByDescending  \\n it.second  \\n it.second  \\n and then we will take 3.  \\n and then we will take 3.  \\n and then we will take 3.  \\n So, what we've done here is take the parsed scores,  \\n we've sorted them in descending order  \\n using the second value of each pair.  \\n So if we go back to our previous variable there,  \\n the second value of each pair should represent the score.  \\n So this is going to sort the scores in descending order.  \\n And then we take 3 to get the three highest scores.  \\n Now, the last thing to do is to write to the file.  \\n So to prepare for writing, we will create our output path.  \\n And remember, we want that output file  \\n to be called sorted.txt.  \\n to be called sorted.txt.  \\n And we want to work with the path API  \\n for writing output lines.  \\n So we will convert the file to a path  \\n using that two path function.  \\n Now, we don't simply want to write out  \\n just the scores or just the IDs,  \\n we want to write them out  \\n in the same format in which we read them in.  \\n So, we need to format the final scores  \\n into a format a little bit easier to write.  \\n So we'll do this  \\n by creating a variable called output scores  \\n and assigning it the result of finalScores.map.  \\n And in our mapping function here,  \\n we will use a string template  \\n to set up the same string format that we were using  \\n when we read them in.  \\n So that will be it.first:  \\n So that will be it.first:  \\n So that will be it.first:  \\n followed by it.second.  \\n followed by it.second.  \\n And now, we can use outputPath.writeLines  \\n And now, we can use outputPath.writeLines  \\n pass in the output scores.  \\n And this should print out the values  \\n that we expect to our sorted.txt file.  \\n So, if we go ahead and run this code,  \\n So, if we go ahead and run this code,  \\n we see here that we are prompted  \\n to enter the name of the input file.  \\n So, that will be scores.txt.  \\n So, that will be scores.txt.  \\n And our program then finishes.  \\n If we look at the project directory here,  \\n we now see that we have a sorted txt file.  \\n And if we open that up,  \\n we will see those highest three scores.  \\n We see 98, 91 and 88.  \\n We see 98, 91 and 88.  \\n If we check that against the input,  \\n sure enough, we see 98, 91 and 88  \\n sure enough, we see 98, 91 and 88  \\n as the three highest scores from that input file.  \\n So, how was your solution?  \\n Was it similar to what we just walked through?  \\n Did you find different ways to process the input  \\n or right to the file?  \\n However you solved the challenge,  \\n this type of problem closely mirrors  \\n the types of challenges we might face  \\n in a production code base.  \\n And as we've seen, Kotlin provides many tools  \\n for solving those types of challenges.  \\n \\n\\n\"}],\"name\":\"7. Working with Inputs and Outputs\",\"size\":52947894,\"urn\":\"urn:li:learningContentChapter:3067670\"},{\"duration\":1202,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:3072727\",\"duration\":727,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Writing JUnit tests\",\"fileName\":\"3008787_en_US_08_01_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to setup and run a JUnit test. This is helpful for testing Kotlin code whether for mobile, web, or back end.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":24729937,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - Testing is an important part  \\n of writing production quality code  \\n with any programming language.  \\n We're going to learn to write basic unit tests in Kotlin  \\n using the popular test framework JUnit.  \\n Now, before we can write our first JUnit test,  \\n we need to add the necessary dependencies to our project.  \\n So within IntelliJ,  \\n we'll navigate over to our project viewer,  \\n and we want to open up the build.gradle.kts build script file.  \\n Here we want to scroll down  \\n until we find the dependencies configuration block.  \\n Here we want to make sure  \\n that we have added the Kotlin test dependency  \\n to our testImplementation class path.  \\n This will make testing classes and functions  \\n available within our test code.  \\n Now, this is likely already in place  \\n from when you created your Kotlin project,  \\n but if it's not, you want to configure it as you see here.  \\n Now, once the test dependency is added,  \\n we also want to make sure that our tests  \\n are configured to use JUnit by default.  \\n So below that you should see a test task configuration block  \\n marking each test as use JUnit.  \\n This will help us pull in  \\n the JUnit testing framework dependencies  \\n that we want to work with when defining our unit tests.  \\n Once we're sure our builds is configured properly,  \\n we can resync our project just to be sure the IDE  \\n will recognize these new dependencies.  \\n To resync the project can open up the Gradle tool window  \\n from the right-hand side of the screen here  \\n or navigate to View, Tool Windows,  \\n scroll down until you find Gradle,  \\n And within that Gradle tool window, in the menu,  \\n there should be this Reload All Gradle Projects button.  \\n If we click that, it will resync the project  \\n and make sure that all needed dependencies  \\n are ready to be used.  \\n Now we're ready to create our first test class.  \\n To do this, we will navigate to our project window  \\n on the left side of the screen,  \\n and we will navigate to src, test, kotlin.  \\n And then we will right-click, select New, Kotlin Class/File.  \\n We're going to select to create a new Class,  \\n and we're going to name that class RandomNumberGeneratorTest  \\n and then hit Enter.  \\n This class is where we will write all  \\n of our individual unit tests.  \\n Our first test is going to be quite basic.  \\n So I'll just hit Enter a couple times,  \\n come down into our class body.  \\n And we're going to write a function  \\n called verifyTrueIsAlwaysTrue  \\n So for this test,  \\n we're going to do what the function name suggests  \\n and simply verify that the value true  \\n is always equal to itself.  \\n And to do this, we will use an assert function  \\n and pass the expression true == true.  \\n Assertion functions will throw an exception  \\n if the past expression evaluates to false.  \\n So in this case, if true equals true, our test will pass.  \\n Otherwise our test will fail.  \\n Now for the final step here,  \\n we need to indicate to the JUnit test framework  \\n that this function is actually a JUnit test  \\n as opposed to a regular function.  \\n So for the final step,  \\n we will mark this function as an actual test  \\n by adding the @Test annotation.  \\n Now, once we've written @Test,  \\n we will be prompted to pick  \\n from a couple different available test types here.  \\n We want to make sure that we are selecting the one  \\n coming from the org.junit package  \\n and hit Enter.  \\n You'll know you've done it right  \\n if at the top of the file you now see import org.junit.Test.  \\n Once the annotation is added,  \\n the IDE will now recognize our test  \\n and test class as test elements that maybe run invalidated.  \\n If we click the little play button on the class name,  \\n this will run tests for the entire test class.  \\n And down in the tool window that popped up,  \\n we see this Test Results drop down here.  \\n And if we click this dropdown, nothing happens at the moment  \\n because everything was successful.  \\n However, as we'll see in a minute,  \\n if we had failing tests here,  \\n we could use this to drill deeper  \\n and see which tests were failing.  \\n If we wanted to run just the individual test  \\n that we've written,  \\n we can click the play button next to that individual test  \\n and we will see the same output window pop up.  \\n And notice in this case, like we've already saw,  \\n our test succeeded because true is always equal to true.  \\n If we change this expression  \\n to assert that false equals true  \\n and we rerun the test here,  \\n this time we see failing test results.  \\n And in the little test window here at the bottom,  \\n we see that we had a failing test  \\n within the RandomNumberGeneratorTest class.  \\n And then below that nested,  \\n we see which specific test failed.  \\n And in the test output  \\n we can even find which specific line failed.  \\n And if we click on that,  \\n in the editor it'll actually take us directly to that line  \\n making the test easy to locate.  \\n When writing tests,  \\n we typically follow the same general pattern.  \\n We set up the test variables and conditions,  \\n call the function or method that we want to test,  \\n and finally, we validate the expected and actual values.  \\n We've already seen how assert can be used  \\n for a trivial test.  \\n So let's build on that example  \\n as we add additional, more interesting tests.  \\n To start, we're going to write a function  \\n that returns an integer value  \\n between zero and some passed max value.  \\n Now we want to simulate how we would do this  \\n in a real code base.  \\n So we are going to write this test  \\n in our main source directory.  \\n So we're going to open up Main.kt  \\n which lives under src/main/kotlin.  \\n And above our main function here,  \\n we're going to this new getRandom function.  \\n GetRandom will take in an argument called max of type int.  \\n And for its implementation,  \\n we will generate a random integer value  \\n using the Random class from Kotlin.  \\n And we will pass our max value to nextInt.  \\n Calling Random.nextInt with this max value  \\n will generate a random number between zero  \\n and whatever that max value is that we passed.  \\n Now we'll return to our RandomNumberGeneratorTest class.  \\n If our expectation is that this getRandom function  \\n returns a positive value between zero and some max value,  \\n we can write tests that validate this.  \\n So we're going to write a new test function.  \\n And this time we will use a special function naming syntax  \\n that Kotlin supports specifically for test code.  \\n So to start, we will write our @Test annotation,  \\n the fun keyword,  \\n and now, rather than jumping in  \\n and writing our name directly using the same naming patterns  \\n that we might typically use for a function,  \\n we're going to add backticks.  \\n And now within these backticks,  \\n we can define our name using human readable text.  \\n So we can name this getRandom returns value  \\n between 0 and 100.  \\n So now this is our test name  \\n and so when we see this test name in our output,  \\n it becomes very easy to read  \\n and understand what to expect from this test.  \\n Now to finish implementing this test,  \\n we'll create a variable called random  \\n and assign it the result of calling getRandom  \\n and passing in 100.  \\n And finally, we want to assert that that random value  \\n is within the range of 0 to 100.  \\n So again, we'll call assert  \\n and this time we will use the expression random in 0  \\n to 100.  \\n So I'll generate a range from 0 to 100  \\n and assert that the value random is within that range.  \\n And now we can go ahead and test this  \\n by running that function a couple of times.  \\n We'll see that the test passed that time.  \\n However, because we're dealing with random values here,  \\n there could be some inherent uncertainty  \\n so we'll just run this a couple more times  \\n to verify that each time we run it, it seems to pass.  \\n And sure enough, we've run it three times  \\n and it passed each time.  \\n So this is kind of a positive test.  \\n We have some expectation  \\n and we are asserting that that expectation is always met.  \\n Now, what if we wanted to write a negative test here?  \\n Let's say we want to verify  \\n that an illegal argument exception is thrown  \\n when a negative value is passed to our getRandom function.  \\n So this is kind of a test to verify  \\n that our function fails in the way we expect.  \\n So once again, we'll start off by defining a new test  \\n by adding a test annotation.  \\n And at this time the function will be named getRandom  \\n throws exception  \\n when negative value  \\n is passed.  \\n And now we will call getRandom  \\n and we will pass in a value of -1.  \\n So if we run this test now,  \\n we will see that the test fails  \\n by throwing in illegal argument exception.  \\n However, in this case,  \\n throwing that illegal argument exception  \\n is actually what we expect.  \\n That's how we think that our function should fail.  \\n So in situations like this,  \\n we can actually modify our test annotation  \\n and indicate to it that we actually  \\n expect a particular exception to be thrown.  \\n So we could you that by adding parentheses  \\n after our test annotation  \\n and then we will use named argument syntax here  \\n to assign an exception type  \\n to the expected argument value here.  \\n So we will pass a IllegalArgumentException::class.  \\n So this is now telling this test that when it runs,  \\n we expect an illegal argument exception to be thrown,  \\n and if it isn't, then fail the test.  \\n If illegal argument exception is thrown,  \\n then treat this test as if it passed,  \\n because that's our expected outcome.  \\n So now if I run this again,  \\n this time we see that our test passed,  \\n because that exception was in fact thrown.  \\n By writing unit tests for your Kotlin code,  \\n you can build greater confidence in that code  \\n and be more assure that it will perform the way you expect.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3070637\",\"duration\":475,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Mocking data\",\"fileName\":\"3008787_en_US_08_02_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to mock data using Mockito. This is very helpful for writing more effective tests.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":16235811,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Sometimes it's not possible  \\n to easily set up the environment for a specific test.  \\n This could be due to types that are not open for extension,  \\n complex dependency graphs, or other reasons.  \\n In these situations, it can be helpful to mock out the data  \\n and responses that we need to effectively write our test.  \\n Mockito is a popular mocking tool for Java development  \\n and works great for Kotlin code as well.  \\n So here's a testing scenario for us.  \\n If we open up our code here,  \\n we'll see that we have an AnalyticsClient interface,  \\n and this interface allows us to track some analytics event.  \\n And we also have a ViewModel class.  \\n That ViewModel class takes in an instance  \\n of an analyticsClient,  \\n and it has a public method called submitClicked.  \\n And when that button is clicked,  \\n it should track an analytics event  \\n using that analyticsClient.  \\n Now our task is to write a test  \\n that validates the tracking of that analytics event  \\n when submitClicked is called.  \\n So to start, we'll go to our project window,  \\n navigate to source, test, kotlin,  \\n right-click, select New Kotlin Class or File.  \\n And we will create a new test class called ViewModelTest  \\n and hit Enter.  \\n Then within the ViewModelTest class,  \\n we will create a new test using our @Test annotation,  \\n importing the org.junit.Test annotation.  \\n And we will name this test  \\n trackEvent is called when submitClick is called.  \\n So here we have our test method, and we want to verify  \\n that any time viewModel.submitClick is called,  \\n trackEvent is called on the AnalyticsClient interface.  \\n Now this is where it gets interesting.  \\n We need to create some instance  \\n of the AnalyticsClient interface.  \\n We could create a class to extend that interface  \\n and use that for our test,  \\n or we could create an anonymous object expression  \\n to create an instance.  \\n We'll learn more about both of those strategies  \\n later in the course.  \\n In both of these cases,  \\n we'd have to implement the full interface,  \\n but really all we care about  \\n is whether or not the track method is called.  \\n What it actually does isn't the focus of this test.  \\n So this is where mocking can be really helpful.  \\n We can mock the object,  \\n in this case our AnalyticsClient interface,  \\n and we can verify the behavior of that object  \\n without actually implementing any of that behavior.  \\n So to do this,  \\n we need to first pull in the Mockito dependency.  \\n We can do this by opening up our build.gradle.kts file.  \\n And within our dependencies configuration block,  \\n we need to add the Mockito core dependency  \\n to the testImplementation class path.  \\n Now here I already have it, it's just commented out.  \\n So I'm going to uncomment this.  \\n And then I will resync my Gradle project  \\n so that that dependency is pulled in  \\n and made available to me.  \\n Now once Mockito has been added to the project  \\n and we've resynced, we can return to our test.  \\n And now we can call Mockito.mock  \\n to create a mocked instance  \\n of our AnalyticsClient interface.  \\n So I'll create a variable called analytics  \\n and assign it Mockito.mock.  \\n And that mock method will take in a class type to mock out.  \\n So in this case, it'll be AnalyticsClient::class.java.  \\n Now when prompted to import the Mockito type,  \\n we want to make sure that we import it  \\n from org.mockito.Mockito,  \\n as we see at the top of the file.  \\n Once we have our mocked AnalyticsClient,  \\n we can create new instance of our ViewModel.  \\n And we can use that mocked instance of the AnalyticsClient  \\n to pass to our viewModel constructor.  \\n So that is the setup portion of our test.  \\n And now we want to exercise the submitClicked method  \\n by calling viewModel.submitClicked.  \\n And finally,  \\n we can call Mockito.verify  \\n to assert that analyticsClient.track is called.  \\n So we can do this by typing Mockito.verify.  \\n We'll pass in analytics as the mock object  \\n that we want to verify that something happened with.  \\n And then we will call track.  \\n So what this is saying up to this point  \\n is that we want to verify that the track method was called  \\n on our mocked analytics variable.  \\n And then track takes in some string parameter  \\n as part of its API.  \\n So we need to tell it what string we should expect here.  \\n So we could tell it to expect a particular string  \\n like kotlin.  \\n This would make our test a little bit less flexible though.  \\n So we can leverage another feature coming from Mockito  \\n which are matchers.  \\n Matchers will help us do pattern matching  \\n for different types of expected inputs or outputs.  \\n So rather than specifying a specific string here,  \\n I could type anyString  \\n and then import that matcher from Mockito.  \\n So if you look up at the top of our file again here,  \\n we see that we've imported the anyString function  \\n from org.mockito.ArgumentMatchers.  \\n So now what our verification line is doing here  \\n is it's going to verify that the track method was called  \\n on our mocked interface with any string value.  \\n It doesn't matter what it is  \\n as long as it's some valid string value.  \\n Now if we run this test,  \\n we should see that the test passes  \\n because the submitClicked method does, in fact,  \\n call analyticsClient.track.  \\n If we just look at our ViewModel, we can see sure enough  \\n analyticsClient.track is called  \\n whenever submitClicked is called.  \\n If we were to comment out that line of code  \\n and rerun our test here,  \\n we'll see that this time our test fails.  \\n And if we dig into our test input here  \\n and look at the failure, we will see this message  \\n indicating that analyticsClient.track was expected  \\n but was never actually invoked.  \\n This indicates to us that our expectation  \\n around that interface being used was not in fact met.  \\n So this strategy can be a good way to validate  \\n that our classes and functions are operating  \\n the way we expect.  \\n Mocking is a useful tool,  \\n but like any tool,  \\n it's not always the right tool for the job.  \\n Before reaching for a mocking tool, carefully consider  \\n whether you can set up your test without it.  \\n \\n\\n\"}],\"name\":\"8. Testing Kotlin Code\",\"size\":40965748,\"urn\":\"urn:li:learningContentChapter:3067671\"},{\"duration\":66,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:3067669\",\"duration\":66,\"visible\":true,\"requiredForCertificateOfCompletion\":null,\"name\":\"Next steps\",\"fileName\":\"3008787_en_US_09_01_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2423190,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] As we've seen throughout this course,  \\n Kotlin is a powerful and flexible language  \\n designed for building modern applications  \\n across a variety of domains.  \\n Language features such as top-level  \\n and higher order functions, default parameter values  \\n and data and sealed classes provide first class solutions  \\n to some of the most common programming problems.  \\n As you continue on with Kotlin,  \\n there are many other great resources out there.  \\n Be sure to check out Kotlin's \\\"Getting Started\\\" guide,  \\n the Kotlin org on GitHub,  \\n or work through the Kotlin Koans for more practice.  \\n You should now have the tools you need  \\n to start building complete applications with Kotlin.  \\n For inspiration on where to apply those skills,  \\n explore the Kotlin laying website for more information  \\n on how to use Kotlin to build mobile, server, browser,  \\n and even multi-platform applications.  \\n There's plenty more to learn about Kotlin,  \\n but hopefully this course has convinced you to try Kotlin  \\n for your a next project.  \\n \\n\\n\"}],\"name\":\"Conclusion\",\"size\":2423190,\"urn\":\"urn:li:learningContentChapter:3073697\"}],\"size\":515510792,\"duration\":16948,\"zeroBased\":false},{\"course_title\":\"Kotlin Essential Training: Object-Oriented and Async Code\",\"course_admin_id\":2497307,\"metadata\":{\"Locale\":\"en_US\",\"Course ID\":2497307,\"Project ID\":null,\"Course Name\":\"Kotlin Essential Training: Object-Oriented and Async Code\",\"Course Name EN\":\"Kotlin Essential Training: Object-Oriented and Async Code\",\"Activation Status\":\"ACTIVE\",\"Display to Public\":\"Yes\",\"Display to QA\":\"No\",\"Course Description\":\"If you\u00e2\u20ac\u2122re looking to get up and running with Kotlin, the powerful programming language from JetBrains, join instructor Nate Ebel, the author of &lt;i&gt;Mastering Kotlin&lt;/i&gt;, as he shows you the ins and out of Kotlin and walks you through its unique selling points for developers\u00e2\u20ac\u201dfrom null safety and concise syntax to Java compatibility, to full support by Google for Android development.In this second installment of the two-apart &lt;i&gt;Kotlin Essential Training&lt;/i&gt; series, Nate covers object-oriented programming and async code in Kotlin. He covers topics like classes, interfaces, companion objects, and coroutines. Nate also provides challenges so you can test your Kotlin knowledge as you go.\",\"Course Short Description\":\"Get a comprehensive overview of object-oriented programming and async code in the Kotlin programming language.\",\"Content Type\":\"TOOLS\",\"Localization Type\":\"ORIGINAL\",\"Original Course Locale\":null,\"Original Course ID\":null,\"Equivalent English Course\":null,\"Instructor ID\":20159017,\"Instructor Name\":\"Nate Ebel\",\"Instructor Transliterated Name\":null,\"Instructor Short Bio\":\"Staff Engineer, Google Developer Expert, and Podcast Host\",\"Author Payment Category\":\"NON-LICENSED\",\"Delivery Mode\":\"ALL_AT_ONCE\",\"Series End Date\":null,\"Course Release Date\":\"2022-06-16T00:00:00\",\"Course Updated Date\":null,\"Course Archive Date\":null,\"Course Retire Date\":null,\"Replacement Course\":null,\"Has Assessment\":\"Yes\",\"Has Challenge/Solution\":\"No\",\"LIL URL\":\"https://www.linkedin.com/learning/kotlin-essential-training-object-oriented-and-async-code\",\"Series\":\"Essential Training\",\"Limited Series\":null,\"Manager Level\":\"Individual Contributor\",\"LI Level\":\"Beginner\",\"LI Level EN\":\"Beginner\",\"Sensitivity\":null,\"Internal Library\":\"Technology\",\"Internal Subject\":\"Programming Languages\",\"Primary Software\":\"Kotlin\",\"Media Type\":\"Video\",\"Has CEU\":\"No\",\"Has Exercise Files\":\"No\",\"Visible Duration\":10301.0,\"Visible Video Count\":23.0,\"Contract Type\":\"PERPETUAL\"},\"sections\":[{\"duration\":261,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:3085327\",\"duration\":60,\"visible\":true,\"requiredForCertificateOfCompletion\":null,\"name\":\"Building more with Kotlin\",\"fileName\":\"2497307_en_US_00_01_WX30\",\"demo\":true,\"videoCreationMetadata\":null,\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2752694,\"solution\":false,\"welcomeContent\":true,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Nate] Kotlin is one of the most popular  \\n programming languages for building mobile applications  \\n being the default choice for Android development.  \\n It's no surprise why developers are turning to Kotlin.  \\n It's concise, flexible, and includes a powerful set  \\n of modern language features.  \\n With Kotlin, developers can efficiently build  \\n robust, scalable applications that run on mobile devices,  \\n in the browser, and a variety of other targets.  \\n I'm going to show you how to start writing  \\n idiomatic, object-oriented code with Kotlin.  \\n We'll start by exploring object-oriented language constructs  \\n like classes and interfaces,  \\n discuss idiomatic Kotlin patterns,  \\n and finish by introducing the basics  \\n of writing asynchronous code with Kotlin.  \\n My name is Nate Ebel.  \\n I've been building mobile applications for over 10 years  \\n and have been working with Kotlin  \\n since before its 1.0 release.  \\n If you're excited to start learning Kotlin  \\n then join me in my LinkedIn Learning course  \\n on Kotlin essentials.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3081328\",\"duration\":30,\"visible\":true,\"requiredForCertificateOfCompletion\":null,\"name\":\"What you should know\",\"fileName\":\"2497307_en_US_00_02_XR30\",\"demo\":true,\"videoCreationMetadata\":null,\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":996873,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] This course is designed  \\n to help you to continue learning the essentials  \\n of the Kotlin programming language.  \\n To get the most out of it you should already be familiar  \\n with foundational Kotlin syntax,  \\n such as variables and functions.  \\n You'll want to be comfortable  \\n with object oriented programming concepts  \\n and you should know your way around GitHub.  \\n If you feel you should brush up on any of these concepts  \\n check out the course library for more resources  \\n and come back to this course when you're ready.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3082338\",\"duration\":171,\"visible\":true,\"requiredForCertificateOfCompletion\":null,\"name\":\"Using GitHub\",\"fileName\":\"2497307_en_US_00_03_XR30\",\"demo\":true,\"videoCreationMetadata\":null,\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":5832203,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] The exercise files  \\n for this course are stored on GitHub.  \\n There are branches for both the start  \\n and end states of each video where we work on code.  \\n You can view a list of all the branches here in GitHub  \\n from the branch dropdown menu.  \\n For example, if you wanted to find the start state  \\n for video 02_01, top level properties and functions,  \\n you could look through this dropdown menu  \\n and find the branch labeled 02_01b.  \\n And the ending state would be in the 02_01e branch.  \\n There are multiple ways  \\n to work with this project from within IntelliJ.  \\n One simple way is to copy the URL  \\n from the Code button,  \\n and then open up into IntelliJ to check out the code.  \\n Once in IntelliJ,  \\n you'll want to select Get from VCS.  \\n You want to make sure Git is selected  \\n for the version control system.  \\n And then you'll paste in that copied URL  \\n into the URL field.  \\n Select whichever directory you'd like the code  \\n to be checked out into.  \\n And then click Clone to clone that repo  \\n on your local development machine.  \\n You may receive a few dialogs asking  \\n if you want to add the files to Git.  \\n Go ahead and ignore those.  \\n But chances are by the time you download the files,  \\n there will be updates to IntelliJ  \\n and the associated plugins.  \\n If you receive a dialog asking you  \\n to upgrade your dependencies, please do so.  \\n Then wait for the project to sync.  \\n It typically takes longer  \\n when the project loads for the first time.  \\n Once sync is complete, however,  \\n you're ready to work with this version of the code.  \\n By default, we're running the code  \\n from the main branch.  \\n As I mentioned earlier,  \\n I've created branches for each video  \\n in the course where we modified code.  \\n If you'd like to follow long,  \\n use the branches popup menu  \\n in the lower right corner of IntelliJ  \\n to change your desired branch.  \\n As an example,  \\n let's check out the code for the start  \\n of the 03_01 video.  \\n So I can search 03_01  \\n and I will select the b branch to check out the code  \\n for the beginning of that video.  \\n Once I click the branch name,  \\n I'll be prompted to check out the code.  \\n And now once that's complete,  \\n we're ready to work with this version of our project  \\n and follow along with 03_01.  \\n If you run into any trouble checking out  \\n the different branches,  \\n or with using Git in general,  \\n I recommend searching the course library  \\n for the Git Essential training videos.  \\n \\n\\n\"}],\"name\":\"Introduction\",\"size\":9581770,\"urn\":\"urn:li:learningContentChapter:3084294\"},{\"duration\":5375,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:3087333\",\"duration\":1172,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Classes\",\"fileName\":\"2497307_en_US_01_01_XR30\",\"demo\":true,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to define and extend classes in Kotlin. This is core to any modern object-oriented programming language.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":36519222,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - Classes are the cornerstone  \\n of object oriented programming,  \\n helping us model data types behavior and real world objects.  \\n Let's dive right in and learn to define  \\n and extend classes in Kotlin.  \\n To create a class, the first thing that we're going to do  \\n is come in to our source main Kotlin directory,  \\n right click, go to New, Kotlin class/file.  \\n We're going to select class here.  \\n And then we are going to type person,  \\n and hit Enter.  \\n Notice what's created here.  \\n We have this class keyword,  \\n and then the name of the class person  \\n followed by these empty curly braces.  \\n And in fact, since there's nothing inside  \\n of those curly braces,  \\n we can actually remove them altogether.  \\n And this will provide the basic definition  \\n of our person class.  \\n Now we'll create a main.kt file  \\n and we will add a main function for us  \\n where we can then use this person class.  \\n To instantiate a new instance of the person class,  \\n we'll create a variable called \\\"Person.\\\"  \\n And then we use the name of the class that we want to create,  \\n followed by the open and close parentheses  \\n for the constructor.  \\n So here we have a new instance  \\n of the person class that we created  \\n in our file person.kt.  \\n Now classes may include variables that are scoped  \\n to a specific instance of that class.  \\n This type of variable is also known as a class property.  \\n Let's define a property named \\\"Age\\\" for our person class.  \\n So we're going to add back those curly braces  \\n to define our class body.  \\n And now within this class body,  \\n we define a variable like we would  \\n in let's say our main function.  \\n So I'm going to make this a read only variable.  \\n So I will use val.  \\n I will name it Age, and I want it to be of type Int.  \\n Now, as soon as we're done typing that  \\n we'll notice that the IDE warns us,  \\n that we must initialize the value  \\n or make our class abstract.  \\n Abstract classes are like class templates.  \\n They define state and behavior that may be reused  \\n by classes that are going to extend the base abstract class.  \\n To mark a class abstract, we come to the beginning  \\n of the class declaration before the class keyword,  \\n and we add the abstract modifier to it.  \\n And if we wanted to leave our property uninitialized as well  \\n we could mark the property abstract as well.  \\n So abstract can apply at both the class level  \\n and the property level.  \\n By marking the property abstract in this case,  \\n we would leave the initialization  \\n to whatever class later extended the person class.  \\n Now let's go ahead  \\n And instead we're going to provide an initial value  \\n for our age property.  \\n And we're going to do this by providing a constructor parameter  \\n to our class where we can pass in the age  \\n for that instance of the person class.  \\n So to add a constructor parameter,  \\n we need to come after the class name  \\n and add parenthesis like we would  \\n if we were defining the parameters for a function.  \\n And now within this,  \\n as we would with function parameters.  \\n So in this case,  \\n we will have a parameter called Age of type Int.  \\n Once we have our age constructor parameter,  \\n we can use that as the value for our age property.  \\n So we could say val age equals age.  \\n A property may have its value initialized  \\n by constructor properties,  \\n or we could have hard coded an age, say, of five here.  \\n Now, what if we wanted to validate the state  \\n of the parameters passed into our constructor?  \\n How could we check that our age parameter is a valid value  \\n before assigning it to our property?  \\n For example, passing a negative age  \\n to our person constructor wouldn't make sense.  \\n So we might want to check  \\n that it is not a negative value, for example.  \\n So for this type of parameter validation,  \\n we could leverage an init block.  \\n Init blocks are sections of code that run  \\n when an instance of a class is created.  \\n To create init block,  \\n we simply type init followed by curly braces.  \\n Init blocks and properties are processed in the order  \\n in which they're defined within a class body.  \\n So if we want to check the value of age before it's used,  \\n we can add an init block before the declaration  \\n of our age property.  \\n So in this case, I'm just going to move  \\n that property declaration before the init block.  \\n And now within the init,  \\n we can use the check function  \\n to ensure that the age parameter is  \\n greater than zero.  \\n What the check function will do here is throw in exception  \\n and print out the message defined by this lambda  \\n if the condition is not met.  \\n So within the lambda passed to check here,  \\n we'll provide a message that says,  \\n \\\"A person's age  \\n cannot be negative.\\\"  \\n So just to test this out then,  \\n if we come back to our main function here,  \\n if we passed in an age of zero  \\n and we ran this code,  \\n actually in this case, when we ran our code,  \\n we see an error here by the IDE  \\n mentioning something about a duplicate JVM class name.  \\n This is likely due to us  \\n incorrectly naming our Main kt file.  \\n So in this case,  \\n we can rename this file,  \\n and we will use a M here.  \\n So it's M .kt.  \\n Now, if we run this again,  \\n this time we see an illegal state exception,  \\n and it says, \\\"A person's age cannot be negative.\\\"  \\n This makes sense here,  \\n as we used the check function  \\n to verify the age is greater than zero.  \\n If we wanted to,  \\n we could probably make this greater than or equal to zero  \\n to make it just a little bit more  \\n what we would expect.  \\n Technically, a person could maybe have an age of zero.  \\n So if we run this one more time now with zero,  \\n we see no error.  \\n And if we pass in negative one and rerun,  \\n this time we see the error that we expect.  \\n So that's just one example of how we could use an init block  \\n to help validate the state of our class  \\n when it is being instantiated.  \\n Now, in cases where we don't need to validate a parameter  \\n before assigning it to a property,  \\n we can use a simplified syntax  \\n for defining class properties  \\n right in the constructor itself.  \\n We're going to add properties for storing the first name  \\n and last name in our person class.  \\n To do so, we're going to come back up to the constructor  \\n after the age property,  \\n and we're going to define the first name  \\n and last name properties  \\n just like with the parameter.  \\n The only difference is that now we will add Val  \\n before the name of the parameter.  \\n So I'll say, val, first name of type string.  \\n Val, last name of type string.  \\n And just to help fit this all in the editor window,  \\n we'll break these all out onto their own lines,  \\n just to make it a little easier to see.  \\n So now we have a parameter called Age  \\n and we actually have two class properties,  \\n first name and last name.  \\n So now if we come back to our Main kt,  \\n we now need to add first name and last name  \\n like we did with the age perimeter.  \\n So I could add my first name \\\"Nate\\\"  \\n and my last name of \\\"Ebel\\\" here.  \\n And now I can access all of these values  \\n by using property access syntax.  \\n So I could write a dot  \\n and then access the age property by its name directly.  \\n Or person.firstname  \\n or person.lastname.  \\n By default, these properties have all been public.  \\n If we wanted to limit their scope,  \\n we could add the private visibility modifier  \\n to any of the properties.  \\n So for example,  \\n if we wanted to make first name and last name private  \\n so that was only accessible within this class itself,  \\n we can add the private modifiers to them.  \\n And now if we come back to our main function  \\n we'll get compiler errors telling us  \\n that first name and last name are private  \\n within the scope of the person class.  \\n Meaning we can't access them.  \\n So we'll just go ahead and clean those up for now,  \\n since they are now private to our person class.  \\n Now, in addition to properties  \\n classes may have methods associated with them as well.  \\n A method is just a function scoped  \\n to a particular class or interface.  \\n Methods help us encapsulate class specific behavior  \\n in a reusable manner.  \\n Let's write a method to print the full name of a person.  \\n So I'll come down here  \\n within our person class body after the last property  \\n and I'm going to start writing a new function.  \\n So I'll use the fun keyword  \\n and I want to call this function print name.  \\n And I'll define this as a single expression function.  \\n And the right side of that expression  \\n is going to use println,  \\n and we will use a string template here  \\n to print out first name and last name.  \\n So now once this method is defined on our class  \\n if we come back over here to Main kt,  \\n we could access person.printName  \\n to invoke that function.  \\n So now just before we run this code,  \\n let's change the age from a invalid negative age  \\n to a valid age here.  \\n And if we run this,  \\n we'll see my name printed out to the console  \\n when that print name function is invoked.  \\n One of the really powerful things  \\n about classes is that they can be extended  \\n and modified to reuse and change behavior.  \\n Let's create a student class that extends person.  \\n So the first thing that we're going to want to do here  \\n is modify our person class to make it open for extension.  \\n We need to do this  \\n because classes in Kotlin are closed for extension  \\n by default.  \\n This is to help enforce the concept of imutability.  \\n So to open up the person class for extension  \\n we add the open keyword to it  \\n before the class declaration.  \\n Once the person class has been marked as open,  \\n now we're ready to create a student class, which extends it.  \\n So again, we'll come back over to our project window.  \\n We'll go to source main Kotlin.  \\n Right click,  \\n go to New, Kotlin file/class,  \\n and I'll create a new class called Student.  \\n Now, the student class to start  \\n is going to take no parameters.  \\n So we'll just add empty parentheses after the class name.  \\n And now to make it extend the person class,  \\n we will add a colon.  \\n The name of the person class,  \\n followed by parentheses representing the constructor  \\n of that person class.  \\n Now person requires constructor parameters.  \\n So we must pass those to the constructor.  \\n So in some way, we have to be able to get those values  \\n into the person class.  \\n And so we could pass those directly here  \\n within the class declaration  \\n or we could add constructive parameters  \\n to the student classes constructor.  \\n So that's what we're going to do.  \\n I'm going to just hit enter within the student constructor.  \\n And then I'm going to add an age parameter.  \\n A first name parameter,  \\n and a last name parameter.  \\n Now notice that none of these are defined as properties.  \\n We haven't added a val or var in front of any of these.  \\n The idea is to simply pass them to the constructor  \\n and forward them onto the person constructor.  \\n So once we have defined those parameters  \\n within the student constructor,  \\n we can go ahead and pass them  \\n to the person constructor here.  \\n Now, if we come back over to our Main,  \\n we can demonstrate how we might use this.  \\n So, anywhere that we need an instance of person  \\n we could provide an instant of student.  \\n So let's come back up here where we've defined  \\n our person variable.  \\n And we're going to be explicit with this.  \\n And so we're going to explicitly define the person type  \\n on our person variable.  \\n And now, rather than creating an instance  \\n of the person class,  \\n we will create an instance of the student class.  \\n And because student is a subtype of person,  \\n this will compile just fine.  \\n And in fact, if we run this code, we will still see  \\n that our print name method works as expected  \\n because it is public and present in that base class,  \\n so it's accessible from the child class student.  \\n Now, what if we wanted to override the behavior  \\n of that print name method in the student class?  \\n Well, the first thing we would need to do  \\n is go back to person  \\n and we would mark the print name method as open.  \\n This is very much the same way  \\n that we marked the person class as open.  \\n So if we want to override the behavior of a method,  \\n we mark it as open,  \\n and then we can come back to our student class now,  \\n and we will add a class body.  \\n And now we can override the behavior  \\n of the print name method for an instance of student.  \\n So to do this, we can start typing override  \\n and the compiler should suggest methods  \\n that are available to us to override.  \\n So in this case, it suggests print name.  \\n And I can hit Enter here,  \\n and it will generate the method signature here for us.  \\n So notice that this signature looks very much the same  \\n as it did in person.  \\n However, it has added the override modifier to it.  \\n So that signifies  \\n that we are about to override the default behavior  \\n with our own custom behavior.  \\n So, if we want to override that behavior,  \\n we could again use println.  \\n And this time we will start off  \\n by typing student with maybe a colon here,  \\n just as a separator.  \\n And then we will go ahead  \\n and print out first name  \\n and last name.  \\n Now, notice that the compiler is telling us here  \\n that we cannot access last name or first name.  \\n Now, why is that?  \\n Hope you remember,  \\n we made first name and last name private  \\n in our person class here.  \\n To expose a property or a method  \\n to just classes overriding it,  \\n we could use the protected modifier  \\n rather than private.  \\n So with protected,  \\n our student class can now access those properties.  \\n However, from our main function here,  \\n we still cannot access first name or last name.  \\n So back here in student,  \\n we've now finished overriding the behavior of print name.  \\n So now, if we were to run our main function here,  \\n when print name is called for our instance of student  \\n we see the updated behavior.  \\n We see student prefix printout  \\n followed by the first and last name.  \\n So this demonstrates the idea of polymorphic behavior  \\n where we have created custom behavior  \\n for the same method name.  \\n And so if we had a student subtype,  \\n we could have one set of behavior.  \\n We might have an instructor type that extends person.  \\n It could have another behavior for a print name.  \\n It's a very powerful concept for us.  \\n This is just the beginning for classes in Kotlin.  \\n Later, we'll see how Kotlin allows us  \\n to define multiple special types of classes  \\n that helps solve very specific  \\n object oriented programming challenges.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3087334\",\"duration\":749,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Interfaces\",\"fileName\":\"2497307_en_US_01_02_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to define an interface and provide default implementations. This is essential to writing scalable, object-oriented code.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":24529719,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Interfaces allow us to define  \\n reusable type contracts to be implemented by other classes,  \\n objects, and even interfaces.  \\n We're going to explore how to define an interface,  \\n how to define methods and properties on that interface,  \\n and finally, we'll see how to provide default  \\n implementations for interface methods.  \\n Now let's define our first interface in Kotlin.  \\n We're going to do this within our main.KT file here.  \\n We could also do this in another file  \\n but for now we'll keep it all in one file  \\n just to keep it simple.  \\n So to define a basic interface,  \\n we start by typing the interface keyword  \\n and then the name of the interface.  \\n So in this case, we're going to call our interface  \\n string provider.  \\n At the moment, This interface has no methods or properties  \\n but it could still be implemented by other types  \\n and we could check if a variable is an instance  \\n of strength provider by using the is keyword.  \\n So for example, if we come down into our main function here,  \\n we'll create a variable called some variable  \\n and it will be of type knowable any  \\n and we'll just initialize it to a null value to start.  \\n Now we could check if some variable is an instance  \\n of string provider, and if it is, we could do something  \\n like print an error message saying the variable  \\n was a string provider.  \\n Now if we were to run this code,  \\n of course we would not see this message  \\n because we know some variable is assigned to null right now.  \\n Now to extend the utility of our interfaces,  \\n we typically want to add methods to our interface  \\n which must then be implemented by any class  \\n implementing the interface.  \\n We may add a method to an interface  \\n by defining a function signature within our interface body.  \\n So we'll start by adding open and closed curly braces  \\n to define an interface body here.  \\n And then we'll define a method named get string  \\n and it will take in an ID parameter of type int  \\n and it will return an int.  \\n So the idea here is that a string provider  \\n will allow us to give it some resource identifier  \\n and hand us back a string.  \\n So now any type that extends this string provider  \\n interface must either be marked abstract  \\n or implement this get string method signature.  \\n Once we've defined an interface,  \\n we can define other types that then implement  \\n that interface.  \\n So let's define a class called default resource provider.  \\n To make default resource provider implement string provider,  \\n we add a colon after the class name  \\n and then we add the name of the interface.  \\n As soon as we do that, the IDE is going to warn us  \\n that we need to implement the get string method.  \\n Otherwise, default string provider must be made abstract.  \\n So let's implement get string for default resource provider.  \\n We'll start by adding open and close curly braces  \\n for our class body.  \\n And then I'll hit enter a couple times  \\n just to give us some space  \\n and then we're going to start typing override.  \\n Now notice here that my IDE is suggesting  \\n an override option of get string.  \\n If I hit enter on that,  \\n it is going to generate a default implementation  \\n of this get string method needed  \\n for the string provider interface.  \\n Now it defaults to this todo function here,  \\n which will actually throw an exception  \\n if this line of code is executed during runtime.  \\n So for now, we're going to replace this todo  \\n with a string that indicates whatever ID was passed to us.  \\n So we'll say ID: and then we will substitute in that ID.  \\n So this will just give us some indication  \\n of what was actually passed into this method.  \\n Now that our default resource provider is fully implemented,  \\n we can create an instance of it,  \\n and because it implements string provider,  \\n we can use it both as default resource provider  \\n or as the less specific type, string provider.  \\n So let's come back down into our main function  \\n and create a variable here called string provider  \\n of type string provider.  \\n And we will assign it an instance  \\n of default resource provider.  \\n And if we wanted to, we could type print L in here  \\n and print out the result of calling  \\n string provider.get string  \\n and we'll pass in some int ID, in this case five.  \\n So if we run this, we will see  \\n that we have the ID five printed out  \\n which is exactly what our implementation  \\n of get string is designed to do.  \\n And now notice here,  \\n using the less specific type of the interface.  \\n If we wanted to, we could change this  \\n to default resource provider.  \\n And if we run the code again, we would see the same output.  \\n I'm going to go ahead and change it back  \\n to the more generic type,  \\n as that is usually a helpful coding practice.  \\n Now classes aren't the only thing  \\n that may extend an interface.  \\n Interfaces may actually extend other interfaces as well.  \\n So let's create a new interface  \\n and this interface will be called resource provider  \\n and it will have a single method in it  \\n called get dimension.  \\n And again, it will take an integer ID parameter.  \\n And this time it will return along.  \\n We're going to make this resource provider interface  \\n extend string provider  \\n in the same way that we would for class.  \\n So now, if we come down here  \\n to our default resource provider class,  \\n if we change it from implementing string provider  \\n to implementing resource provider,  \\n the IDE will let us know  \\n that we need to add an implementation of get dimension.  \\n So to complete the implementation here,  \\n we'll start typing override,  \\n we'll hit enter for get dimension.  \\n And in this case, we will return id.toLong.  \\n So again, just kind of a placeholder output here  \\n but notice the interesting thing here,  \\n we've overridden both get string and get dimension.  \\n Now resource provider itself  \\n doesn't have a get string method on it  \\n but because it extends the string provider type,  \\n default resource provider must implement both.  \\n This ability to have interfaces  \\n which themselves implement other interfaces  \\n can be really helpful when modeling data via composition.  \\n In addition to methods,  \\n interfaces may also define properties.  \\n Let's define a property named placeholder  \\n on our string provider interface.  \\n To define a property,  \\n we do it much the same we would on a class.  \\n So we would type val placeholder of type string.  \\n Once we have done so,  \\n we must now update any classes  \\n that are implementing string provider.  \\n So in this case here,  \\n that is really just our default resource provider class.  \\n So to override a resource,  \\n we can start much the same way we would with a method.  \\n We can start typing override  \\n and then we finish the implementation  \\n of the placeholder property.  \\n Now by default here,  \\n the IDE starts by providing this getter  \\n and we could provide some default string value  \\n here using this syntax.  \\n We could also assign a value directly,  \\n and in this case, that's what we'll go with.  \\n So in this case, we'll define a placeholder  \\n using some special syntax here.  \\n So we'll use angle brackets and the placeholder text here,  \\n just so that it's very clear  \\n that this is going to be a placeholder string.  \\n Now, any place where we are working with  \\n default resource provider,  \\n we should have access to this placeholder value.  \\n So if we come down to our main function,  \\n we could print this out by saying  \\n string provider.placeholder.  \\n And if we run our code,  \\n we'll see that placeholder printed out as we would expect.  \\n Now let's say we define an interface method  \\n that has a well-defined default behavior.  \\n Rather than having to reimplement that default behavior  \\n in every implementing class.  \\n Kotlin allows us to define a default implementation  \\n for an interface method.  \\n To provide the default implementation,  \\n all we need to do is finish implementing the method  \\n in our interface.  \\n To demonstrate this, let's update both string provider  \\n and default resource provider to provide  \\n default method implementations.  \\n So first we'll provide the default implementation  \\n for get string by having it convert the past ID  \\n to a string and returning it.  \\n So we can do that pretty simply here  \\n by turning this into a single expression function  \\n and returning id.tostring.  \\n And next, we'll repeat this process  \\n for the get dimension method on resource provider.  \\n And now, because both interfaces  \\n have default implementations for their methods,  \\n default resource provider now no longer  \\n needs to override those methods.  \\n It could if we wanted to, but it doesn't need to.  \\n And now let's come back to string provider  \\n and just take a look at our placeholder.  \\n Could we provide a default value for a placeholder here?  \\n Well, if we try to, we'll actually see  \\n that we have an error here as soon as we try and assign  \\n a string value.  \\n And if we hover over this, we'll see this message  \\n saying property initializers are not allowed for interfaces.  \\n So while we can provide default implementations  \\n for an interface, we cannot provide a default value  \\n for an interface property.  \\n Interfaces are an essential component  \\n to writing object-oriented code with Kotlin,  \\n and the ability to divine interface properties  \\n and default method implementations  \\n makes Kotlin's interfaces even more useful to developers.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3087335\",\"duration\":733,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Enum classes\",\"fileName\":\"2497307_en_US_01_03_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to define an enum class to enumerate over a closed set of values. This is particularly helpful when modeling API responses or errors.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":21842918,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Sometimes we want to define a new type  \\n that only has a limited set of values.  \\n Enum classes are a special class type  \\n that help us do just that.  \\n Let's look at how we can use enum classes  \\n or just enums to define some closed set of values.  \\n When working with enums,  \\n we typically want to start  \\n by thinking about the values we need to model.  \\n So for example, let's imagine we want  \\n to model the four cardinal directions.  \\n So those would be north,  \\n east, south, and west.  \\n These are the only four directions possible.  \\n Because we know these are the only values we ever want  \\n to work with, an enum class is a natural fit.  \\n We can define each possible value  \\n and prevent the addition of any other value.  \\n To define the enum class,  \\n we're first going to create a new file  \\n by opening up our project pane here  \\n and within src, main, kotlin,  \\n we will right click, go to New,  \\n Kotlin Class or File.  \\n And we'll scroll down this list  \\n and we will select enum class.  \\n And for the name,  \\n we will use Direction.  \\n And then I'm just going to remove the curly braces  \\n to make it a little bit easier to read here.  \\n So what we have here  \\n is a class called Direction  \\n with the enum modifier added to it.  \\n So in this case, Direction will be the type,  \\n and now we need to define the possible values  \\n of that Direction type.  \\n To define the set of values for an enum class,  \\n we may add a class body  \\n and then write out comma-separated value names.  \\n These enum value names  \\n are typically written in all caps.  \\n So we want to represent the directions,  \\n we would then have a value of NORTH,  \\n EAST, SOUTH, and finally, WEST.  \\n Now we can define variables  \\n using the Direction type  \\n and we will only have these four possible values  \\n that can be assigned to that type.  \\n So I'll return back to Main.kt here.  \\n I will go ahead and just remove my notes there  \\n and within the main function,  \\n I'll create a variable called direction  \\n of type Direction  \\n and I can assign it a value  \\n by referencing the Direction type name  \\n and then one of the values.  \\n So in this case, I've assigned it to Direction.EAST.  \\n I could change it to NORTH if I wanted  \\n or any of the other two values.  \\n Any enum value has a couple of common properties.  \\n We may access the name of the enum value.  \\n So in this case, I could reference my enum variable  \\n and then access the name property  \\n by writing .name.  \\n The name will be a string representation  \\n of the actual type name defined in the enum class body.  \\n So if we just print out this direction.name call here  \\n and we run our code,  \\n we will see NORTH printed out to the console  \\n just the same way that it was defined  \\n in the enum type declaration.  \\n If I were to change this from NORTH to say WEST,  \\n and run this again,  \\n we'll see WEST printed out.  \\n So there's a pretty direct mapping  \\n between the way the name is defined  \\n in the enum class,  \\n and how it is represented when accessing the name property.  \\n We can also determine the index  \\n of the value within the type  \\n by using the ordinal property.  \\n So let's again, we'll do a println here  \\n and this time we'll say direction.ordinal.  \\n So again, the ordinal  \\n is representing the index into that type.  \\n So in this case,  \\n for the value of WEST,  \\n its ordinal should be three  \\n because it is the fourth item we declared  \\n and because we're zero based,  \\n that means the indices would be zero, one,  \\n two, and finally, WEST would be three.  \\n So if we return to Main.kt  \\n and we go ahead and print this out.  \\n Sure enough we see the name WEST printed out  \\n and we see three printed out for the ordinal.  \\n Now, we can use these concepts  \\n in the other direction as well.  \\n We can convert a string into an enum value  \\n by using valueOf.  \\n So we could do something like Direction.valueOf  \\n and pass in WEST here.  \\n And if I created a new variable called parsedDirection,  \\n I could assign it the result of this value of call.  \\n And if we then call println direction.name,  \\n if we run this,  \\n we will see WEST printed out a second time.  \\n So we were able to correctly parse this string value,  \\n turn it into a valid Direction type  \\n and then print that out.  \\n If we were to pass something else in here,  \\n like the word kotlin,  \\n and we try to run this code,  \\n we would get an exception.  \\n We see an IllegalArgumentException here saying  \\n no enum constant Direction.kotlin.  \\n So effectively, this is saying there is no value  \\n that matches this name.  \\n If we wanted to understand all of the values  \\n that were available,  \\n we could do that as well  \\n by calling the values method.  \\n So I'm going to create a new variable  \\n called apiValue here  \\n and I will assign it the result of saying Direction.values.  \\n And this is going to give us back an array  \\n of the available values for this enum.  \\n So if I wanted to get say the third item,  \\n I could pass in an index of two.  \\n So again, let's go ahead and print out the name of this,  \\n so we could say apiValue.name.  \\n And just to help us verify our output,  \\n I'm going to comment out the other print calls here.  \\n So now if we run our code,  \\n oops, we need to make sure we comment out this parsing  \\n of the incorrect Kotlin value.  \\n Now if we go ahead and run our code, we see SOUTH.  \\n And if we check our direction type,  \\n sure enough, SOUTH is the third item corresponding  \\n to index two.  \\n But again here, we need to be careful  \\n that we don't try to access an element  \\n that doesn't exist.  \\n If we were to pass in an index  \\n of say six right here,  \\n and run our code,  \\n we would again get an exception.  \\n This time an ArrayIndexOutOfBoundsException  \\n because there are not that many values  \\n in this Direction.values array.  \\n So we must be careful when trying  \\n to access elements this way  \\n but when used safely,  \\n these approaches can help us  \\n when mapping non-type safe responses  \\n into our concrete enum values.  \\n Now, let's create another enum class here.  \\n And I'm going to open up the project directory again.  \\n Again, navigate to src, main, kotlin.  \\n Click New, Kotlin File or Class.  \\n Again, I will select enum class  \\n and this time, we're going to name this HighlightColor.  \\n So now we have again a very basic HighlightColor type  \\n with no values.  \\n So now let's imagine that each value we define here  \\n should represent some hex color.  \\n So we might want each value  \\n to provide its own hex color value  \\n that we could use to render to the screen.  \\n Well, enum types can provide properties  \\n that every value type must then implement.  \\n So within our enum class HighlightColor,  \\n we can add a constructor here,  \\n and we can define a property  \\n that will then be present on any value type of this enum.  \\n So I'll type val value  \\n of type Int here.  \\n So this will represent the hex value  \\n for any of the specific value types within HighlightColor.  \\n Now we will go ahead and create a class body  \\n and we're ready to start defining some value types here.  \\n So we could start off by writing the name  \\n of YELLOW, let's say,  \\n and now we see that we have an error here.  \\n If we hover over that,  \\n we'll see that enum has no default constructor.  \\n So effectively what it's saying here  \\n is that we need provide the value integer.  \\n So instead of just defining the value name here,  \\n we will go ahead and add a constructor  \\n and now we can provide some integer value  \\n representing a hex color.  \\n So in this case,  \\n I've got a couple of these colors saved off.  \\n So I will just type this out.  \\n 0xebba34.  \\n And then I might want to define,  \\n let's say a BLUE value.  \\n And lastly, I'll add in a PURPLE value.  \\n So each of these are now named value types  \\n within the HighlightColor enum  \\n and they each have their own hex value available  \\n as a property.  \\n So now if we come back to our Main.kt here,  \\n so now we'll create a variable called color,  \\n and assign it one of these HighlightColor values.  \\n So in this case I'll say HighlightColor.BLUE.  \\n And now I could print out the result  \\n of saying color.value.  \\n So that value property then is corresponding  \\n to this property that we added  \\n to the HighlightColor constructor.  \\n And if we print this code out,  \\n oh, we will again see our ArrayIndexOutOfBounds here,  \\n again because we didn't comment the previous example.  \\n There we go.  \\n Now we'll run this one more time.  \\n And there we go.  \\n We have the hex value for the blue color.  \\n Enum classes are very helpful  \\n when we try to model real-world data  \\n in a type-safe way.  \\n We might use enums to ensure our network responses  \\n are safer, or our database responses are safer.  \\n They're a great option when trying to limit the set  \\n of values coming in or out of our APIs.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3082339\",\"duration\":707,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Data classes\",\"fileName\":\"2497307_en_US_01_04_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to represent value-holder types in a concise syntax using data classes. Data classes save a lot of code and help encourage immutable coding practices.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":21087754,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] When writing object oriented code,  \\n it's common practice to have types  \\n that are simple value holders,  \\n that have no real business, logic, or purpose  \\n other than to hold some set of data.  \\n Data classes in Kotlin are specifically designed  \\n for this purpose and have several useful traits  \\n that help reduce boilerplate code.  \\n We can define a data class, much like a regular class,  \\n but using the data modifier and with a few restrictions.  \\n So let's open up our Project pane here,  \\n and we're going to create a new Kotlin class or file,  \\n and we are going to select the Data class option,  \\n and we will name this class Task.  \\n So this is now created a new Task.kt file.  \\n And with it, a data class named Task.  \\n Notice the data modifier in front of the class name.  \\n This is what differentiates a class from a data class.  \\n Now, by adding that data modifier,  \\n we bring with it some restrictions that data classes have.  \\n And one of those special restrictions on data classes  \\n is that they must contain at least one constructive property  \\n in their primary constructor.  \\n So if we actually place our cursor over our constructor,  \\n we see that it is indicating to us here,  \\n Data class must have at least  \\n one primary constructor parameter.  \\n So the IDE in compiler are working in conjunction here  \\n to let us know about this restriction.  \\n So to satisfy this requirement  \\n to have at least one primary constructor perimeter,  \\n we will add a read only property named name.  \\n I'll do that by adding val_name with the type of String.  \\n Now, if we go back to Main.kt here,  \\n we can create a couple of tasks.  \\n We'll create task1.  \\n And when we call our constructor,  \\n we need to pass a name for that task.  \\n So we will call that Build search feature.  \\n And let's create a task2 variable here.  \\n And this task will be named Add analytics.  \\n Now, if we go back to our Task.kt file here,  \\n that name property is public.  \\n So from Main.kt, we can access that public name property.  \\n So here we will just print out the names of each task.  \\n So we'll say println task1.name,  \\n and then we'll duplicate that and we will do task2.name.  \\n If we run our code,  \\n we will see Build search feature for task1  \\n and Add analytics for task2,  \\n which are the names we provided.  \\n Now, what if we wanted to know  \\n if these variables represented these same task?  \\n We could manually check the value of the name property  \\n to do the comparison and print out the results  \\n that might look something like this,  \\n where we have an if conditional here,  \\n and we could say task1.name == task2.name,  \\n println Tasks are the same,  \\n else println Tasks are different.  \\n And if we run this, we see tasks are different printed out.  \\n No surprise.  \\n If we compared, let's say, task1.name to task2.name,  \\n we see tasks are the same.  \\n And, just as a more interesting example,  \\n let's take the name of task2 and use it for task1 as well.  \\n Now, if we run this one more time, we, once again,  \\n we see tasks are the same.  \\n So the idea here is that  \\n by using the data held in the task itself for comparison,  \\n we can more accurately compare these  \\n in situations where all we care about is the data.  \\n So I'm just going to revert the change to task1's name here,  \\n put it back to the original Build search feature.  \\n So we've seen with this name comparison here  \\n that we can accurately compare the data held  \\n in task1 and task2.  \\n However, this doesn't scale well.  \\n Imagine your task class had 5 properties  \\n or 10 properties.  \\n Would you want to manually check each value?  \\n Probably not.  \\n In the Java world, the way we would solve this  \\n is by implementing equals and hash code  \\n so the values could be compared directly.  \\n In Kotlin, data classes actually take care of this for us.  \\n The Kotlin compiler will generate the needed code  \\n to compare data classes  \\n based on their constructor properties.  \\n So rather than manually checking the name of each task  \\n and any other properties that we might add to task  \\n in the future, we can compare the task variables directly.  \\n So we could say task1 == task2 here.  \\n And unsurprisingly, if we run the code,  \\n we see that the tasks are different.  \\n If we update the tasks, so the names are the same,  \\n the output will show that they are the same task.  \\n So we'll repeat what we did before.  \\n We will use the Add analytics name for both tasks.  \\n And now, if we run this,  \\n this time, we see tasks are the same  \\n because that name property is the same for each task.  \\n So I will now revert the name one more time.  \\n Let's add an id property to our data class.  \\n So we'll open up a Task.kt again  \\n and we will add another val,  \\n then with the name of id and of type String again.  \\n Now back in Main.kt,  \\n we will need to update the constructors to provide an id.  \\n So for task1, we'll provide an id a1.  \\n And for task2, we'll provide an id b2.  \\n But now, even though we've added this new id property,  \\n we don't have to update our equality check  \\n when doing the task comparison in our main function.  \\n And so if we run this once again,  \\n we'll see tasks are different  \\n because they have different ids and different names.  \\n If we were to, again, then use the same name for each task  \\n but leave the ids different,  \\n we still see that the tasks are different.  \\n And if we use both the same name and the same id,  \\n now we see that the tasks are treated as the same.  \\n So with this one equality comparison  \\n of task1 compared to task2,  \\n it is looking at the actual values held by each property  \\n and tells us whether those values are the same or not.  \\n This is an incredibly powerful feature  \\n because it helps us scale our code base  \\n without having to update all of our comparisons  \\n in every place where we use a given data class type.  \\n Another useful feature of data classes  \\n is that the compiler generates a copy function,  \\n which may be used to copy an instance of a data class  \\n along with all of its associated data.  \\n So we could make a copy here of task2  \\n and store it in a variable called task2Copy.  \\n To make the copy, we would access task2.copy.  \\n Now, in our comparison,  \\n we could compare task2Copy to task2.  \\n And we see that the tasks are the same.  \\n Now part of the data class magic  \\n is that the copy function allows us  \\n to modify specific values when calling that copy function.  \\n So if we wanted to copy task2 but change the id,  \\n we could easily do so by using a named argument  \\n when calling copy.  \\n So now we'll update our call to task2.copy  \\n to specify a custom id of c3.  \\n So now, if we run this code,  \\n we'll see that the tasks are different  \\n because task2Copy has the id of c3,  \\n whereas task2 has the original id of a1.  \\n The last data class feature we'll explore is destructuring.  \\n Destructuring declarations allow us  \\n to extract the public values of a data class  \\n into variables without having to explicitly reference them.  \\n Let's say we want to extract the id and name of task1.  \\n Well, we could start by writing val.  \\n And then in parentheses, we'll define the name  \\n of each variable that we want to hold the id  \\n and name for the task.  \\n So in this case, we'll just say id and name.  \\n Those will be our two variable names.  \\n And then to assign those values, we simply say = task1.  \\n The variables will have their values assigned  \\n in order of the property declarations in the data class.  \\n So here, since we defined id first,  \\n it will be assigned to the first property in the data class,  \\n which corresponds to the id property.  \\n And similarly, the name variable here will be associated  \\n with the name property of the task data class.  \\n If a data class had three properties  \\n and used destructuring with only two variables,  \\n the first two data class properties would be extracted  \\n and the third one would be unused.  \\n Once the destructuring declaration is executed,  \\n each variable will be initialized  \\n to match the data class property values.  \\n Data classes help encourage immutability  \\n and reduce the amount of code required  \\n for making direct comparisons  \\n or for copying of our value holders.  \\n You might consider data classes  \\n for representing API responses,  \\n database elements, or UI states,  \\n really anything you might want to compare  \\n that would benefit from being immutable.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3082340\",\"duration\":429,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Object classes\",\"fileName\":\"2497307_en_US_01_05_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to define concise, thread-safe singletons using less code.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":12888570,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Singleton is a design pattern for ensuring  \\n that only a single instance of a class exists  \\n at any time within the runtime of an application.  \\n In Kotlin, object declarations provide a concise thread  \\n safe syntax for writing singletons,  \\n creating an object declaration is quite simple.  \\n So let's open up our project window here,  \\n navigate to source main Kotlin,  \\n we're going to right click, go to new Kotlin class or file  \\n and if we scroll down to the very bottom  \\n we will see an option for object.  \\n So we're going to select that object choice  \\n and we are going to name this NetworkConfig and hit enter.  \\n So, once we remove the empty class body that was generated  \\n we're left with this.  \\n We have the object keyword representing that  \\n we want this to be an object declaration  \\n and NetworkConfig as the name.  \\n So we have this network config object declaration defined  \\n which means there would only be one instance  \\n of this ever created within our application when we run it  \\n and it will be initialized the first time we access it.  \\n So if we never actually use this  \\n then it'll never be in instantiated.  \\n If we access it once, then we'll get the same object  \\n throughout the lifetime of our application.  \\n Now, let's imagine we need to define several  \\n properties that might control our networking layer.  \\n We can add those to our NetworkConfig class  \\n like we would any other class, except for one thing,  \\n we can't use a constructor.  \\n So, we'll create a class body here  \\n and we'll start by defining a property called base URL  \\n and set that equal to http://<some url>,  \\n the URL doesn't really matter here.  \\n And then we might also have a property called userAgent  \\n and we'll set it equal to demo app.  \\n Now, because object classes are singletons  \\n they're instantiated for us upon first access  \\n which means they do not have a constructor  \\n which also means that we may use them  \\n without having to first in instantiate them.  \\n So, if we go back over to main KT,  \\n we could access the base URL by referencing the name  \\n of the type in this case, NetworkConfig,  \\n and accessing that base URL property directly.  \\n If we go ahead and print this out  \\n we'll see that fake base URL printed out to the console.  \\n Now, our object classes may define methods  \\n and implement interfaces just like any other class.  \\n So let's go back to our project directory  \\n and we're going to create a new interface here  \\n and we're going to call this interface NetworkInfoProvider.  \\n A network info provider is going to have  \\n a single method called getNetworkDetails  \\n which just returns a string.  \\n So now we have this NetworkInfoProvider interface,  \\n our NetworkConfig object declaration  \\n could implement that interface and the associated method,  \\n to implement the interface  \\n it's just the same as with any other class.  \\n We'll come to the object declaration here  \\n and after the name of that object, we will add a colon,  \\n and then the name of the interface we want to implement  \\n and then just like any other class as well,  \\n we can override that method  \\n and in this case, getNetworkDetails will return  \\n a string that can concatenates our base URL  \\n with a separator and the userAgent.  \\n Once we finished implementing that method, we can come back  \\n to main and we're now free to access that method  \\n and call it on our NetworkConfig singleton.  \\n So here we will print out the result  \\n of calling getNetworkDetails  \\n and there as the second output we see the base URL,  \\n our separator and the userAgent printed out to the console.  \\n Now, it's also possible to create anonymous object  \\n declarations using what's called an object expression.  \\n These are analogous to anonymous inner classes in Java.  \\n So these are perfect for situations  \\n where you might just need a one off  \\n implementation of a particular interface or object.  \\n So say we wanted to create a one off  \\n instance of NetworkInfoProvider.  \\n We could define a variable called provider  \\n of type NetworkInfoProvider, and then we could assign it  \\n in object expression here, to define an object expression  \\n we start with the object keyword, a colon,  \\n and then the type that we want that object  \\n to implement or extend.  \\n So in this case, we're basically saying  \\n create an anonymous object  \\n that implements NetworkInfoProvider  \\n and then we can add a class body here  \\n or in this case, an interface body  \\n and we can override that getNetworkDetails method.  \\n So this object expression that we've just created  \\n will result in an object that will only be active  \\n during the life cycle of the provider variable.  \\n So in this case, that provider variable is only active  \\n and alive during the invocation of the main function.  \\n But during that time we can access all  \\n of the properties and methods of that type.  \\n So with that provider variable  \\n we could call network details.  \\n Now, in this case we haven't implemented network details,  \\n if we tried to run this we would actually  \\n get an exception thrown when we hit the to-do there.  \\n But if we needed to, we could override that  \\n for whatever custom behavior we wanted.  \\n The ability to create concise, thread safe singletons  \\n is incredibly convenient and demonstrates Kotlin's focus  \\n on developer productivity and readable code.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3082341\",\"duration\":702,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Sealed classes\",\"fileName\":\"2497307_en_US_01_06_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to define a sealed hierarchy of data types that all may contain unique values. These are incredibly helpful for modeling complex types such as UI states or user actions.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":20064252,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Much like enum classes,  \\n sealed classes allow us to define  \\n restricted class hierarchies.  \\n However, unlike enum classes each subtype  \\n in the hierarchy may include unique properties  \\n making them more flexible and perfect  \\n for modeling things like uistates or operation results.  \\n So we're going to create our first sealed class here  \\n in IntelliJ by going to source, main, Kotlin,  \\n right clicking, navigating to new Kotlin class or file.  \\n And then from this option, we'll select sealed class  \\n and we are going to name that sealed class  \\n uistate and then hit enter.  \\n So we will imagine that we're going  \\n to use this uistate sealed class to represent uistates  \\n in let's say a mobile application or web application.  \\n If this was an enum, each type in the enum would have  \\n to have the same properties  \\n but that doesn't work well for complex states.  \\n For example, in our uistate here  \\n we might want to have a loading state  \\n and that loading state might not have any properties at all.  \\n And we might want then a loaded state that represents  \\n exactly the data that we should be drawing to the screen.  \\n And finally, we might want some type of errored state  \\n to indicate that something went wrong in this process  \\n and that we should show some type of fallback.  \\n So if this was an enum, each of these loading,  \\n loaded and error states would have to have the same values  \\n but that's just not how we really want to model our data.  \\n With a sealed class however, we can use a combination  \\n of classes, data classes or object classes  \\n to model each unique state in whatever manner  \\n makes the most sense.  \\n For example, for our loading state  \\n we could use an object declaration  \\n to define a singleton loading value  \\n that takes no properties.  \\n We need to then be sure to extend  \\n the base sealed class type or our loading value here  \\n wouldn't be considered part of the sealed hierarchy.  \\n We could then use a data class for our loaded state.  \\n Now data classes have to have at least one  \\n constructor property, so we could add a title  \\n of type string and a subtitle of type string.  \\n And again, we're going to want to make sure  \\n that we extend the base  \\n uistate type so that loaded is recognized  \\n as part of our uistate hierarchy.  \\n And finally, for our error state, we will define this  \\n as a basic class called error  \\n that takes in some error throwable.  \\n So now we have our uistate type here  \\n and it has three possible values.  \\n So now back here in main.kt,  \\n we could create a mutable variable called state  \\n that is set up to hold an instance of a uistate.  \\n And we might initially set that to uistate.loading,  \\n now notice here, we don't have to instantiate  \\n an instance of loading because as we remember  \\n loading was defined as an object declaration,  \\n so it will be initialized once upon first access.  \\n Now, after we're in the loading state  \\n we might eventually enter the loaded state.  \\n So we could reassign our variable  \\n to an instance of uistate.loaded.  \\n And we might need to then provide each parameter value here  \\n so we could say Kotlin for the title  \\n and is cool for the subtitle.  \\n And lastly, we could assign an instance  \\n of uistate.error as well  \\n and we could pass it an instance of sum throwable  \\n so maybe we caught an error when making our network request  \\n we could forward it on to the error class here.  \\n So in this case, I will just create a new instance  \\n of illegal state exception and that'll be forwarded  \\n on to our uistate.error instance.  \\n So like with an enum, we have this restricted set of values  \\n either loading, loaded or error, but unlike an enum  \\n we can provide different values here or no values at all,  \\n we have the freedom to model and express our data  \\n in whatever way makes the most sense.  \\n Now, because we've defined all possible value types  \\n in our sealed class, the compiler knows that as well  \\n and the compiler can help us enforce that we handle  \\n each possible value in certain situations.  \\n We've got our uistate, let's imagine that we're now going  \\n to write a render function to actually render that state  \\n to the screen.  \\n So we can simulate this by writing a new function  \\n called render and render will take in an instance  \\n of uistate  \\n and return unit.  \\n Within our render function,  \\n we want to make sure that we handle each possible value  \\n from that uistate hierarchy.  \\n To do this, we're going to leverage a when statement,  \\n so we'll type when, and we will pass our state parameter  \\n to that when statement.  \\n If we use a when statement with a sealed class  \\n the compiler can recognize which types are  \\n in the sealed class and the IDE can generate branches  \\n for each of those possibilities.  \\n So I'm going to move my cursor over the when keyword here  \\n and hit alt + enter and it'll give me an option here  \\n to add remaining branches.  \\n So if I hit enter, we'll see that the IDE generates  \\n three branches here, one for each value  \\n in our sealed glass hierarchy.  \\n Now, the fact that the IDE can help us generate  \\n each of these state branches  \\n in our when statement here is really helpful.  \\n However, we have to remember to go in there  \\n and add each of those conditions.  \\n It would be nice if we didn't have to remember that,  \\n it would be nice if the compiler could help enforce  \\n that for us, and as it turns out, it can.  \\n So let's just remove what we added there  \\n and instead, we're going to define a render  \\n as a single expression function.  \\n So we will say equals and then we were going  \\n to use when as an expression here instead of as a statement.  \\n So I'll still pass in state to our when.  \\n Now however, we have this little error highlighted  \\n over the when, it says when expression must be exhaustive.  \\n So what this is indicating to us is that if using when  \\n as an expression in conjunction with a sealed class  \\n or even an enum class, we have to exhaustively  \\n handle every branch of that hierarchy.  \\n So if I move my cursor back onto the when, hit alt + enter  \\n I could add an else branch here and  \\n that error would go away.  \\n And so in this case, because we just have an else  \\n this will effectively be the only thing that's handled,  \\n this will be the fallback value,  \\n every time we called render, we would do whatever  \\n is defined in this else block.  \\n However, if we removed the else,  \\n the other option is to generate all remaining branches.  \\n Now, if we do this, each branch will then  \\n be handled for us, this helps us enforce that  \\n we're going to handle each one of our values  \\n from the uistate sealed class.  \\n Now again, we now have a compiler warning here  \\n on the render function itself, it's indicating  \\n that a nothing return type needs to be specified explicitly  \\n this will go away in just a moment once we implement  \\n the branches here in our when expression.  \\n So now let's actually define some behavior here.  \\n So for the error case, we are going to simply print  \\n out the string error, and notice as soon as we do this  \\n that warning went away on the render function.  \\n For the loading state, we will also print out  \\n just a string saying loading.  \\n Now, for the loaded state however,  \\n we want to print out a little bit more information,  \\n we want to actually print out the title of the uistate  \\n passed to us.  \\n If we're using when as a statement  \\n or an expression in this case, smart casting will kick in  \\n and automatically cast the state parameter  \\n to an instance of uistate.loaded.  \\n This means we can directly access the unique properties  \\n of each of our sealed class subtypes  \\n once smart casting kicks in.  \\n So in the case of the loaded state here  \\n we could print out loaded, colon  \\n and then we could use a string template here  \\n to substitute in the value of state.title.  \\n We can access state.title  \\n because state has already been casted  \\n to an instance of uistate.loaded.  \\n So now, if we come back down to our main function  \\n and we call render on each of our unique types here,  \\n we'll see the different outputs printed to the console.  \\n So we'll call render once here when state is loading,  \\n we will call it a second time  \\n after we set it to a loaded value.  \\n And finally, we will render once again  \\n when we have the error state.  \\n And if we run our code, we will see loading,  \\n we will see loaded with the title of Kotlin  \\n and we will see error printed out.  \\n So our render function when invoked  \\n is using the when expression to correctly  \\n check the type of each uistate passed to it  \\n and print out the custom error message.  \\n The ability to create these sealed types  \\n with unique properties gives us a tremendous amount  \\n of flexibility when modeling states in our application.  \\n Imagine your own projects, can you think  \\n of any areas where sealed classes might be useful?  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3086280\",\"duration\":405,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Companion objects\",\"fileName\":\"2497307_en_US_01_07_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn what a companion object is and how to define one. Companion objects play an important role in organizing code and interloping with Java.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":11473442,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Kotlin does not have a static keyword,  \\n instead relying on things like top level  \\n and extension functions to achieve similar semantics.  \\n However, sometimes it's still useful to be able  \\n to scope properties or methods to a particular type.  \\n Companion objects provide a mechanism  \\n for mimicking the semantics of static in Java  \\n and can be a useful tool  \\n for code organization or interoperability with Java.  \\n Fundamentally, a companion object is an object declaration  \\n within a class.  \\n So, we are going to create a new class  \\n called SearchController  \\n and within that SearchController class  \\n we are going to have a private mutable variable  \\n called query that holds a current search query string.  \\n Now, what if we wanted to create some kind of factory method  \\n for creating a new instance of SearchController,  \\n we could just create a top level function,  \\n but then that function might have to be public or internal,  \\n possibly polluting the global name space.  \\n As an alternative, we could add a companion object  \\n to our SearchController class, to add a companion object  \\n we need to come within the class body  \\n and then we will use the companion keyword  \\n followed by object, followed by a class body.  \\n Within that companion object  \\n we can then add a create method that will take  \\n in a single parameter called initialQuery of type string  \\n and it will return an instance of SearchController.  \\n Within that create method we'll create a variable called  \\n controller to hold onto an instance of SearchController  \\n and then we will set controller.query  \\n equal to the initialQuery, there we go.  \\n And finally, we will return the controller.  \\n Now, a couple of things are interesting about this.  \\n One of which is that our SearchController class does not  \\n have a public constructor that allows  \\n for any parameters to be passed and if the query property  \\n is private, however, within this companion object  \\n that is within SearchController  \\n we have access to that query property.  \\n So we can create an instance of SearchController  \\n and then set that initialQuery using the value passed  \\n to that create method.  \\n This is one of the benefits of a companion object.  \\n Companion objects have access  \\n to private properties and methods of the enclosing class.  \\n Once we have our companion object,  \\n we can reference its properties and methods  \\n by referencing the enclosing class name.  \\n So if we come back to our main function here,  \\n we'll create a variable named controller  \\n and we will set it equal to SearchController.create  \\n and we'll pass in an initial query of Kotlin.  \\n So what we've done here is reference  \\n that commanding object by using the name  \\n of the enclosing class, in this case SearchController  \\n and then the name of the method on that companion object.  \\n Another more verbose way  \\n of referencing the companion object  \\n would be to actually explicitly name it using Companion  \\n and then dot create, however from Kotlin  \\n we don't need to do this.  \\n We can simply remove that companion naming.  \\n If we were calling this from Java  \\n we would have to explicitly reference  \\n that companion instance.  \\n Now, let's add a property to our companion object.  \\n So we will come back over to SearchController  \\n and to add a property to the companion object,  \\n we will declare it like we would a property  \\n in any other class.  \\n So we might want to define, let's say a constant  \\n for the maximum number of search results.  \\n In this case, we'll make it private,  \\n we'll use the const keyword here,  \\n this will help make it defined  \\n as a true static by the compiler  \\n which will be a little bit more memory efficient.  \\n Then we'll use val to indicate this will be  \\n a read only property, and then we will name it MAX_RESULTS  \\n and assign it to 20,  \\n this property, even though it's private  \\n may still be accessed from anywhere  \\n within the SearchController class,  \\n if it was made public it could be accessed externally,  \\n again by referencing a class name.  \\n So I'll just remove private, go back to main KT here,  \\n and we could reference  \\n SearchController.MAX_RESULTS directly.  \\n If we remove that,  \\n we'll come back to SearchController here,  \\n we will make it private once again  \\n and just to demonstrate, we could create an init block  \\n within SearchController and from within here  \\n we could reference SearchController.MAX_RESULTS  \\n or even more concisely  \\n because we are within the SearchController class,  \\n we don't even need to prefix it  \\n with the name of the enclosing class,  \\n we could just reference MAX_RESULTS directly.  \\n Companion objects are most useful  \\n in organizing methods and properties  \\n so they are only accessible  \\n by first referencing an enclosing class name,  \\n when deciding between a companion object  \\n or a top level property or function,  \\n consider whether or not the function  \\n should be globally available or whether it makes more sense  \\n within the context of another explicit class.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3085328\",\"duration\":105,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Challenge: Create a Result type using a sealed class\",\"fileName\":\"2497307_en_US_01_08_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, explore a common example of defining a closed set of typed result values.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":3636235,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" (upbeat music)  \\n - [Nate] Let's work through another challenge,  \\n this time to reinforce the concept of modeling data  \\n with sealed classes.  \\n In this challenge your task is to create a sealed class  \\n named StringResult.  \\n Imagine that you would use this class  \\n when fetching a string from the network  \\n or from a database.  \\n Rather than returning a raw string  \\n we could use StringResult  \\n so that failures are strongly typed  \\n as opposed to using null or an empty string  \\n to represent the failure case.  \\n StringResult should have two possible states:  \\n Success and Error.  \\n The Success state should have a public String property  \\n and the Error state should have a public Throwable property.  \\n To help test your StringResult sealed class  \\n we have some starter code.  \\n This function getRandomString will simulate  \\n fetching a string from, let's say, a network.  \\n Sometimes it will succeed  \\n and sometimes it will throw an exception.  \\n Use the getRandomString function  \\n to write another function named getString  \\n that calls getRandomString  \\n and wraps that result into an instance of StringResult.  \\n Calling getString should never crash  \\n but instead should wrap any failures  \\n into an instance of StringResult.Error.  \\n To help get you started,  \\n we've already given a StringResult.kt file  \\n that outlines the details,  \\n so use this file to define your StringResult sealed class.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3085329\",\"duration\":373,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Solution: Create a Result type using a sealed class\",\"fileName\":\"2497307_en_US_01_09_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, see a demonstration of an example Result type implementation using a sealed class.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":12794984,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" (upbeat electronic music)  \\n - [Instructor] Let's take a look  \\n at one way we could solve this challenge.  \\n The first step towards a working solution  \\n is to create the string result sealed class.  \\n So here within the string result KT file,  \\n I'm going to go ahead  \\n and define a sealed class named StringResult.  \\n With that in place, we can move on  \\n to defining the success and error types.  \\n Because success and error states  \\n both will contain properties,  \\n we'll use data classes to represent them both.  \\n So to start, we will define a new data class for success.  \\n And that class will have a single property  \\n called value of type string.  \\n And then we will make sure  \\n that success extends StringResult  \\n so that it is recognized as part of that sealed hierarchy.  \\n And next, we'll create our error type in much the same way.  \\n So we will define data, class, error.  \\n This time, instead of a value string,  \\n we will have an error property representing a throwable.  \\n And again, we will extend StringResult.  \\n This error property will help us represent  \\n any error that might occur when fetching a string,  \\n maybe a network request or a database failure,  \\n anything like that.  \\n Now that we have our string result types set up,  \\n we can move on to implementing the get string function.  \\n So we will move over to main KT here,  \\n and I will stub out a get string function.  \\n So I know we want it to be called getString  \\n and we know that we want it to return a string result.  \\n We also know that we want to use  \\n the provided get random string function  \\n to simulate making some type of request for the string.  \\n So we'll go ahead and write in getRandomString here,  \\n even if we're not really doing anything with it yet.  \\n If we take a closer look  \\n at the implementation of getRandomString,  \\n we'll see that there is a 50/50 possibility of that function  \\n throwing an illegal state exception.  \\n So rather than calling getRandomString directly,  \\n which might lead to a runtime exception being thrown,  \\n we're actually going to wrap our call to getRandomString  \\n in a try catch.  \\n So within the try block, we will call getRandomString,  \\n and within the catch block,  \\n we will catch any illegal state exceptions  \\n that might be thrown.  \\n Now, we're set up to convert both the success case  \\n and the error case into instances of StringResult.  \\n So for the success case,  \\n we will wrap the result of getRandomString  \\n in an instance of StringResult.Success.  \\n And within the catch block,  \\n we can use the caught exception  \\n to create an instance of StringResult.Error.  \\n And now just the last thing that we'll do  \\n is return the result of this try catch,  \\n and now our get string function should be ready to test out.  \\n So we'll come back up into main  \\n and we'll write a little bit of test code here  \\n to help us validate that getString is working as expected.  \\n So we're going to use a when statement here  \\n and within that when, we'll define a result variable  \\n and assign it the value of calling getString.  \\n Now, because that getString result  \\n is going to be an instance of StringResult,  \\n we can generate the sealed class branches.  \\n So in this case, we can make sure that we handle  \\n both the error and the success cases.  \\n So in the case of error,  \\n we will print out, there was an error.  \\n And in the success case,  \\n we will print out result.value.  \\n So any instance of StringResult.Error  \\n will print out the error message  \\n and any instance of StringResult.Success  \\n will print out the actual value  \\n that was generated by getRandomString.  \\n So now if we run this code a few times,  \\n we should be able to see instances of both results.  \\n So in this case, we see one printed out  \\n which means that getRandomString did in fact  \\n return us a string value.  \\n If we run it again, we see zero.  \\n So again, another success.  \\n And here we have output, there was an error.  \\n So we've seen now cases of both the success case  \\n and the error case being successfully handled.  \\n And more importantly,  \\n we've seen no crashes in our code,  \\n even though we know that getRandomString  \\n sometimes throws an exception.  \\n This challenge represents  \\n the very common real world use case of modeling  \\n both success and error states.  \\n Not all scenarios will have the same exact states  \\n or be implemented quite the same way  \\n but the concepts have wide applications,  \\n regardless of what you're building.  \\n \\n\\n\"}],\"name\":\"1. Object-Oriented Programming with Kotlin\",\"size\":164837096,\"urn\":\"urn:li:learningContentChapter:3085333\"},{\"duration\":2392,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:3083325\",\"duration\":492,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Top-level properties and functions\",\"fileName\":\"2497307_en_US_02_01_XR30\",\"demo\":true,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to define properties and functions without an enclosing class. This represents a key difference between Java and Kotlin and is essential to writing idiomatic Kotlin.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":12804046,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Let's talk code organization in Kotlin.  \\n More specifically, we're going to explore options  \\n for organizing our top-level properties and functions  \\n in a scalable way.  \\n Now, to quickly review,  \\n top-level properties and top-level functions  \\n refer to any property or function that is defined  \\n outside of any enclosing class.  \\n Now, throughout this course  \\n we've been using examples of both of these extensively.  \\n So, if we imagine a variable like this  \\n we might name it DEFAULT_CLICK_DELAY.  \\n This is an example of a top-level property.  \\n Or if we define a function like this  \\n where it's standalone within some Kotlin file,  \\n so maybe we'll name this log.  \\n So, this would be an example then of a top-level function.  \\n So, anytime that we create a standalone variable  \\n or a function in a Kotlin file  \\n and it's not within some other class  \\n you've created a top-level element.  \\n The use of top-level elements  \\n is a standard practice in Kotlin,  \\n but we should still use them pragmatically.  \\n Now, let's imagine that we have a file called TimeUtils.kt.  \\n So, I'm just going to create that file real quick here,  \\n TimeUtils.kt, there we go.  \\n Now, within TimeUtils here  \\n we want to define some constants and functions  \\n for working with time in our application.  \\n To start we're going to define a top-level property here  \\n called hourInMillis and set it equal to 60 minutes  \\n times 60 seconds times 1,000.  \\n This is a completely valid top-level property.  \\n We know that it has to do with time,  \\n so we've organized it into a file called TimeUtils.  \\n But there's still potentially an issue  \\n with the way this property is written and organized.  \\n Do you have any guesses as to what that issue might be?  \\n Well, if we come back over to Main.kt we can explore this.  \\n The potential problem here is that this property  \\n we've just defined within TimeUtils is public,  \\n and because it's public and because it's not scoped  \\n to any enclosing class that means it's available globally  \\n throughout our entire application.  \\n So, we could access that quite simply  \\n by referencing that name directly.  \\n Now, while this can be very convenient,  \\n especially in a small application, this can be problematic.  \\n Global variables are easy to misuse.  \\n They can be used for unrelated things,  \\n they can make it difficult to find other variables  \\n and functions as they pollute the global namespace,  \\n and they inherently break any kind of encapsulation  \\n we might have hoped for if we intended  \\n the top-level property to only be used  \\n within some given file or class.  \\n So, when we use top-level elements  \\n we should be mindful about the visibility applied  \\n to the property or function.  \\n If we return back to TimeUtils,  \\n in this case if we imagine we only wanted  \\n our hourInMillis property to be available  \\n within this TimeUtils file  \\n we could mark that property as private.  \\n Once we've made it private  \\n we'll see that we can no longer access that value  \\n outside of the file.  \\n So, in our Main.kt function here  \\n we now have an error indicating that hourInMillis  \\n is private within its file.  \\n Now, the same concept applies  \\n for top-level functions as well.  \\n So, again, we'll return back to TimeUtils here,  \\n and now let's imagine we're going to create  \\n some utility function here.  \\n So, we will name that millisForHours.  \\n It will take in an integer number of hours,  \\n and it will return that integer times  \\n our hourInMillis constant value.  \\n So, again, because this function is public  \\n we can call this from within Main without any issue.  \\n MillisForHours we could pass in a value of five here,  \\n and this will compile with no problem.  \\n Again, if we wanted to then make that function private  \\n only within the TimeUtils file we could do that.  \\n And again, we will now see the error in Main.kt indicating  \\n that the millisForHours function is private.  \\n Now, we've looked at public visibility  \\n and private visibility.  \\n However, there's also a middle ground  \\n that can be useful in certain situations,  \\n and that is internal.  \\n The internal modifier makes a property, function,  \\n or a class accessible within a given module,  \\n but not to the entire project.  \\n So, if we come back to TimeUtils  \\n and we replace the private with internal,  \\n now back in Main.kt we see that this Main.kt file has access  \\n to that millisForHours function.  \\n However, other modules, if this was a multi-module project,  \\n for example, they would not have access to this.  \\n Now, within the context of Kotlin  \\n and these visibility modifiers, a module essentially means  \\n a set of Kotlin files compiled together.  \\n Most basic projects that you might generate by default  \\n in IntelliJ are going to be single module,  \\n but as codebases scale it's quite common to split code  \\n into separate reusable modules,  \\n especially if using a build system like Gradle  \\n which is quite common with Kotlin projects.  \\n So, in these situations adding the internal modifier  \\n can be a good way to make constants and functions available  \\n to the specialized module, but not to the entire codebase.  \\n So, we'll return to TimeUtils here,  \\n and we'll just make that change to our  \\n hourInMillis value as well just to demonstrate  \\n that it works for properties in addition to functions.  \\n However, if we were going to be writing this  \\n in a production codebase we probably would want  \\n to keep that constant private.  \\n So, we'll remove it from our Main.kt file,  \\n and we'll add it back here.  \\n So, the idea here is that we have  \\n the constant private within the file,  \\n but the utility function is available more widely.  \\n So, now we've kind of encapsulated  \\n that constant within this file  \\n while still making the useful function available  \\n to more of our codebase.  \\n Understanding the different visibility modifiers  \\n is important when writing Idiomatic Kotlin  \\n with top-level properties and functions.  \\n As you write Kotlin code think carefully  \\n about how much of your application  \\n should be able to access the code.  \\n Is your property truly global?  \\n Then public might be the way to go.  \\n Should your function only be accessible  \\n within a file or within a class?  \\n Then you might consider making it private or protected.  \\n And if you're working in a multi-module project  \\n you'll find yourself using internal  \\n on many of your functions, classes, and properties.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3080454\",\"duration\":702,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Extension properties and functions\",\"fileName\":\"2497307_en_US_02_02_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn to extend types with extension properties and extension functions. This is a powerful tool for writing clean APIs and for working with external data types.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":19503756,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Extension functions and extension properties  \\n are two of the most powerful features of Kotlin.  \\n They allow developers to extend types they don't own,  \\n making it easier to adapt types and APIs  \\n to fit your specific use cases.  \\n Extension functions are defined outside a given type  \\n but may be called as if it exists on that type.  \\n For example, let's revisit  \\n our earlier function, millisForHours,  \\n which converts an integer input,  \\n representing a number of hours,  \\n into the equivalent number of milliseconds.  \\n If we go to Main.kt here,  \\n we can invoke this by always passing an integer value to it.  \\n But what if we call that function on the integer  \\n rather than passing the integer?  \\n This is something we can accomplish  \\n by adding an extension function.  \\n So we'll return to TimeUtils.kt,  \\n and to define an extension function,  \\n we will start like any other function,  \\n by using the fun keyword.  \\n Then, rather than defining the function name,  \\n we will specify the type that we want to extend,  \\n followed by a period and then the name of the function.  \\n So in this case, we want to extend the Int type  \\n and then we will go ahead  \\n and give this the same function name of millisForHours.  \\n You might notice that this syntax  \\n actually looks quite like a method invocation.  \\n Now we need to finish implementing our function.  \\n We need to multiply the integer  \\n by our hourInMillis constant.  \\n But how do we do that  \\n if the integer is no longer passed  \\n as an argument to the function?  \\n Well as it turns out, we still have access to the integer  \\n in the form of a receiver.  \\n A receiver is a value made implicitly available  \\n within our function.  \\n Essentially it means we don't need  \\n to explicitly reference the Int parameter  \\n because the function is being called on the Int itself.  \\n And we can access the Int by referencing this.  \\n So we can complete the body of our function here  \\n by referencing this, which will refer to the Int  \\n that the function's being called on, times hourInMillis.  \\n Now if we notice here,  \\n now that we've finished our implementation,  \\n we have an error here, basically saying  \\n that both of these functions have the same signature.  \\n So we are just going to comment out the first one for now.  \\n Now, if we return to Main.kt,  \\n we will see that both of our previous invocations  \\n of the old function are giving us a compiler error now  \\n which is no surprise since we commented it out.  \\n So let's go ahead and comment these as well.  \\n And now we will replace them  \\n with our new extension function.  \\n So instead of calling the function name  \\n and passing the integer into them,  \\n so this time we will type  \\n the integer of four representing our hours, period,  \\n and then type the name of the function, millisForHours.  \\n And similarly, we could do the same thing for 10 hours here.  \\n So even though that millisForHours function  \\n doesn't actually exist on the Int type,  \\n we can call it as if it does.  \\n Extension functions like this are quite prominent  \\n in the Kotlin standard library.  \\n For example, we can easily convert any string  \\n into a regular expression.  \\n So I'll create a basic regular expression here  \\n that will simply match  \\n any number of the characters, A, B, or C.  \\n And now I can turn that into a regular expression instance  \\n by typing toRegex.  \\n Now, if we click into Regex here  \\n to look at its implementation,  \\n we can see that it is in fact defined  \\n as a extension function on the string type.  \\n And it then wraps that string that the method is called on  \\n and uses it to create a new instance of the Regex type.  \\n Now, extension functions like this  \\n don't actually insert new methods into the extended class.  \\n The compiler essentially generates code for us  \\n that passes the receiver type  \\n as the first argument of a function,  \\n but allows us to call the function on the receiver itself.  \\n So in our Regex example here,  \\n we're not inserting this toRegex function  \\n into the string type,  \\n but instead, the compiler is generating a version of toRegex  \\n that actually takes in the string.  \\n But it provides some compiler magic for us  \\n and some syntactic sugar  \\n so that we can call it in this more fluent way,  \\n which looks like the method does exist on the string type.  \\n Now we're not limited to extension functions either.  \\n We can write extension properties as well.  \\n The syntax is quite similar.  \\n So if we wanted to write an extension of property  \\n on the Int integer, we could start by writing val.  \\n And then again, we will reference the type we want to extend,  \\n in this case, Int.  \\n And now let's say we want to add in isEven property  \\n to an integer.  \\n So we could name that isEven  \\n and specify that it should be a Boolean type here.  \\n Now just like methods don't insert code  \\n into the actual type,  \\n extension properties also can't insert member variables  \\n into the extended class.  \\n So there's no efficient way to store the value  \\n in a backing field of any kind.  \\n So to provide the property value,  \\n in this case, we must add a custom getter to our property.  \\n Now we could do this in a number of ways.  \\n In my case here, I'm going to hit enter  \\n and then type get with empty parenthesis, =,  \\n and we'll say this.mod 2 ==0.  \\n The mod function here means modulous,  \\n so this is going to tell us what the remainder would be  \\n if we divided the Int receiver by two.  \\n And if the remainder is zero,  \\n that means that the property is even.  \\n And let me just fix this typo here,  \\n instead of is event, it should say isEven.  \\n So now that we have our extension property,  \\n I could type the value eight here, .isEven  \\n or 7.isEven.  \\n And if we wanted to, we could print both of these out  \\n just to verify that they show what we expect here.  \\n And sure enough, we see eight is true, seven is false.  \\n So each time that isEven property is accessed,  \\n this custom getter  \\n is actually going to be run behind the scenes  \\n and return a value to us.  \\n Extension functions and properties  \\n follow the same visibility rules as any other functions.  \\n So, if you have a common set of extensions,  \\n you could make them public or internal  \\n so they can be used by a large portion of your code base.  \\n Or if you want to write a highly specific extension  \\n for a one off use case,  \\n you might make it private to that class or file.  \\n Sometimes we may want to write an extension  \\n that applies to any type  \\n or to any type extending another base class.  \\n In cases like this, we can write extension functions  \\n or properties using generics  \\n that can be reused in more places in our code.  \\n To demonstrate this, let's create a new file,  \\n and we'll just name this file logging.  \\n And now within this file,  \\n let's say we want to write a log function  \\n that we could call on an object of any type.  \\n So as usual, we'll start by adding the fun keyword.  \\n Now we need to set up our generic  \\n and we'll do this by adding angle brackets  \\n with an identifier inside of the angle brackets.  \\n That identifier, in this case we're going to use T,  \\n represents sort of the generic type we want to use.  \\n I like to think of T in this case, representing type,  \\n but we can use whatever letter we wanted here.  \\n Now, we've defined that this function is going to operate  \\n with some generic type T.  \\n Now we can define  \\n the rest of our extension function signature.  \\n So rather than extending an explicit type  \\n like string or Int,  \\n we're going to extend the generic type T,  \\n and we're going to name this function log  \\n and it will print out the receiver object.  \\n So effectively, we've just defined a function  \\n that we can call on any object  \\n and that object will be printed out to the console.  \\n And because this function is public,  \\n we can now use it on any type in our project  \\n from any place in our project.  \\n So we'll come back to Main.kt here,  \\n and just comment out the last two examples.  \\n And now, we're going to demonstrate  \\n how we can use our new log function on any type.  \\n So we could type 5.log here, and that'll work  \\n because our generic in this sense  \\n will be inferred to be an Int.  \\n We could do a sample string here, .log,  \\n or we could even do something like listOf(1, 2, 3).log.  \\n And if we run this code,  \\n we will see all three of our values printed out.  \\n In the case of the integer,  \\n we simply see the integer printed out to the console.  \\n For the string, likewise, we see the string printed out  \\n and for the list, we actually see  \\n the full list representation  \\n with all the values in that collection printed out.  \\n Extension functions and properties  \\n are an essential part of Kotlin.  \\n They have the potential to transform  \\n how we write and organize our code.  \\n By leveraging extensions,  \\n we can start to remove those helper or utils classes  \\n that are commonly found in code bases.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3085330\",\"duration\":802,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Delegates\",\"fileName\":\"2497307_en_US_02_03_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to use property delegates. Delegates are a powerful tool for writing safer, scalable code.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":24543725,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Delegation  \\n is an object-oriented design pattern  \\n that leverages object composition  \\n to achieve the same code reuse as inheritance,  \\n but in a more flexible way.  \\n Kotlin supports delegation in two primary ways  \\n through interface delegation and property delegates.  \\n Interface delegation allows us to delegate  \\n the implementation of an interface  \\n to some other object implementing that interface.  \\n Let's define a Logger interface to demonstrate this.  \\n So I'm going to create a new Kotlin file.  \\n I'm going to select Interface.  \\n I'm going to name that interface Logger.  \\n Now within Logger,  \\n we will add a log method that takes in a tag  \\n and takes in any as an additional parameter.  \\n Now we'll define a concrete implementation  \\n of that Logger interface,  \\n and we'll name that SimpleLogger.  \\n So we'll come to New Kotlin File or Class,  \\n select Class and name that SimpleLogger.  \\n SimpleLogger will then implement Logger.  \\n Now we'll need to override that log method,  \\n and we'll do so using a basic println  \\n where we will print out the tag,  \\n followed by a colon.  \\n And then we'll call two string on that any parameter.  \\n So calling log here will give us some tag for an identifier  \\n and give us a string representation of whatever other object  \\n was passed into the log function here.  \\n So while SimpleLogger is pretty straightforward,  \\n just printing out to the console,  \\n it does fully implement Logger.  \\n so we can use it as a delegate for other classes  \\n needing to implement that Logger interface.  \\n So let's come back  \\n and once again, create a new class here.  \\n And this time, we're going to call this class  \\n ApplicationLogger.  \\n ApplicationLogger will take no parameters to start  \\n within its construction,  \\n but it will implement Logger.  \\n And at the moment, we see some compiler errors,  \\n because we haven't yet finished implementing Logger.  \\n However, rather than implement  \\n the Logger interface directly,  \\n we're going to delegate that implementation  \\n to some other instance of a Logger.  \\n To do this,  \\n we are going to add a parameter to our constructor.  \\n So we'll define this as a private val,  \\n and we'll name it delegate.  \\n And it will be of type Logger.  \\n Now we can use the delegate property  \\n as our delegate for the Logger interface.  \\n And we can do this  \\n by coming to the end of our class declaration here,  \\n right after we've specified Logger  \\n as an interface to implement,  \\n and we can say by and delegate.  \\n By doing this,  \\n the compiler will take care of routing calls  \\n to ApplicationLogger dot log  \\n and passing those on to delegate dot log.  \\n If we come to our main function here,  \\n we could create an instance of ApplicationLogger.  \\n We'll call it appLogger.  \\n And we will pass in an instance of SimpleLogger.  \\n And now if we call appLogger dot log,  \\n we'll pass in a tag of example,  \\n and maybe we'll just pass in the appLogger itself  \\n as the extra parameter.  \\n If we run this code,  \\n we will see that we have our output with the tag  \\n and the string representation  \\n of the extra parameter that was passed into it,  \\n in this case, appLogger.  \\n So by passing in that instance of SimpleLogger  \\n as the delegate property of ApplicationLogger,  \\n we were able to forward all calls  \\n to ApplicationLogger dot log over to SimpleLogger dot log.  \\n This approach is quite powerful  \\n when composing behaviors from multiple interfaces.  \\n We can even delegate multiple interfaces on a single type.  \\n Now, in addition to interface delegation,  \\n Kotlin supports delegation of properties as well.  \\n We can define our own custom property delegates  \\n for specific use cases we might have.  \\n But Kotlin also includes several built-in property delegates  \\n for common scenarios.  \\n The lazy delegate allows us to defer  \\n initialization of a property  \\n until the time it's first accessed.  \\n So let's demonstrate this.  \\n Let's imagine that we have a ViewModel class.  \\n So we'll just create that class quickly here.  \\n And we will name it ViewModel.  \\n And let's say that we want ViewModel  \\n to have a Logger property,  \\n so we can log interactions within the ViewModel.  \\n So within the class body here,  \\n we will define a Logger property of type Logger.  \\n And now notice the compiler is giving us an error here  \\n telling us that we need to initialize this property  \\n or make it abstract.  \\n So we're going to look to initialize this  \\n by using the lazy delegate.  \\n Now, to define Logger as a read-only property,  \\n we have to initialize it.  \\n That's what the compiler error is telling us here.  \\n But sometimes, objects are expensive to initialize,  \\n because they might take up a lot of memory, CPU,  \\n maybe even both.  \\n For cases like this,  \\n we might want to avoid creating the object  \\n unless it's actually needed.  \\n However, that creates kind of a chicken and the egg problem.  \\n If we want it to be a read-only property,  \\n we have to initialize it.  \\n But we might not want to initialize it  \\n unless we absolutely need it.  \\n So in cases like this,  \\n to defer the instantiation of our property  \\n until it's first use,  \\n we can use the lazy delegate.  \\n To apply this lazy delegate,  \\n we come to our property declaration here.  \\n And after the type, we add by lazy.  \\n So in this case,  \\n lazy takes a Lambda.  \\n And within that Lambda,  \\n we can then define the code to run  \\n when initializing the Logger.  \\n So just to demonstrate this,  \\n we will add a print statement here  \\n that just says something like initializing the Logger.  \\n And then we will create a new instance of ApplicationLogger.  \\n So whenever ViewModel dot Logger  \\n is accessed for the first time,  \\n this Lambda will run,  \\n and a new instance of ApplicationLogger will be created.  \\n Now, to finish rounding out our ViewModel here,  \\n we're going to create a method called search.  \\n And search will take in a query of type string.  \\n And within that method,  \\n we will use that Logger  \\n to log out whatever the query is being passed in.  \\n Now let's test this all out.  \\n Let's come back to our main function here.  \\n We'll comment out the previous example.  \\n And now we're going to create a new instance of our ViewModel.  \\n If we run our code at this point,  \\n we shouldn't see any type of output  \\n indicating that our Logger has been created,  \\n because the Logger property hasn't been accessed yet.  \\n However, if we use the search method  \\n to say search for Kotlin here,  \\n and we rerun our code,  \\n this time, we see initializing the logger  \\n printed out to the console,  \\n and then we see the actual log output.  \\n So what this indicates to us here  \\n is that, in fact, when search is called,  \\n we access the Logger for the first time,  \\n which then calls the lazy delegate here  \\n which prints out the initialization statement  \\n and then creates that new instance of the Logger for us.  \\n If we were to search then a second time,  \\n this time, we'll just search for the word code,  \\n and we run our code again.  \\n We see that initialization output printed just once still  \\n the first time Logger is accessed.  \\n And then on the second call to search,  \\n we don't see any additional initialization output,  \\n because the Logger has already been initialized  \\n the first time.  \\n Another property delegate Kotlin provides  \\n is an observable delegate  \\n that lets us monitor and respond to changes in a property.  \\n So let's return to our ViewModel here.  \\n And we are going to create a new property here  \\n called currentQuery of type string.  \\n And currentQuery is going to be a mutable variable.  \\n The idea is anytime we call search,  \\n we will update this currentQuery property.  \\n Now, to help monitor changes in this query,  \\n we're going to use an observable delegate  \\n and print out all property value changes.  \\n To set up the delegate,  \\n we'll again come to the property declaration here,  \\n type by.  \\n And then we'll type Delegates dot observable.  \\n Now this observable method here  \\n requires us to pass in an initial value.  \\n So in this case, we'll pass in an empty string  \\n as our initial query.  \\n And then we also need to provide a Lambda.  \\n Within this Lambda, we'll be given three things:  \\n the property, the oldValue and the newValue.  \\n So anytime our currentQuery property changes,  \\n this Lambda will be called back,  \\n and we can use those past arguments to do whatever we like.  \\n In this case,  \\n we are going to simply print out these changes.  \\n So we will print oldValue  \\n and some separator here followed by newValue.  \\n And then to actually make use of this property,  \\n we'll come down to our search method,  \\n and we will update currentQuery anytime search is called.  \\n Now, if we come back to main here,  \\n we'll see that we are still calling search twice.  \\n So if we run our code,  \\n we can observe the outputs here.  \\n So again, we see initializing the logger,  \\n which is coming from our lazy delegate  \\n setting up the Logger itself.  \\n Then we see query, Kotlin,  \\n that's from the Logger logging out the search call.  \\n Then we see an empty string being transitioned into Kotlin.  \\n So that is that transition from our initial currentQuery  \\n into the updated currentQuery  \\n when the first search is called.  \\n Then we see the query log for code.  \\n And then we see the value of currentQuery  \\n changing from Kotlin to code.  \\n So each time that currentQuery is changed,  \\n we are in fact seeing this output logged to the console.  \\n By leveraging both interface and property delegation,  \\n we can build complex behaviors with minimal code.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3085331\",\"duration\":79,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Challenge: Refactor a helper class to use top-level functions\",\"fileName\":\"2497307_en_US_02_04_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, explore a practical example of refactoring a helper class to leverage idiomatic top-level functions.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2534339,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" (upbeat music)  \\n - [Instructor] Let's work through another coding challenge.  \\n In this challenge, we'll work through an example  \\n of refactoring a helper class  \\n into more idiomatic, top-level functions.  \\n For this exercise, we have this class ListUtils  \\n which includes two methods within a companion object.  \\n This class can be used from our main function here  \\n to create a nonEmptyList  \\n or to convert a set into a nonEmptyList.  \\n And just to be clear, a nonEmptyList in this case  \\n is a list that is guaranteed  \\n to have at least one item in it.  \\n So if we return to ListUtis,  \\n we can see the implementation  \\n of each of these methods within ListUtils.  \\n Your challenge then is to refactor this code  \\n to leverage top-level, extension functions.  \\n And ultimately we should be able  \\n to remove the ListUtils class altogether  \\n and the two methods will instead live  \\n as extension functions on the List type.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3084293\",\"duration\":317,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Solution: Refactor a helper class to use top-level functions\",\"fileName\":\"2497307_en_US_02_05_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, see a demonstration of how to refactor from a helper class to top-level functions. This helps you understand how Kotlin embraces functions.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":10490679,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" (upbeat music)  \\n - [Instructor] Let's take a look  \\n at one possible solution  \\n for refactoring our ListUtils helper class  \\n to top level extension functions.  \\n So I've opened up into ListUtils KT here.  \\n And to start,  \\n I know that I want to ultimately move the functions  \\n out of the ListUtils class.  \\n So I'm just going to hit enter a few times  \\n and make some space above that class  \\n where I'll write new functions.  \\n Next, let's think of how to structure  \\n these updated functions.  \\n The non empty list function  \\n acts much like a constructor,  \\n taking in an array of elements  \\n and returning a list of elements  \\n or throwing in exception  \\n if there isn't at least one element.  \\n So, the way we might go about converting this  \\n into a top level function  \\n is to write an extension function on the array type.  \\n We could do that by typing fun.  \\n We'll use a template here  \\n to represent an array of any type.  \\n And then we will define array  \\n of that generic type T.  \\n And then we will name  \\n this extension function NonEmptyList.  \\n And it will return a list of that generic type T.  \\n To complete the implementation,  \\n we can then reuse the previous function body.  \\n We simply need to remove the references  \\n to the items parameter and replace it  \\n with implicit calls to the extended receiver.  \\n So we'll come down here to NonEmptyList,  \\n copy that code,  \\n and paste it back up here in our extension.  \\n And we can simply  \\n remove that reference to the array  \\n because we're extending the array in this case.  \\n So now if we come back to main KT here,  \\n we could replicate the behavior in the first example  \\n by doing array of 1, 2, 3,  \\n dot toNonEmptyList.  \\n Oops.  \\n Just nonEmptyList.  \\n There we go.  \\n So now, rather than having to reference ListUtils,  \\n calling the method and then passing the array to it,  \\n we simply create the array  \\n and then call the non empty list extension method.  \\n The second function can then be refactored  \\n in much the same way.  \\n So in this case,  \\n we're going to write our function  \\n to extend a generic set.  \\n So again, we'll use a templated value here.  \\n And we will extend set of that generic type.  \\n Having set in the name of a function extending set  \\n is a bit redundant.  \\n So for this function,  \\n we are going to change the name a little bit  \\n and we'll just change that name  \\n over to toNonEmptyList.  \\n And it will also then return a list of T.  \\n And once again,  \\n we can reuse the previous method body  \\n for our new function.  \\n And again, this time we are extending the set type,  \\n so we don't need to reference set explicitly  \\n and instead it will be an implicit reference  \\n based on the receiver of set of generic T.  \\n Now, if we come back over to main.  \\n Like we did with the first example,  \\n we could now little bit more fluently  \\n generate a non empty list from a set  \\n by generating the set first.  \\n In this case, A, B, and C.  \\n And then calling toNonEmptyList on that set.  \\n And now finally,  \\n because we have these top level extension functions  \\n that replace the functionality  \\n of the previous methods,  \\n we can go ahead and remove those methods.  \\n And then, because there's nothing left there,  \\n we can go ahead and remove that ListUtils class.  \\n So how did this compare to your solution?  \\n As you compare solution,  \\n also think about design trade offs,  \\n such as visibility of the functions  \\n or potential naming conflicts.  \\n \\n\\n\"}],\"name\":\"2. Writing Idiomatic Kotlin\",\"size\":69876545,\"urn\":\"urn:li:learningContentChapter:3084295\"},{\"duration\":2214,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:3082342\",\"duration\":650,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Threads, thread pools, and executors\",\"fileName\":\"2497307_en_US_03_01_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn how to interact with common JVM threading mechanisms using Kotlin. This is helpful to understand the fundamentals of async programming with Kotlin.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":20312880,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Writing multi-threaded code  \\n is one of the biggest challenges in software development.  \\n Part of the challenge is choosing which sets  \\n of APIs and abstractions to work with.  \\n In Kotlin, we have several options  \\n and we're going to start by reviewing core concurrency APIs  \\n from Java that are still available and viable  \\n in our Kotlin code.  \\n Threads are fundamental elements of concurrency  \\n in Java or Kotlin programs.  \\n A thread represents a thread of execution by the processor.  \\n Having multiple threads can allow  \\n for multiple instructions to be carried out in parallel.  \\n To create a thread,  \\n we can extend the thread class.  \\n So here we'll create a class named custom thread  \\n and it will extend the thread class.  \\n Now within our custom thread,  \\n we can override the run method  \\n to define what work should be executed  \\n when the thread is started.  \\n In this case, we simply want to print out a message  \\n indicating that our code is running from this thread.  \\n So we will simply add a print statement here  \\n that says customthread.run.  \\n To start our thread then, we can come down  \\n into our main function  \\n and we can create a new instance of custom thread  \\n and then call the start method on that thread.  \\n And if we then run our code,  \\n we'll see that customthread.run is printed out  \\n to the console.  \\n Now, why do we care about threads?  \\n Well, modern applications often require multiple streams  \\n of processing at any given time.  \\n We may need to respond to user input and draw user interface  \\n while also monitoring for background location  \\n or listening to an open socket.  \\n Doing all this work on the same thread  \\n can slow down our applications.  \\n By doing work in parallel across multiple threads,  \\n we can make better use of the processing power  \\n of modern CPUs.  \\n Take our current example.  \\n How many threads do you think are currently running  \\n when we run our main function?  \\n If you guessed two, you're right.  \\n Let's print the name of the current thread,  \\n both at the beginning of our main function  \\n and within our custom thread run method.  \\n So first we'll come into a main here  \\n and we will use print LN again  \\n and to get the name of the current thread,  \\n we can type thread.currentthread  \\n and access the name property from that current thread.  \\n And now we will copy that code  \\n and we will add that to our custom thread  \\n run method as well.  \\n Now if we run this code one more time,  \\n we can examine the output and we see that by default,  \\n our main function runs on a thread named main  \\n while our custom thread is running on a thread  \\n called thread-0.  \\n So this highlights for us the fact that  \\n we have multiple threads being run  \\n at the same time when we execute our main function.  \\n Now if we wanted to change the name  \\n of our custom thread here to make it easier to identify,  \\n we could pass a string to the thread constructor.  \\n So we could call this custom thread.  \\n And if we run this again, we'll see that thread-0  \\n has been renamed to custom thread,  \\n making it easier to understand what's going on here.  \\n Threads implement an interface called runnable.  \\n By implementing the runnable interface,  \\n non-thread classes can be passed to a thread for execution.  \\n This gives more flexibility in how we structure our code  \\n since Kotlin supports implementing multiple interfaces  \\n but not multiple inheritance.  \\n So let's create a custom runnable  \\n and demonstrate this example.  \\n So again, we'll create a new class here  \\n and we will call this one custom runnable  \\n and it will implement the runnable interface.  \\n And because it's an interface,  \\n we will need to override the run method in this case.  \\n And for the output of this run method,  \\n we will simply print out custom runnable.run.  \\n Very similar to what we did in our custom thread.  \\n We can then execute this custom runnable  \\n by creating a new thread.  \\n So we'll come down here inside of our main function,  \\n create an instance of a new thread,  \\n and then when we invoke that thread construction  \\n we will pass an instance of custom runnable to it.  \\n And then once again, call the start method.  \\n Now just before I print this out,  \\n I am going to comment out the previous call  \\n to custom thread.start.  \\n And now when we run our code,  \\n we will see that custom runnable.run is printed out  \\n to the console when we create that new thread  \\n and start it while passing in the runnable  \\n to define the behavior that should be run.  \\n In a production code base,  \\n we typically want to avoid creating raw threads  \\n in this manner.  \\n A thread is directly tied to real system resources.  \\n Create too many and you could degrade the performance  \\n of your entire system.  \\n To help with the managing of threads  \\n in a complex application, we can leverage thread pools.  \\n A thread pool is a pattern  \\n in which runnable work is submitted  \\n to a processing queue to be run  \\n on some managed set of threads.  \\n It could be a single thread, two threads, or many threads.  \\n In Java, executors can be used to work with thread pools.  \\n We can create a new single thread executor  \\n that will manage a single thread for us  \\n and create a new thread  \\n if the current one is terminated.  \\n To do this, we'll create a property here called executor  \\n equals executors.newsinglethreadexecutor.  \\n Runnable can then be submitted to be run  \\n by the thread pool as threads become available.  \\n So we could access our new executor property here  \\n and call submit on it  \\n and pass in a new instance of custom runnable.  \\n So now, if we comment out the previous call  \\n to our custom runnable and we run our code again,  \\n we'll see custom runnable printed out to the console,  \\n because that single thread executor  \\n handles submitting that runnable  \\n and running it on the first available thread.  \\n If we need a pool with more than one thread,  \\n say for making simultaneous network requests,  \\n we can create a fixed thread pool using executors  \\n new fixed thread pool.  \\n So let's create another property here,  \\n this time called multithread executor  \\n and assign it the value of executors.newfixedthreadpool.  \\n And we will pass in three.  \\n So in this case, this thread pool  \\n will have a maximum number of threads of size three.  \\n So this means we could have up to three  \\n concurrent operations being performed  \\n at the same time using this thread pool.  \\n So now if we submit multiple runnables,  \\n they will be spread across the available threads  \\n in that pool.  \\n To visualize this ,let's print the name  \\n of the current thread within our custom runnable.  \\n So like we did with custom thread,  \\n we will print out the result of calling  \\n thread.currentthread.name.  \\n Then we can come back down into our main function.  \\n We'll comment out the previous example  \\n and we're going to create a loop  \\n to submit multiple instances of our custom runnable.  \\n So we will write a simple forward loop here  \\n for i in range of 0 to 10,  \\n and then for each iteration,  \\n we're going to submit a new instance  \\n of custom runnable to our fixed thread pool  \\n of size three.  \\n If we then run this code,  \\n we'll see that in the output,  \\n we have three different named threads.  \\n We see pool-2-thread-1, pool-2-thread-2,  \\n pool-2-thread-3,  \\n and those three threads are then repeated  \\n each time through the iteration.  \\n So the thread pool is managing spreading  \\n the submitted runnables across those threads  \\n as the threads finish their work and become available.  \\n Now, just remember our application code  \\n runs within threads which are tied to  \\n real system resources.  \\n Do too much work on a single thread,  \\n and application performance may negatively impacted  \\n as that thread can become blocked or deadlocked.  \\n To avoid this, modern applications  \\n are typically multi-threaded,  \\n spreading work across multiple threads at the same time.  \\n Managing these threads and calculations  \\n are one of the biggest challenges in software development.  \\n This only scratches the surface  \\n of the full set of Java concurrency APIs.  \\n However, the concepts of threads and of thread pools  \\n are quite helpful in building a foundation  \\n for understanding Kotlin coroutines  \\n which we will explore later.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3085332\",\"duration\":253,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Understanding coroutines\",\"fileName\":\"2497307_en_US_03_02_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn about the concept of coroutines and why they are helpful. This helps you better understand why coroutines work the way they do.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":9555952,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] Coroutines are Kotlin's primary abstraction  \\n for writing multithreaded asynchronous code.  \\n Understanding the core concepts behind coroutines  \\n will help us in learning how to use Kotlin's coroutine APIs  \\n in our application code.  \\n Coroutines are not a new concept.  \\n The term coroutines was coined in the 1950s  \\n as a means of describing a subroutine  \\n that could be suspended and resumed.  \\n This concept has since been implemented in many languages,  \\n including C++, C#, Rust, and of course Kotlin.  \\n In Kotlin, the Standard Library  \\n provides a few low-level APIs for coroutines,  \\n while most of the functionality is provided  \\n by the kotlinx.coroutines library.  \\n The library is actually publicly available on GitHub  \\n and can be viewed as a great resource for getting started  \\n or for learning more about coroutines implementation.  \\n In Kotlin,  \\n coroutines can be thought of as lightweight threads.  \\n Like a thread, a coroutine allows us to run a block of code  \\n in parallel with other threads and coroutines.  \\n However, unlike threads, coroutines are not directly tied  \\n to system resources.  \\n A single thread may support multiple coroutines  \\n at the same time.  \\n Because coroutines support suspension and resuming,  \\n they can be called from one thread, suspended,  \\n resumed on another thread, and so on,  \\n all in a non-blocking way.  \\n Now to help manage all those coroutines  \\n and to avoid leaking resources,  \\n coroutines in Kotlin support the concept  \\n of Structured Concurrency.  \\n Coroutines are launched into hierarchical scopes.  \\n Those scopes essentially control the lifecycle  \\n of a coroutine.  \\n Scopes can then be nested within one another as well  \\n to create parent-child relationships  \\n of concurrent coroutines.  \\n Coroutines, and by extension coroutine scopes,  \\n support cancellation of work.  \\n A single coroutine may be canceled,  \\n or an entire scope may be canceled.  \\n Cancellation of a coroutine or a coroutine scope  \\n generally leads to the immediate cancellation  \\n of all child coroutines as well.  \\n This structure is particularly helpful  \\n when managing asynchronous calls  \\n across multiple screens or API requests.  \\n We can define scopes associated to specific API requests,  \\n or application screens, or other objects,  \\n and then clean up any and all launched coroutines  \\n by canceling that scope.  \\n When a coroutine is launched, by default  \\n it will run on the thread associated with the context  \\n of the current coroutine scope.  \\n However, we can also easily change the context  \\n or the thread that that coroutine runs on.  \\n This gives us a great deal of flexibility  \\n in how our coroutines execute.  \\n We can create our own coroutine context  \\n to provide custom threads for our coroutine.  \\n Or we can use a predefined set of contexts,  \\n such as dispatchers.io.  \\n A common example in mobile development  \\n would be to launch a coroutine that runs on the main thread,  \\n process a network request or database access  \\n on a worker thread,  \\n and then update the UI back on the main thread.  \\n While coroutines are simple in concept,  \\n they are still an abstraction  \\n around the inherently complex problem  \\n of concurrent programming.  \\n Keeping these core concepts in mind will help  \\n when learning to use Kotlin's coroutine APIs later on.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3082343\",\"duration\":1095,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Working with coroutines\",\"fileName\":\"2497307_en_US_03_03_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, learn to write async code using coroutines. This highlights the core coroutine APIs needed to start writing idiomatic async code in Kotlin.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":35399564,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Instructor] By leveraging the co-routine APIs  \\n from Kotlin X co-routines,  \\n we can start building multithreaded code  \\n using a few basic APIs.  \\n Let's jump in and learn how to start leveraging co-routines  \\n for asynchronous programming in Kotlin.  \\n To start leveraging the co-routine APIs,  \\n we need to add the co-routine's dependency to our project.  \\n So if we go to our project window  \\n on the left side of the screen here  \\n and open our build.gradle.kts file,  \\n we should see that the coroutines dependency  \\n has already been added.  \\n If it hasn't, you're looking for KotlinX-coroutines-  \\n core version 1.6.0.  \\n Now, once this dependency has been added  \\n and the Gradle old project has been synced,  \\n we should be ready to use the coroutine APIs.  \\n So we'll come back over to our main.kt file here  \\n and we should now be ready to launch  \\n our very first coroutine.  \\n To launch a coroutine,  \\n we need access to a coroutine scope.  \\n The easiest way to access a scope is by using globalscope.  \\n This scope is active for the lifetime of our application.  \\n Because of this, we should be careful to only use it  \\n for coroutines that should truly persist  \\n across the entire life cycle of our program.  \\n In our case, we're simply going to launch a new coroutine  \\n into global scope to print out a message.  \\n We can do this by calling the launch method on the scope  \\n and then we will use print LN to print out  \\n hello coroutines.  \\n Now, if we run this code,  \\n you might notice that we don't see our message  \\n printed out to the console.  \\n Why do you think that might be?  \\n The answer is that we are printing our message  \\n from a coroutine that runs asynchronously.  \\n So we launch the coroutine  \\n and our main function then immediately completes  \\n because there's nothing left for it to do  \\n within that thread of execution.  \\n If we come down to the bottom of our main function  \\n and we add a call to thread.sleep  \\n and then we rerun our code,  \\n this time we see our hello coroutines output  \\n printed to the console.  \\n Why does this work?  \\n Well, the call to thread.sleep will block  \\n the main thread from completing for one second.  \\n This gives our coroutine time to execute  \\n before the main function completes.  \\n This highlights the fact that the threads  \\n that coroutines operate on still behave  \\n as normal threads of execution,  \\n even if we launch coroutine into them.  \\n Now an easier way to prevent our program  \\n from completing early is to use the run blocking function.  \\n Now to update our code to support this  \\n run blocking function,  \\n we will come up to our main function declaration,  \\n and after the parenthesis list, we'll add a colon.  \\n We'll explicitly return the unit type  \\n and then we'll say equals run blocking.  \\n And when prompted, we will import that.  \\n And now because we're using this run blocking method,  \\n any coroutines launched within the scope provided  \\n by run blocking will be completed  \\n before our main function completes.  \\n Now, this also means that we can launch our coroutine  \\n without the use of global scope.  \\n So now when we launch our coroutine,  \\n it'll launch into the run blocking scope,  \\n it will complete its output,  \\n and then our main function will complete.  \\n And if we run this, sure enough,  \\n we see hello coroutines printed out  \\n and then immediately our program terminates.  \\n Now we're going to jump over  \\n to the refresh home KT file for another example.  \\n So we'll open up our project window here,  \\n find a refresh home, and open that file.  \\n And then we'll go ahead and close the project window,  \\n close our main file  \\n and any other remaining files we might have open.  \\n So within refresh home here,  \\n we are simulating the loading of data  \\n from the home screen in an application.  \\n We need to load data from three different sources,  \\n tasks, reservations, and a user endpoint.  \\n So we have functions to simulate each of those,  \\n we have a refresh tasks function,  \\n a refresh reservations, and a refresh user.  \\n Additionally, we have a couple other functions here  \\n for updating the UI and eventually canceling all this work.  \\n We'll get to those shortly.  \\n If we look at our main function here,  \\n we are launching a new coroutine here  \\n by calling run blocking  \\n and then we are calling each of those refresh tasks  \\n one after the other.  \\n Now if we run this code, we'll notice a couple of things.  \\n The calls are carried out sequentially  \\n and they all run on the same thread.  \\n In this case, the main thread  \\n since that's the thread that called run blocking.  \\n Within the same coroutine,  \\n code will execute sequentially by default.  \\n However, we can change that by launching new coroutines  \\n within a scope.  \\n Let's wrap the calls to refresh tasks  \\n and refresh reservations  \\n in another launch call and see what happens.  \\n So we will come down into our main function.  \\n We will call launch, and then we will move refresh tasks  \\n and refresh reservations into that new launch call.  \\n Now if we run this code again, let's see what happens.  \\n This time we see the call to refresh user completes first  \\n because the other two were launched  \\n into a separate child coroutine  \\n which then takes a little bit of time to run.  \\n Also worth noticing here that each of these calls  \\n were still run in the same underlying thread,  \\n the main thread.  \\n To change the thread on which a coroutine  \\n will ultimately be executed,  \\n we have a couple of options.  \\n The easiest way is to specify a new coroutine context  \\n when launching the coroutine.  \\n In this case, we can do this quite easily  \\n by passing dispatchers.io to our call to launch.  \\n This will move the tasks  \\n and reservation calls onto a worker thread.  \\n When we rerun this code,  \\n we now see those two calls being called  \\n from a different thread.  \\n Another option for moving work onto a different thread  \\n within a coroutine is to use with context.  \\n Let's imagine we want to update the application UI  \\n after the tasks and reservation calls are finished.  \\n We can call with context  \\n and then pass in the context provided  \\n by the run blocking function to move the work back  \\n to the original thread.  \\n So within our launch call to dispatchers.io,  \\n we'll make a call to with context.  \\n And now we want to reference the coroutine scope  \\n provided by run blocking,  \\n and we can do this by typing  \\n this@runblocking.coroutinecontext,  \\n and then we need to provide a Lambda  \\n to control what should actually be run.  \\n And in this case,  \\n we'll make our call to the update UI method.  \\n So once the two refresh calls are completed,  \\n we'll then use with context to call the update UI method  \\n in whatever context run blocking provided.  \\n So effectively what this has done is  \\n let us run the refresh calls  \\n on an IO thread, and then move the update call  \\n back to the main thread.  \\n This type of pattern is very common in mobile development.  \\n If we go ahead and run this real quick,  \\n we'll then see that the refreshing of user happens  \\n on the main thread.  \\n Then our refreshing tasks and refreshing reservations calls  \\n happen on a worker thread  \\n and finally, updating the UI completes back  \\n on the main thread.  \\n Now we've touched on the fact that code  \\n within a coroutine runs sequentially.  \\n We can better demonstrate this  \\n by simulating long running operations  \\n with the delay suspending function.  \\n Delay is similar to thread.sleep,  \\n but it only suspends the coroutine.  \\n It doesn't block the entire thread.  \\n So let's come up to our tasks and our reservations functions  \\n and add a call to delay and pass in a value of 3000.  \\n So the idea here is that we will delay for three seconds.  \\n Now as soon as we add that call to a delay,  \\n we get an error.  \\n If we hover over that error,  \\n we'll see suspend function delay  \\n should be called only from a coroutine  \\n or another suspending function.  \\n So this error stems from the fact that delay  \\n is a suspending function.  \\n The suspend keyword indicates  \\n that a function can suspend operation  \\n of a coroutine to then be resumed at a later time.  \\n Suspending functions can only be called  \\n from within a coroutine  \\n or from some other suspending function.  \\n So to call delay in refresh tasks or refresh reservations,  \\n we need to add the suspend keyword  \\n to each of those functions.  \\n As soon as the suspend keyword is added,  \\n that compiler error goes away.  \\n If we run our code now,  \\n we can clearly see the delays operating sequentially,  \\n three seconds for the first function to complete,  \\n and three more for the second.  \\n While this code is not blocking the underlying thread,  \\n it's still not as efficient as we could make it  \\n if we parallelized the work.  \\n For that, we can leverage another coroutine builder, async.  \\n Async, like launch, allows us to create a new coroutine,  \\n but async returns to us a deferred value  \\n which can then be later used to get a result.  \\n And we can run multiple async coroutines at the same time  \\n and proceed only when all results are available.  \\n So to demonstrate this, we are going to grab the code  \\n within our launch and just move it back out of the launch.  \\n Now we're going to refactor this then  \\n to use a couple different calls to async.  \\n So to start, we're going to create a variable called tasks  \\n and then we are going to call async on it.  \\n And we're going to move our call  \\n to refresh tasks inside that call to async.  \\n So now the tasks variable here is going to hold  \\n a deferred value that will eventually calculate  \\n the result of refresh tasks.  \\n And similar here,  \\n I'm going to create a variable called reservations,  \\n and same thing.  \\n We will move the refresh reservations call  \\n inside that call to async.  \\n So now we have references  \\n to both of these deferred computations  \\n and we want to suspend completion of this coroutine  \\n until both of those operations complete.  \\n So to do that, we can call await all  \\n and we will pass in both of those deferred values.  \\n So calling await all here will suspend the coroutine  \\n until both deferred values are finished  \\n and only then will we call with context to update our UI.  \\n So now if we run this, we see an initial delay,  \\n and then we see that both the refresh tasks call  \\n and the refresh reservations call complete  \\n at more or less the same time.  \\n So now instead of having those three second delays  \\n executed serially, they happen in parallel  \\n so they complete together  \\n And then we go on to finish updating our UI.  \\n Now notice here that refreshing the user  \\n happened last as well.  \\n This is because we removed that other call to launch.  \\n So now, because we are within the same run blocking  \\n coroutine, refresh user is going to be run serially  \\n after the await all call is completed.  \\n The last thing we're going to touch on  \\n is coroutine cancellation.  \\n Whether we start a coroutine using launch or async,  \\n we can cancel that coroutine and its children  \\n by calling cancel on the coroutine's job.  \\n A job is a part of a coroutine scope  \\n and can be used to remember a coroutine and cancel it.  \\n The launch builder returns a job.  \\n So all we need to do is assign it to a variable  \\n and we can use it for cancellation.  \\n So let's come down here to our refresh user call  \\n and we are going to make this call  \\n from within a launched coroutine.  \\n So we'll create a variable here called job  \\n and assign it the result of calling launch.  \\n And then we'll just move that call  \\n to refresh user within the launch.  \\n So now we have this reference to a job,  \\n and if we wanted, we could call job.cancel here  \\n to cancel this work  \\n so that refresh user call was never completed.  \\n And if we run this code,  \\n we will see that once our UI is updated,  \\n we never see the output indicating  \\n that the user was refreshed.  \\n This is because as soon as we get a reference  \\n to the launched job for refreshing the user,  \\n we're immediately canceling it.  \\n And this can be extended to multiple coroutines  \\n at the same time.  \\n So let's just say for fun,  \\n we wanted to take all of our syncing and UI updates  \\n and move those into another launched coroutine.  \\n So we could create another variable here called job2  \\n and launch a new coroutine for all of that work.  \\n If we then wanted to cancel all of this work together,  \\n we could make use of this cancel everything function  \\n that we had previously defined.  \\n This will take in a number of jobs,  \\n and then we can iterate over each job  \\n to cancel them together.  \\n So if we call cancel everything,  \\n pass in job and job2,  \\n now if we run our code,  \\n we see that nothing at all is printed out.  \\n So this ability to get a reference to the work  \\n from a launched routine and to cancel all of the work  \\n being done within that given scope  \\n and within its child scopes is very powerful.  \\n It gives us a lot of ability  \\n to ensure that we're not doing more work  \\n than is needed to make sure that work is scoped properly  \\n to different components in our applications.  \\n Now, there's much more to learn when it comes to coroutines  \\n but here we've covered the core essentials.  \\n As you continue to explore coroutines,  \\n be mindful of the coroutine's scope you're launching  \\n your coroutine into,  \\n and the thread on which it'll be running.  \\n Being careful with those things will go a long ways  \\n towards helping you write effective async code  \\n with coroutines.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3081329\",\"duration\":56,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Challenge: Manage multiple async requests\",\"fileName\":\"2497307_en_US_03_04_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, explore a common example of coroutines usage by responding to multiple, long-running tasks at the same time.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":1932660,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" (upbeat music)  \\n - [Instructor] Let's get some hands-on practice  \\n with coroutines.  \\n In this challenge, your task is to use coroutines  \\n to parallelize the execution of two suspending functions.  \\n We have load items from DB and load items from network.  \\n These functions simulate making blocking requests  \\n to a database into the network.  \\n Your task is to use the async coroutine builder  \\n to run both functions at the same time  \\n and then to use deferred data wait,  \\n to get the results of both async calls.  \\n Convert those results into a unified list  \\n and print out that unified list to the console.  \\n The resulting code should run in approximately five seconds  \\n if the coroutines are running in parallel.  \\n \\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:3081330\",\"duration\":160,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Solution: Manage multiple async requests\",\"fileName\":\"2497307_en_US_03_05_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"In this video, see a demonstration of common coroutine usage by responding to multiple, long-running tasks at the same time.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":5681386,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" (upbeat music)  \\n - [Instructor] All right, let's walk through a solution  \\n to our concurrent coroutines challenge.  \\n To run our load functions in parallel  \\n and get back our result,  \\n we want to leverage the async coroutine builder.  \\n So we will come into our main function here  \\n and we'll start by creating a variable called db  \\n that will hold the deferred result  \\n from loading the items from the database.  \\n So we'll make a call to async  \\n and within that launched async coroutine,  \\n we will call loadItemsFromDB.  \\n We'll then repeat this process  \\n for the network function.  \\n So we'll create a variable  \\n called network equals async loadItemsFromNetwork.  \\n Now we have two variables holding deferred results,  \\n DB and Network.  \\n These deferred values act  \\n like futures in other languages.  \\n They represent a handle to a value  \\n that will be returned in the future.  \\n To get access to that future value,  \\n and suspend the parent coroutine until that happens,  \\n we can call await.  \\n We're going to create a variable called results  \\n and assign it the resulting calculation  \\n of calling db.await  \\n plus network.await.  \\n So what this is going to do  \\n is await for each of those deferred results  \\n and once each one has completed,  \\n it will concatenate the returned lists together,  \\n and give us back a unified list of results  \\n in our results variable.  \\n While we wait for those results,  \\n the parent coroutine will be in a suspended state.  \\n Once we have our results list,  \\n we can go ahead and print out each of those results.  \\n So since these results  \\n are representing programming languages,  \\n we will rename that implicit lambda parameter  \\n to language and we will print out that language  \\n to the console.  \\n If we then run this code,  \\n we should see a delay for several seconds  \\n and then ultimately, we should see  \\n that unified list printed out to the console,  \\n just like that.  \\n\\n\"}],\"name\":\"3. Writing Asynchronous Code with Kotlin Coroutines\",\"size\":72882442,\"urn\":\"urn:li:learningContentChapter:3087336\"},{\"duration\":59,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:3080455\",\"duration\":59,\"visible\":true,\"requiredForCertificateOfCompletion\":null,\"name\":\"Next steps\",\"fileName\":\"2497307_en_US_04_01_XR30\",\"demo\":false,\"videoCreationMetadata\":null,\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2292189,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\" - [Nate] As we've seen throughout this course,  \\n Kotlin is a powerful and flexible language,  \\n designed for building modern applications  \\n across a variety of domains.  \\n Language features, such as data and sealed classes,  \\n extension functions,  \\n and coroutines, provide first-party solutions  \\n to many common programming problems.  \\n As you continue on with Kotlin,  \\n there are many other great resources out there.  \\n Be sure to check out Kotlin's Getting Started guide,  \\n the Kotlin org on GitHub,  \\n or work through the Kotlin Koans for more practice.  \\n You should now have the tools you need  \\n to start building complete applications with Kotlin.  \\n For inspiration on where to apply those skills,  \\n explore the Kotlinlang website  \\n for more information on how to use Kotlin  \\n to build mobile, server, browser,  \\n and even multi-platform applications.  \\n There's plenty more to learn about Kotlin,  \\n but hopefully, this course has convinced you  \\n to try Kotlin for your next project.  \\n \\n\\n\"}],\"name\":\"Conclusion\",\"size\":2292189,\"urn\":\"urn:li:learningContentChapter:3080456\"}],\"size\":319470042,\"duration\":10301,\"zeroBased\":false},{\"course_title\":\"Kotlin Multiplatform Development\",\"course_admin_id\":2724070,\"metadata\":{\"Locale\":\"en_US\",\"Course ID\":2724070,\"Project ID\":null,\"Course Name\":\"Kotlin Multiplatform Development\",\"Course Name EN\":\"Kotlin Multiplatform Development\",\"Activation Status\":\"ACTIVE\",\"Display to Public\":\"No\",\"Display to QA\":\"Yes\",\"Course Description\":\"Master cross-platform development with Kotlin by creating sophisticated applications that run seamlessly across Android, iOS, web, and desktop. In this comprehensive course, instructor Colin Lee empowers you to make smart architectural choices between Compose Multiplatform's shared UI approach and platform-specific interfaces like SwiftUI, balancing code reuse with native feel. Learn how to create shared networking layers with Ktor and implement cross-platform data persistence using SQLDelight. Whether you're a mobile developer looking to expand your reach or a full-stack engineer seeking to unify your codebase, this course equips you with the essential skills you need to develop professional Kotlin applications that truly write once and run from anywhere.\",\"Course Short Description\":\"Discover the tools you need to start creating multiplatform apps by sharing Kotlin code across Android, iOS, web, and desktop.\",\"Content Type\":\"TOOLS\",\"Localization Type\":\"ORIGINAL\",\"Original Course Locale\":null,\"Original Course ID\":null,\"Equivalent English Course\":null,\"Instructor ID\":\"2094007\",\"Instructor Name\":\"Colin Mark Foster Lee\",\"Instructor Transliterated Name\":null,\"Instructor Short Bio\":\"Staff Mobile Engineer at webAI | Kotlin Multiplatform Expert\",\"Author Payment Category\":\"NON-LICENSED\",\"Delivery Mode\":\"ALL_AT_ONCE\",\"Series End Date\":null,\"Course Release Date\":null,\"Course Updated Date\":null,\"Course Archive Date\":null,\"Course Retire Date\":null,\"Replacement Course\":null,\"Has Assessment\":\"No\",\"Has Challenge/Solution\":\"No\",\"LIL URL\":\"https://www.linkedin.com/learning/kotlin-multiplatform-development\",\"Series\":\"One-Off\",\"Limited Series\":null,\"Manager Level\":\"Individual Contributor\",\"LI Level\":\"Intermediate\",\"LI Level EN\":\"Intermediate\",\"Sensitivity\":null,\"Internal Library\":\"Technology\",\"Internal Subject\":\"Programming Languages\",\"Primary Software\":\"Kotlin\",\"Media Type\":\"Video\",\"Has CEU\":\"No\",\"Has Exercise Files\":\"Yes\",\"Visible Duration\":9236.0,\"Visible Video Count\":34.0,\"Learning Objectives\":\"Assemble a Kotlin application that can execute across Android, iOS, web, macOS, Windows, and Linux.,Correctly choose between building your Kotlin app using either Compose Multiplatform with shared Compose user interfaces or using Kotlin Multiplatform with native user interface libraries, such as Jetpack Compose and SwiftUI.,Create shared networking code in Kotlin across multiple platforms using a REST library such as Ktor.,Share database code in Kotlin across multiple platforms using a library such as SQLDelight.\",\"Contract Type\":\"PERPETUAL\",\"Certifications\":null,\"Framework Topic\":null,\"Automatic Caption Translations\":null,\"Automatic Metadata Translations\":null,\"Gen AI Feature Flag\":null,\"Hands-On Practice\":null,\"Hands-On Practice Library\":null,\"Unlocked for Viva Learning\":null,\"Free Course\":null,\"Certification Library\":null,\"Github Codespace\":null,\"Skills Count\":2,\"Skills\":\"Cross-platform Development,Kotlin\",\"Skills EN\":\"Cross-platform Development,Kotlin\",\"Content Manager\":\"Christa Lindley\",\"Acquisition Manager\":\"Christa Lindley\",\"Framework Subject\":null},\"sections\":[{\"duration\":77,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:6063009\",\"duration\":39,\"visible\":true,\"requiredForCertificateOfCompletion\":null,\"name\":\"Kotlin multiplatform development\",\"fileName\":\"2724070_en_US_00_01_VT\",\"demo\":true,\"videoCreationMetadata\":{\"rawDurationSeconds\":719,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Get an introduction to what this course will cover.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2641478,\"solution\":false,\"welcomeContent\":true,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- Are you ready to explore the magic\\nof Kotlin Multiplatform?\\nIn this course,\\nI'll provide you with a broad overview of the topic.\\nFor example, we will explore many libraries\\nthat make it possible for you to write an app\\nthat runs across many web, desktop, and mobile platforms.\\nBut these solutions will require\\nhardly any platform specific code.\\nHi, I'm Colin Lee.\\nI'm an experienced mobile engineer at an AI startup.\\nI launched a Kotlin user group\\neven before Google announced official support\\nfor Kotlin and Android.\\n\\nSo let's go.\\nI'm excited to share with you the magic\\nof Kotlin Multiplatform.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6064007\",\"duration\":38,\"visible\":true,\"requiredForCertificateOfCompletion\":null,\"name\":\"What you should know\",\"fileName\":\"2724070_en_US_00_02_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":47,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":true,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Find out what you need to know to get the most out of this course.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":921730,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Here's what you should know.\\nSince this course is not going to cover the basics,\\nyou may want to consider an intro to Kotlin.\\nYou could simply read the Kotlin tour\\non the official website.\\nJust go to kotlinlang.org and click on \\\"Get Started.\\\"\\nThe official Kotlin tour is short, sweet,\\nand won't ask you to rate it five stars at the end.\\nHowever, you shouldn't need too much preparation.\\nIf you've used a similar language\\nwith strong types, like Swift,\\nKotlin will feel quite familiar.\\n\\nYou will also need to know how\\nto install software on your computer\\nand how to use a terminal\\nor command line in your operating system.\\n\"}],\"name\":\"Introduction\",\"size\":3563208,\"urn\":\"urn:li:learningContentChapter:6061090\"},{\"duration\":1724,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:6064008\",\"duration\":230,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"The problem Kotlin Multiplatform solves\",\"fileName\":\"2724070_en_US_01_01_VT\",\"demo\":true,\"videoCreationMetadata\":{\"rawDurationSeconds\":254,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":true,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Decide if Kotlin Multiplatform (KMP) is right for your needs.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":6385843,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Why are we discussing Kotlin Multiplatform?\\nCost complexity and trade-offs\\nmake it the best solution for many apps.\\nLet me explain.\\nNative apps have traditionally\\nprovided the best experience for users.\\nWhat is a native app?\\nA native app uses the best language\\nand user interface libraries to run natively on your system.\\nBy using methods supported by your operating system vendor,\\nyour app is more likely to look like an app that belongs\\non that platform and to work in a way that is more intuitive\\nto users of that operating system.\\n\\nWriting a traditional native app across iOS, Android, MacOs,\\nWindows, Linux, and web requires a large team\\nof highly paid developers communicating closely\\nwith one another.\\nIt is a very expensive and it's challenging\\nto write one app that looks beautiful and runs nicely\\nacross all of these devices.\\nTypically, one developer lacks the specific knowledge\\nof languages and frameworks and the time to port one app\\nto all of these different systems.\\n\\nAlso, each platform ends up with unique bugs\\nbased upon the different development teams\\nworking on each platforms app.\\nEnter hybrid frameworks.\\nThese were intended to solve the difficulty\\nin knowing all of these systems,\\nand to produce a native app across all of them.\\nMost hybrid frameworks substitute calls in one language,\\nlike JavaScript or Dart,\\nwith user interface calls in the native language.\\n\\nWhile hybrid frameworks seem convenient\\nand they would seem to solve the difficulty\\nof producing an app across a wide spectrum of platforms,\\nthey have several key downsides.\\nDebugging is challenging\\nsince multiple languages are involved,\\nand the programmer may not understand the native code.\\nThe languages used tend to have poor performance,\\nlike JavaScript,\\nor may be less known outside of hyper development,\\nsuch as Dart.\\nApps which require careful handling of device hardware,\\nlike camera, Bluetooth, and others,\\nmay be more challenging to write and to maintain.\\n\\nKotlin Multiplatform handles most of the downsides\\nof hybrid frameworks admirably.\\nWhat is Kotlin Multiplatform?\\nIn 2017, the Kotlin language team at JetBrains\\nadded support to allow running software\\nwritten in Kotlin across a wide variety\\nof different hardware and software types.\\nThey added support to allow writing apps\\nfor the Java Virtual Machine, or JVM,\\nnative on the LLVM, and web.\\n\\nHowever, each platform can still benefit\\nfrom custom per-platform code in some instances.\\nSo they added a mechanism to the core Kotlin language\\nto allow running a different function or method\\ndepending upon the underlying platform.\\nThat announcement was very popular and exciting,\\nbut it was still difficult to write software\\nbecause you then had to write slightly different code\\nto accommodate all the differences between platforms.\\n\\nThis all changed with the development\\nof Kotlin Multiplatform libraries.\\nThe complexity and cost of developing high-quality apps\\nfor many platforms has made native development a challenge.\\nMeanwhile, hybrid frameworks often fall short.\\nKotlin Multiplatform changed the game by offering a method\\nto share logic while still embracing the unique strengths\\nof each platform.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6065001\",\"duration\":198,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Comparison with alternatives\",\"fileName\":\"2724070_en_US_01_02_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":228,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":true,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Determine when KMP might serve your needs more effectively than other alternatives.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":5184109,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] What if you could code native apps\\nfor every device without giving up on the performance,\\nthe flexibility, or the unique look\\nand feel of each platform.\\nThis is what KMP or Kotlin Multiplatform offers.\\nSo how does KMP compare to hybrid alternatives?\\nToday, most software is composed of libraries.\\nSince 2017, many Kotlin software libraries have been written\\nfor Kotlin Multiplatform.\\n\\nThis means you might be able to write a simple app\\nwithout writing any code specific\\nto the operating system or at hardware.\\nIn addition, you can mix and match Kotlin\\nwith other languages and incorporate\\nshared business logic into native user interfaces.\\nFor example, Kotlin Interoperates with Objective-C\\nand Swift Code for writing apps for Apple devices like iOS,\\nmacOS, watchOS, and visionOS.\\nYour software teams can decide\\nhow much they want to share code to deliver software faster,\\nor how much they would prefer to have native user interfaces\\nthat are easy to use and which native developers\\nwill feel more comfortable working with.\\n\\nSince all of your code is actually running\\nin the best native target for your operating system,\\nKotlin Multiplatform is also very fast\\nand offers native performance.\\nMany companies have adopted KMP or Kotlin Multiplatform,\\nand have found it to perform very well for their apps.\\nHere is a handful of companies that use KMP\\nand have nice things to say about it.\\nI personally use KMP to revitalize the apps\\nthat we wrote at Meetup.\\n\\nThere are a lot of common misconceptions about KMP.\\nHere are a few.\\nSome assume it's simply another hybrid framework\\nlike React Native.\\nWhile there is a user interface framework available\\ncalled Compose Multiplatform, KMP can be used\\nwith entirely native UI as well.\\nAlso, KMP works across a very wide spectrum of platforms\\nand is not limited to mobile or even client apps.\\nMany case studies are also very complex apps\\nand they benefit extensively from the way\\nthat Kotlin Multiplatform allows sharing of logic.\\n\\nSince KMP uses the best native code generator\\nfor most platforms,\\nit is typically comparable in performance to native.\\nAs I found during my Meetup project work,\\nnative developers can quickly start contributing code\\nto KP projects if there's someone to support the team\\nwith Kotlin Multiplatform knowledge.\\nFinally, there is a large,\\nrobust community centered on KP mostly due to Android apps,\\nwhich also share code with iOS.\\nThat community is very competent\\nand quite often does not limit their libraries\\nexclusively to mobile.\\n\\nKotlin Multiplatform stands apart from hybrid frameworks.\\nBy combining the performance\\nand the flexibility of Native,\\nwith the efficiency of shared business logic,\\nKP allows infinite mixing\\nand matching to find the most efficient solution.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6061089\",\"duration\":180,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Supported platforms and performance\",\"fileName\":\"2724070_en_US_01_03_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":215,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":true,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Find out how KMP performs on each supported platform and what underlying technology it uses.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":5107136,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] What app would you build if you knew\\nit could work on every device and operating system?\\nKotlin Multiplatform supports nearly all operating systems\\nand hardware in wide use today;\\nthis includes mobile, desktop, web, and server.\\nIn order to support this wide range of hardware\\nand operating systems, Kotlin uses four code generators:\\ntheir Java Virtual Machine or JVM; Native or LLVM;\\nJavaScript, and WebAssembly.\\n\\nThese four code generators allow Kotlin\\nto target most modern devices\\nand operating systems: Android, iOS, Windows, Mac OS,\\nLinux, web, WebAssembly, server-side backend web,\\nwatchOS, tvOS, even Raspberry Pi,\\nor any device that can run Java, C, or JavaScript.\\nKotlin is known to interoperate quite nicely\\nwith a good number of alternative programming languages.\\n\\nThe best are like Java, Objective-C, Swift.\\nIt's decent at other JVM languages, C/C++, Rust,\\nand JavaScript; and only okay maybe at like Go, Python,\\nand any other language with C bindings.\\nBased on Kotlin's four code generators,\\nthere are also numerous options to choose\\nin terms of user interface frameworks.\\nHere's a small sampling: Jetpack Compose, SwiftUI, React,\\nany JavaScript framework, Flutter, Angular, Spring.\\n\\nSo how easy is it to use Kotlin on these platforms?\\nWhat are the best-case platforms\\nthat are the easiest to use today?\\nI would say the easiest is Android and iOS with Compose\\nand SwiftUI, or Jetpack Compose, Windows, Mac OS,\\nand Linux with Compose Desktop,\\nand back-end web with Ktor and Spring.\\nHarder might be Kotlin with React\\nand JavaScript frameworks or WebAssembly,\\nwhich is still fairly young.\\n\\nAnd hardest would be all the rest of the platforms.\\nCompose Multiplatform is a technology which uses\\nthe Jetpack Compose Android user interface library\\nto create shared user interface code across nearly\\nall supported devices.\\nThere are also numerous software libraries supporting\\nwith this framework, which function decently\\nacross many of the devices.\\nAs you have learned in this section,\\nKotlin Multiplatform offers exceptional support\\nacross a wide range of platforms.\\n\\nIt also supports interoperability with many other languages\\nas well as user interface frameworks.\\nBy using Kotlin, you should be able\\nto target nearly any system once you have the right skills.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6057318\",\"duration\":198,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Just what the KDoctor ordered\",\"fileName\":\"2724070_en_US_01_04_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":756,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":true,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Discover the Fleet IDE and its interface while using KDoctor to validate your setup.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":7389279,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Before we get started programming,\\nit's important to ask if our system is ready.\\nThere could be a number of things required\\nto build and run a Kotlin Multiplatform app.\\nTo make sure that we're ready,\\nwe're going to take a trip to the doctor,\\nspecifically KDoctor.\\nNow KDoctor is only for macOS.\\nHowever, you won't generally be able to develop software\\nfor iOS or macOS\\nunless you have a macOS device for development.\\n\\nYou will still be able to use Kotlin Multiplatform\\nand take this course, however,\\neven if you can't develop for Apple devices.\\nTo get started installing KDoctor, you will need Homebrew.\\nIf you don't already have it installed,\\nyou'll find the steps to install it at brew.sh.\\nI will walk through this with you.\\nHere I'm copying the URL\\nand I'm going to go into a command line terminal\\nand paste this content here into the terminal.\\n\\nAfter you run the bash command to install Homebrew,\\nit will walk you through the process.\\nHere I have to put in my sudo password\\nand just follow along in the interactive terminal.\\nWith Homebrew installed, we simply need\\nto run the brew install kdoctor.\\nFirst I'm going to run through the steps here\\nto add it to my path.\\nJust copy and paste and then brew install kdoctor.\\n\\nOnce installation is completed, we can then run KDoctor\\nand it will run us through the steps needed\\nto have a fully working Kotlin Multiplatform environment.\\nAs you can see, it can't find Java\\nor the Xcode command line tools.\\nIt's using system Ruby, which is not good\\nand does not have CocoaPods.\\nSo keep running KDoctor until you no longer see\\nrequired steps to perform.\\nIf you're not developing on a macOS device,\\nbut are using Windows or Linux instead,\\nwe have a number of manual steps\\nyou're going to need to perform.\\n\\nFirst, install Android Studio from the official website.\\nThis will give you all the Android SDK tools,\\nas well as Android Studio.\\nSecond, make sure JAVA_HOME is set in your environment\\nto working Java development kit.\\nAndroid Studio provides one,\\nso try running Java from the command line\\nand ensure that it runs without errors.\\nThere we go, java -version.\\nAnd if it doesn't run correctly,\\nmake sure you add the correct Java development kit\\nto your path.\\n\\nThird, install the Kotlin Multiplatform plugin\\nin your Android Studio.\\nSo you go to Settings, Plugins,\\nand Marketplace, and then you would search for it.\\nI already have it installed here as you can see,\\nbut just make sure that it's installed and fully updated.\\nWhether you're using macOS, Windows or Linux,\\nfollowing the outline setup process will ensure\\nthat you have the tools and the environment ready\\nto build and to run your projects with confidence.\\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:6055289\",\"duration\":581,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Android studio for KMP\",\"fileName\":\"2724070_en_US_01_05_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":1057,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"Exercise Files > Chapte01 > 01-05\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":true,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":21916764,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] For working with Kotlin Multiplatform,\\na number of integrated development environments\\nor IDE options are supported.\\nFor this course,\\nwe will use Android Studio for most of our development.\\nWe will also use Xcode, which we'll cover in a later video.\\nA lot of improvements\\nhave been coming to Android Studio recently\\nrelated to Kotlin Multiplatform.\\nAs a result, you may want to consider using a\\nbeta or canary version of the IDE.\\nFor this course,\\nI recommend using Android Studio Meerkat, Narwhal, or later.\\n\\nStarting with Meerkat, Android Studio has the capability\\nto add shared module to your Android app projects for you.\\nBeginning with Narwhal, the IDE also has the capability\\nto show compose multi-platform previews.\\nLet's take a look at an example project that I created.\\nFirst of all, you're going to generally want to switch\\nfrom the Android view to the project view.\\nThis is generally true\\nwith Kotlin Multiplatform projects in Android Studio.\\n\\nThere are a couple of plugins you should consider\\nwhich will improve your development experience.\\nFirst, there is a compose multiplatform project,\\nwhich is included in most recent versions of Android Studio.\\nThis adds some useful functionality\\nto make compose multiplatform easier to work with.\\nSo you can see this is Jetpack Compose.\\nIt's not the same one.\\nWe want to go to this one, Compose Multiplatform IDE support\\nand this will come with, I believe, Narwhal and later.\\n\\nAlso, you're going to want the Kotlin Multiplatform plugin,\\nwhich I have right here, which will help as well.\\nThis should allow you to run your iOS app\\ndirectly from Android Studio.\\nIf it doesn't show up automatically,\\nyou can still add iOS or desktop targets or any other\\nby editing the run configurations.\\nIf you want to run your app directly from Android studio\\nfor iOS, desktop, or web assembly,\\nyou may find you have to add\\na new run configuration manually.\\n\\nSometimes the iOS configuration appears automatically\\nif you already have\\nthe Kotlin Multiplatform plugin installed.\\nIf you want to run the desktop app,\\nyou should follow these steps.\\nFirst, go to the dropdown at the top of the IDE\\nwhere you would select Android or iOS run configurations,\\nyou select Edit Configurations\\nand then press the plus button.\\nChoose application, name your run configuration,\\nselect a recent Java version.\\n\\nHere I'm going to choose the JetBrains Runtime\\nthat came with Android Studio.\\nSelect the desktop main module,\\nand then we need to select a main class here.\\nYou tap this icon in the right corner, the document icon,\\nand it searches and finds a main class.\\nIt will not find one if you haven't created it.\\nSo usually select the first option, press OK,\\nand run the desktop app.\\nOkay, I had to update some Gradle versions,\\nbut now I should correctly run the desktop version.\\n\\nYou'll notice I made changes\\nto both the Gradle Libs versions 2 ML file,\\nas well as the Gradle wrapper properties file\\nin order to update the versions of the project.\\nWhen I'm here and there's underlined text,\\nyou can put your mouse over, click,\\nand then you just hit option enter\\nand it'll update to the latest version,\\nassuming that version works correctly.\\nOkay, here we go.\\nI'm just going to press run and it's going to run,\\nand as you can see, it's correctly loading the version here.\\n\\nSo it'll show to you\\nthat it's coming from the desktop app.\\nHere, it's Java and the version of Java that is running.\\nSo you can see that I managed\\nto get the desktop configuration to work.\\nWeb assembly or WASM JS in this case is more experimental.\\nWe won't dive too deeply into this course due\\nto more limited multi-platform library support today,\\nbut you can still run it from Android Studio.\\nAgain, you go to the dropdown for run configurations,\\nchoose edit configuration, add a new one with Gradle\\nas the type, here I'll put in web\\nand this part, you have to type exactly the right thing.\\n\\nI put down here WASM JS browser\\ndevelopment run minus T.\\nExactly that.\\nAnd now if I hit okay\\nand I try running it, this should load my web browser\\nand show a web assembly version of the project running.\\nAs you can see here, it's running and showing WASM JS.\\nIt's in my Safari browser, so everything's working.\\n\\nI can also show you how\\nto create this iOS app configuration if it does\\nnot create it for you.\\nLet me give this a go.\\nDo I press minus?\\nSay iOS application\\nand we'll type in iOS here.\\nYou have to choose the project file in the folder\\nand here it is.\\nThen you have to wait for it,\\nthen choose the project scheme,\\nand finally the configuration and the target.\\nSo you're picking which type of simulator you want it\\nto run on, and it says before launch, build iOS application.\\n\\nAll this stuff should be fine.\\nSo I'm going to hit okay and now I can run it for iOS.\\nNow you're going to have to make sure you run X code\\nbefore you do this, most likely\\nbecause you have to accept the license terms\\nor X code will not allow it to run the simulator.\\nIt's now installing the simulator\\nand here it is starting up the simulator.\\nIt's going to then immediately\\nrun the app in our new iPhone simulator.\\n\\nIt's also possible to choose devices as targets,\\nand as you can see, I click here.\\nIt's got Hello iOS.\\nThis is coming from the iOS specific code that's right here.\\nSo now that we know how to run code against each platform,\\nwe should look into the features\\nthat Empower Kotlin Multiplatform\\ndevelopment in Android studio.\\nFirst, we need to get our minds into the gutter.\\nThat's the IDEs gutter, that is.\\nThe gutter is the area just\\nto the left of the main editor window.\\n\\nLet's look at platform KT in the common main code.\\nYou'll notice an A with a diamond\\nsurrounding it in the gutter.\\nIf you click on it, it allows you to travel quickly\\nto the different actual fun.\\nGet platform calls for each platform.\\nIf you tap on the E\\nwith the diamond surrounding in the gutter,\\nthen you'll return to the Expect fund,\\nso it will cover actual and expect a little more\\nin a later video.\\nLet's say we want to delete one\\nof the actual functions.\\nYou'll notice that the word expect\\ngets a red underline if we do that.\\n\\nIf you tap on it and hit option return\\nto do the IDE Quick fix,\\nit'll give you the option to create the missing function\\njust like that.\\nThe same thing implies to the interface.\\nHere you can tap on the eye to get to the implementations\\nof the interface, and if you tap on the eye again,\\nit will take you back.\\n\\nIf you want to go backwards\\nand forwards on a Mac, you can do command option left arrow\\nand right arrow, just like that.\\nYou can also do cross platform refactoring, so let's try\\nto rename the Expect Fund, get platform function\\nright here.\\nSimply right click the name of the function,\\nchoose refactor, and then rename.\\nIf you're using a track pad, you can also right click\\nby tapping with two fingers.\\nNow, if we type the new name of the function\\nand you'll see that all the actual funds have also been\\nrenamed, as you can see, all of these are now the same.\\n\\nThe same goes for interfaces across the platform boundary,\\nexcept that you may need to check check boxes in the\\ndialogue to ensure they're renamed properly,\\nand then you can select all and then hit okay.\\nThe same goes for refactoring to change the signature\\nof the Expect Fund function.\\nYou'll find that most refactorings simply work across these\\nplatform boundaries as long as you use a Kotlin\\nmulti-platform aware IDE like Android Studio.\\n\\nSo here I can change the signature\\nand just add something new to it,\\nand there I've added a string\\nand you'll see each of the functions\\nnow has a string added to it.\\nSo there you go.\\nAndroid Studio is definitely aware\\nand will empower your cross-platform development.\\nI recommend it for now until they get IntelliJ working\\nwith all of these new features.\\nIt's probably your best option.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6057317\",\"duration\":252,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Xcode for KMP\",\"fileName\":\"2724070_en_US_01_06_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":351,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":true,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Synthesize an initial multiplatform project ready to run.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":9035362,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] If you're building an iOS app with KMP,\\nyou should know how to use Xcode to empower multi-platform\\nand development with Kotlin.\\nYou might be asking yourself,\\n\\\"If I have spent all of this energy building an app\\nusing both native iOS languages like Swift and Objective-C,\\nwill I still be able to debug my app in Xcode?\\\"\\nThe answer is yes.\\nTouchlab produced an excellent library\\nthat makes it possible to debug your KMP apps using Xcode\\nacross the Kotlin, Swift, Objective-C boundaries.\\n\\nInstalling the plugin is not difficult on a Mac.\\nYou first make sure you have\\nthe homebrew package manager installed, which I do,\\nso it's actually BrewMan's version.\\nAnd if it's not installed, go to brew.sh\\nand run the one line command there to get started.\\nNext run brew install xcode-kotlin.\\nWhen that's done, simply run xcode-kotlin install.\\n\\nI'll show you, xcode-kotlin install.\\nIt's a yes, attempt to shut it down\\nbecause you want it to restart,\\nand now it's installation complete,\\nit's now running with Xcode.\\nAt this point, you should be up and running.\\nWhenever you upgrade Xcode,\\nit's important to run xcode-kotlin\\nwith the sync command instead of install.\\nAgain, to make sure that you keep your tools up-to-date\\nand working with the latest version.\\n\\nNow that you have the plugin installed,\\nyou can now add references to your Kotlin code\\nto your iOS project inside of Xcode.\\nI can open my project in Xcode.\\nBe sure to set the option so it doesn't copy the files,\\ninstead references them in place.\\nAlso, don't add them to a target\\nsince that will attempt to package them redundantly.\\nSo I will go here, I would say Add Files to iOS app,\\nand I can go to composeApp, src, commonMain.\\n\\nI think that's correct, src like that. Hit Add.\\nDo not copy, reference them in place,\\nand do not add them to targets.\\nYou do want to create groups.\\nSo now you can actually see all of your common Kotlin source\\ninside of Xcode,\\nand it will be able to handle it\\nwith syntax highlighting and everything working here,\\nas you can see.\\nAll of these Kotlin files are now searchable\\nfrom inside of Xcode.\\n\\nNow we can set break points in our Kotlin code\\nand debug both Kotlin and Swift code from within Xcode.\\nWhen it comes time to actually run your project from Xcode,\\nit should be pretty simple.\\nChances are that if you have a simulator already installed\\nand selected when you open your project,\\nyou can simply press the Run button.\\nYou might need to first select\\nthe correct target at the top,\\nonly if there's more than one.\\nRight here.\\nHowever, oftentimes the only setup required\\nis to set a team for signing purposes\\nunder your target's signing capabilities tab,\\nwhich you click here on the project,\\nyou then would go here, select the target, which is the app,\\nand then click Signing Capabilities.\\n\\nAnd here you would add a team.\\nAnd this is going to require\\nsigning into your Apple account and all of that.\\nBut right now it's actually installing and working.\\nI recommend creating a team\\nand getting everything working.\\nHere it's launching and it's going to fire up\\nthis iPhone 16 Pro simulator right here.\\nWhich will go to the main screen and then install the app,\\nand finally, I can click, and it's working.\\n\\nI'll see you in the next video.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6062031\",\"duration\":85,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Crafting a template with the Kotlin Multiplatform wizard\",\"fileName\":\"2724070_en_US_01_07_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":109,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":true,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to create a template using the KMP wizard.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2498441,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] To write our first code,\\nwe should start from a template.\\n\\\"Why not just get started writing?\\\" you might ask?\\nThere is a lot of custom setup\\nto select which platforms to support\\nand the directory structure required\\nis quite complex to create it all from memory.\\nSo, to avoid creating all of this boilerplate,\\nfirst, let's go to the URL kmp.jetbrains.com.\\nAfter that, we can name our project\\nwith a title and a project ID.\\n\\nNormally, a project ID is in reverse DNS notation.\\nSo if our project is named hello,\\nand our internet domain is example.com,\\nwe would make the ID com.example.hello.\\nIn this case, it's com.callingtheshots.project.\\nNext, let's select which platforms we would like to use.\\nThe template supports Android, iOS,\\nDesktop, Web, and Server.\\nLet's choose all except server for now.\\n\\nYou'll notice that the iOS platform lets you decide\\nwhether or not to share the UI using Compose Multiplatform.\\nLet's leave that checked for now.\\nFinally, let's press the DOWNLOAD button.\\nWe now have a functioning app,\\na very basic app that runs across all of these platforms\\nand we can decompress it.\\n\"}],\"name\":\"1. Creating Our First Multiplatform App\",\"size\":57516934,\"urn\":\"urn:li:learningContentChapter:6065006\"},{\"duration\":1545,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:6063008\",\"duration\":283,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Building our first multiplatform app\",\"fileName\":\"2724070_en_US_02_01_VT\",\"demo\":true,\"videoCreationMetadata\":{\"rawDurationSeconds\":626,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Produce your very first KMP app running across a variety of devices and simulator targets.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":10383657,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Narrator] In this video, we'll take a hands-on approach\\nto building your first multiplatform app,\\nguiding you through the process of using\\nthe custom template that you just downloaded.\\nBy the end of this session, you'll have a working app\\nrunning on multiple platforms\\nand a clear understanding of how to make impactful changes\\nto its functionality.\\nFirst, let's open the template that you just downloaded.\\nYou'll need to uncompress the zip file into a directory.\\nIn most cases, you can double-click the file\\nin the file manager of your operating system,\\nand this will start the process.\\n\\nNext, we're going to open the project\\nfrom within Android Studio.\\nIf needed, we may be required to allow permission\\nto let it build the project.\\nThen we want it to Gradle sync\\nand choose the project view instead of Android,\\nwhich is what we always use\\nfor Kotlin Multiplatform development.\\nFirst, I'm going to go into the Gradle directory\\nand update some versions.\\n\\nThis should be 8.11.1.\\nIt's the current today,\\nand we'll update these to the current latest, 8.9.1.\\nIf you hit Option + Enter, you can change\\nto the latest version of each\\nand then Gradle sync and wait for it.\\nIf you press the elephant button up here,\\nthat will sync your project with the Gradle files.\\nIt will also, if you've changed the Gradle files at all\\nfor a sync now option with the button at the top,\\nand this is fine at the bottom there.\\n\\nNow we are going to add any missing run configurations.\\nI'll go to edit configurations, add, application,\\nwe call it Desktop,\\nselect the Java version, desktopMain,\\nthe main class, and hit OK.\\nAnd then we'll add the web assembly version,\\nwhich is Gradle.\\nWe call this Web, and this has to be exactly this,\\nwasmJSBrowserDevelopment, which is the branch we're running,\\nthen Run -t, just like that, and hit OK.\\n\\nNow one by one, we can run each of these targets.\\nYou try to run them all at once,\\nyou may run into some problems, so we're going to wait\\nuntil the emulator starts to start the next one.\\nAs you can see, I've got Android running here.\\nClose that now.\\nHere's JVM.\\nSays Hello, Java.\\nThis is running in Mac OS right now.\\nI am going to then run web.\\nHere's web running, and now I can actually run iOS last.\\n\\nAnd there's iOS.\\nOkay, I'm now running all four projects side by side.\\nNow you may notice I ran into some problems earlier on\\ntrying to build and run all four of them at the same time.\\nIt does seem that there is a issue in Android Studio\\nwhere it doesn't seem to want to execute all four at once.\\nYou may need to try potentially stopping a task\\nto start another and see if that helps.\\nBut right now I have all four running\\nand I can now demonstrate\\nhow you would add some changes to your project.\\n\\nSo after going through the steps for each platform,\\nwe should have our project running on Mac OS,\\nan Android emulator, an iOS simulator, and a web browser.\\nIf your device is not running Mac OS,\\nyou can instead run only on Android, web,\\nand your desktop operating system.\\nLet's make a small change to our project\\nand observe that the results have changed in each.\\nAs you can see, I now have all four running at once.\\nI have made a small change and changed the text\\nto read Hello LinkedIN Learning! in the shared code,\\nand it's reflected in all four.\\n\\nYou've now seen how to set up, run,\\nand customize your first Kotlin Multiplatform app\\nusing the custom template.\\nBy following our steps, you successfully built\\na very simple project for multiple platforms.\\nAdditionally, you made a small change\\nand observed its impact across all of the platforms,\\nreinforcing the power of this shared code.\\nWith this setup complete, you're ready\\nto dive deeper into Kotlin Multiplatform development\\nand we're going to explore some more advanced features.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6062029\",\"duration\":194,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Whether to use Compose Multiplatform\",\"fileName\":\"2724070_en_US_02_02_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":214,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":true,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Find out when it's best to either share UI views and when it's best to write custom per-platform logic.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":5075127,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Let's look at what\\nCompose Multiplatform offers,\\nits benefits, and its limitations,\\nand how to decide if it's the right choice for your project.\\nCompose Multiplatform has its origins\\nwith the user interface framework Jetpack Compose.\\nJetpack Compose was written by Google\\nfor Android developers.\\nIt shared some of the same main developers\\nwho originally wrote React.\\nI feel Compose has a wonderful developer experience\\nfor writing user interfaces in a declarative manner.\\n\\nIt's fast, and it's easy to work with.\\nCompose Multiplatform is a user interface library\\nwritten by JetBrains,\\nbased upon Jetpack Compose for Android.\\nThey figured out a neat trick to treat every platform\\nas if it was an Android screen,\\nsimply by porting the Android graphics library Skia\\nto each of these platforms.\\nThey call it Skiko for Skia Kotlin.\\n\\nWhile it's obvious that writing all\\nof your user interface code once may save you a lot of time,\\nthere are reasons why this may not be a good idea for you.\\nUsing the same UI in all apps\\nmay mean that your Android app looks identical\\nto your iOS app,\\nand your desktop and web apps.\\nThis may seem favorable to some,\\nbut it also means that the controls\\nmight not look like the native controls for that platform.\\nThis might cause some confusion,\\nas icons and appearances are not the same\\nas users would normally expect.\\n\\nYou might find that some animations behave differently\\nor require custom tweaking.\\nYou can get around some issues\\nwith the special KMP libraries,\\nbut a Compose Multiplatform app\\nstill may not appear the same on iOS, for example,\\nas if you had written it using SwiftUI.\\nAlso, if you work for a larger company,\\nyou might have existing development teams\\nand investments into the native user interface libraries.\\n\\nIn this case, it might make sense\\nto reuse existing user interface code\\nand to only replace the code sections\\nwith shared Kotlin code when it makes sense.\\nA lot of larger companies share business logic\\nbetween Android and iOS apps with Kotlin Multiplatform,\\nwhile still using Jetpack Compose on Android\\nand SwiftUI on iOS.\\nHere's some examples.\\nCompose Multiplatform can offer a huge savings in cost,\\ntime, and administrative overhead.\\n\\nHowever, you must consider\\nif a seamless native user experience\\nmay be more important to your organization\\nthan those savings.\\nKotlin Multiplatform has the ability\\nto empower both hybrid Compose\\nand per-platform native user experiences,\\nYou can mix and match to your heart's content.\\nUsing your new skills in KMP,\\nthe choice is ultimately yours.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6064009\",\"duration\":174,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Expect and actual\",\"fileName\":\"2724070_en_US_02_03_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":203,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":true,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn about the essential Kotlin keywords \\\"expect\\\" and \\\"actual\\\", which are the crux of KMP.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":4954325,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] So far we've used a template\\nto modify existing code to work on multiple platforms.\\nHowever, we haven't really explained\\nhow Kotlin Multiplatform works.\\nUnder the hood,\\nthere are two special Kotlin language modifiers,\\nwhich were added to the core Kotlin language\\nback when KMP was added to Kotlin in 2017.\\nThese are expect and actual.\\nWhen we write expect in Kotlin,\\nwe're telling the compiler that we want\\nto create an interface.\\n\\nHowever, unlike interfaces in most languages,\\na Kotlin expect interface is expected\\nto have an actual implementation for each platform.\\nWhen we write actual in Kotlin, we're telling the compiler\\nthat this is the actual implementation\\nof the interface we told the compiler\\nto expect earlier.\\nThe compiler can then look\\nat the project directory structure\\nto determine which platform\\nthis actual implementation serves.\\n\\nNow, as I said, expect and actual both create\\nand satisfy an interface.\\nHowever, they're also more powerful than interfaces\\nor protocols in most languages.\\nIn fact, there are\\nat least seven different language constructs\\nthat can be used with expect and actual in Kotlin.\\nYou can use expect and actual with functions,\\nproperties, objects, type aliases, enums,\\nannotations, and now even classes,\\nwhich is a new beta feature in the language.\\n\\nExpect and actual classes should become stable soon,\\nbut may change slightly before they're considered final.\\nThis is what an experimental feature means\\nin the Kotlin world.\\nDoesn't mean that they're not usable yet,\\njust means it might change a little bit.\\nYou don't need to know how to use all\\nof these different types of expect\\nand actual to begin using Kotlin Multiplatform.\\nIn fact, you can do most things\\nwith only expect and actual functions and properties.\\n\\nAll of the others are just there simply\\nto make Kotlin Multiplatform more convenient.\\nNot only can you use expect and actual\\nwith functions and properties,\\nbut you can make the return types different\\nfor each actual statement.\\nYou can return an interface\\nthat has a different implementation for each platform.\\nThe main point I want to get across is that expect\\nand actual are very powerful keywords in Kotlin.\\nYou can use them\\nto provide platform specific implementations\\nof a great number of things.\\n\\nThese built-in language features are a big reason why Kotlin\\nis possibly the most powerful multi-platform language today.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6057319\",\"duration\":324,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"An actual example\",\"fileName\":\"2724070_en_US_02_04_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":436,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"Exercise Files > Chapte02 > 02-04\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to apply \\\"expect\\\" and \\\"actual\\\" with an example.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":11806331,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] In the last segment,\\nI gave you an overview of the expect\\nand actual keywords in Kotlin,\\nbut now it's time for a brief demonstration.\\nI will show you an example\\nof using different implementations for each platform\\nfor Kotlin property and function.\\nFirst open your template project again in the IDE.\\nYou'll need to wait for it to fully sync\\nbefore every feature works as expected.\\nFor starters, let's try a property.\\n\\nLet's open the template project and go to the shared folder.\\nTypically, this code sits\\nunder commonMain slash kotlin\\nfor your app or library module.\\nYou need to use the Project view, not the Android.\\nSo here we have my shared code for my project.\\nYou'll notice the existing code here already\\nhas some expect and actual functions.\\nLet's delete the existing Greeting.kt code and start over.\\nDelete all but the package statement.\\n\\nHere we're going\\nto add expect val_world: String\\nand expect fun platformFunction.\\nAs you type these lines,\\nyour IDE will likely underline the names in red.\\nDon't worry about this yet.\\nThis is just here to remind you\\nthat you haven't yet written\\nthe actual implementations of these functions.\\nIf you click the red underlines\\nand hit Option + Enter,\\nthere's an option to add the missing actual declarations,\\nand you can then select each one\\nthat you want to support\\nand press OK.\\n\\nAnd I can then do the same thing here with the other one.\\nAdd missing, Desktop, Android, iOS,\\nand WebAssembly.\\nNow you select all the platforms you want\\nthe implementations for on that quick fix screen.\\nYou can choose iOS main instead\\nof the individual check boxes for each\\nof the different iOS targets, for example,\\nthis works because KMP uses a hierarchical approach,\\nso you're not forced\\nto write multiple implementations\\nwhen it does not make any sense.\\n\\nAfter you click through to this screen,\\nthe IDE will create files for each platform\\nand will leave the implementation\\nas TODO, Not yet implemented.\\nTODO is a built-in Kotlin function\\nthat will crash your app\\nwith that TODO message if you try\\nto run it without writing the necessary code.\\nThis crash is deliberate to remind you\\nto finish your code before checking it in\\nand sending it off to production or to a client.\\nYou can also find all TODOs\\nin your code using the TODO tool window\\nin most JetBrains IDEs.\\n\\nSo that would go Tool Windows\\nand then look for TODO,\\nand it found four TODOs,\\nas you can see.\\nLet's define the actual val greeting\\nto four different values depending upon the platform.\\nLet's go to Android here for world, we're going to say,\\n\\\"Let's do the robot, Android!\\\"\\nWe're going to go to desktop,\\ngoing to say, \\\"Let's click around, desktop!\\\"\\nAnd iOS will do,\\n\\\"Let's take a bite\\nof the apple, iOS!\\\"\\nFinally, go to WebAssembly,\\nwe're going to say,\\n\\\"Let's rock the web, WASM!\\\"\\nWe're going to have to change some code here.\\n\\nSo if I go to shared code,\\nwe need to change this greeting here\\nfrom Greeting.great\\nto the new property called world.\\nYou'll see it turn purple.\\nIf I run this on any of the platforms, it should work.\\nI run for Android here.\\nIf I click here, it says,\\nCompose: Let's do the robot, Android!\\nSo, and likewise,\\nif I pick any other one of these, let's do web.\\nWe should see the web version.\\n\\n\\\"Let's rock the web ,WASM!\\\"\\nThere we go.\\nCompose: Let's rock the web, WASM!\\nSo there we go.\\nWe've implemented an expect\\nand actual val returning a string.\\nSo as you can see, expect val is used\\nfor setting a value such that the result could\\nbe different per platform and calculated differently.\\nWhat if we simply wanted\\nto run a function that works differently\\nfor each platform?\\nYou could use a side effect of expect val,\\nbut that will be unexpected and awkward.\\n\\nSo instead, we're going to use expect\\nand actual fun in this case.\\nYou should expect fun in the next video, (laughs)\\npun intended, we're going\\nto start calling platform-specific APIs\\ndirectly from Kotlin.\\nWe'll make our app move around in unique ways\\nfor each individual operating system.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6065003\",\"duration\":282,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Accessing operating system methods\",\"fileName\":\"2724070_en_US_02_05_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":397,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"Exercise Files > Chapte02 > 02-05\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Discover how to call the operating system methods of your platform directly from Kotlin code.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":11768975,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] In this video, we're going to call methods\\nor functions that are specific for each operating system,\\nbut we're going to make that call from shared code.\\nYou see here, I have created a platform function\\nwith expect fun, and I gave it the composable annotation.\\nThis makes it a Compose Multiplatform function,\\nso then we can actually make this call from Compose code\\nand also take advantage of some of the Compose methods.\\nSo we're going to use this expect fun\\nto create a function interface that we satisfy\\nwith a different Kotlin function for each platform,\\nso let's take a look at Android here.\\n\\nStarting with Android, we create a sequence of toasts,\\nso toast is a system message\\nthat briefly appears over the top of our app,\\ncovering everything underneath it.\\nIn this case, we define our platform func\\nto show two different messages\\nwith the Toast.makeText method, which only Android supports,\\npassing in the Android context\\nthat we get from the composable,\\nso LocalContext.current is the way, in Jetpack Compose,\\nthat you can get Android's context.\\n\\nHere, we're passing into a launched effect,\\nwhich allows you to use coroutines to run normal code\\ninside of Compose rather than view code,\\nand so here, we're in a coroutine,\\nlooping forever while true,\\nmeaning we continue this loop until the end of time\\nunless this is no longer visible, which we'll show,\\nand Toast.makeText is going to spit these two messages out\\nwith a two second delay between each of them,\\nso this is going to show the two messages\\non repeat for Android.\\n\\nSo let's take a look at iOS.\\nFor iOS, we changed the background color\\nof our app's root window controller, as you can see here.\\nTake the key window.\\nWe're using the UI application method,\\nwhich is built into iOS, into the operating system,\\nand shared application with key window,\\nrootViewController.view, and from that,\\nwe can set the background color back and forth\\nevery two seconds.\\n\\nThis code will cycle back and forth between a cyan color\\nand a yellow color background.\\nNext, we go to desktop.\\nFor desktop, we're going\\nto use Compose Multiplatform method\\nthat only works on desktop.\\nWe're going to create a dialog window on the screen\\nwhere the message in dialog for the title cycles\\nbetween two different messages.\\nAgain, we're using the launched effect with while true.\\nEvery two seconds, we change it\\nbetween the two marquee slogans.\\n\\nFinally, we go to WebAssembly.\\nAgain, WebAssembly, we're going to use a platform access\\nto the browser's JavaScript to the document.title\\nthat allow us to change the title of the webpage.\\nI'm going to show this in Chrome,\\nbecause if I show it in Safari,\\nit doesn't show you the title,\\nso we're going to go back and forth every two seconds\\nbetween the two messages.\\nAs you can see, using Kotlin Multiplatform,\\nyou can make calls to specific messages\\nfor each operating system on each platform\\nwhile keeping the main majority of your codebase\\nstill shared and still reusable,\\nand I'm going to demonstrate that quickly here.\\n\\nSo let's take a look at Android.\\nHere we go.\\nYou see here that this is the messages\\ngoing back and forth every two seconds.\\nIf I close it so the view is no longer visible,\\nthese will stop.\\nThere we go. Okay, so that's Android. iOS.\\nSee, the colors are going to change in the background here,\\nback and forth, and then we're going to check out web.\\n\\nI'm going to open this instead in Chrome,\\nand you'll notice the title changing right there.\\nEvery two seconds, good,\\nand finally, we're going to test desktop,\\nand the title of the window's changing there.\\nSo we've just demonstrated\\nhow we can run the platform functions\\nof the operating system directly from actual functions\\nand then calling it from shared code.\\nThis approach not only simplifies\\ncross-platform development, but it also ensures\\nthat platform-specific features integrate cleanly\\ninto your app.\\n\\nKotlin Multiplatform enables you to write maintainable code\\nwhile leveraging the unique capabilities of each platform.\\n\"},{\"urn\":\"urn:li:learningContentVideo:2744003\",\"duration\":288,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Multiplatform project structure\",\"fileName\":\"2724070_en_US_02_06_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":330,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":true,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Diagram how a KMP project is laid out and where all of the code needs to go.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":10961235,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Now that we've looked at a bit\\nof Kotlin Multiplatform code,\\nwe should familiarize ourselves with the project structure\\nthat makes it all possible.\\nLet's take a look at our template\\nand identify each location where the different code goes\\nfor each platform and for shared code segments.\\nThe template keeps all of its Kotlin code\\nwithin a single module named composeApp.\\nAll of its Kotlin code lives under composeApp/source\\nin different folders with special names.\\n\\nShare code always lives under a folder named Common Main.\\nUnder this folder, there's a folder for composed resources\\nand for Kotlin code.\\nResources folders are used to store images,\\ntranslatable strings, plurals fonts, raw files,\\nthat sort of thing.\\nThe Kotlin folder contains the actual shared code\\nwith the keywords and code references to software libraries\\nthat provide shared code implementations\\nin Kotlin Multiplatform.\\n\\nIn addition to the shared code folder, common Main,\\nwe'll have another folder for each platform\\nor closely related group of platforms.\\nFor example, iOS here is a group of platforms.\\nIt includes ARM 64 for most actual iOS devices,\\nand ARM 64 simulator, or x64 simulator for simulator\\nis on Intel devices.\\nBecause iOS is actually a group of platforms,\\nit sometimes makes sense to share code across all of iOS,\\nand sometimes it makes sense to make different code\\nfor each architecture.\\n\\nYou might want to use the more specific architectures\\nif you're calling code that only works in that architecture.\\nLikewise, we can share code for all JVM platforms\\nthat use methods specific to the JVM,\\nor we can create code under Android\\nand desktop that are more specific than the JVM.\\nEach time we create both expect\\nand actual implementations, we can decide for ourselves\\nas a programmer which level is most appropriate\\nto create our actual code implementation at.\\n\\nOtherwise, each specific platform has its own code\\nin directory name platform main.\\nFor example, desktop is Desktop Main.\\nAndroid is Android Main.\\niOS is iOS Main for all iOS platforms, device,\\nand simulator on all architectures.\\nBut you could get more specific like iOS simulator,\\nARM 64 main or less specific like Apple Main,\\nwhich also supports Watch OS and Vision OS.\\nWeb has wasmjsmain,\\nwhich supports writing both web assembly\\nas well as JavaScript code from Kotlin.\\n\\nYou might wonder how Kotlin knows\\nwhich platforms you're supporting.\\nAll of these settings are defined\\nwithin the standard build system called Gradle.\\nYou can also try Amper instead of Gradle,\\nbut that build system is still very new\\nand less tested with complex configurations.\\nIn Gradle, you would look in the main module directory\\nfor a file called Build Gradle.kts.\\nWithin the Kotlin block, right here,\\nyou'll see multiple targets defined.\\n\\nOurs has wasmjs, Android Target,\\nDesktop, which in this case is a JVM target\\nand iOS target.\\nWe also define a desktop target\\nby naming our separate JVM Target Desktop,\\nas you can see here.\\nSo you've seen that you can place your code\\nin different folders for each module\\nto support different platforms.\\nThis doesn't really demonstrate\\nhow useful Kotlin Multiplatform is though.\\n\\nWhat really makes KMP exciting is the plethora\\nof useful libraries that provide both the expect\\nand the actual code for us to use.\\nBy using these libraries,\\nwe can access the network, store data in databases,\\nkey platform settings and key value stores,\\nmanage dates and times, handle dependency injection\\nacross platforms, and provide resources for all platforms.\\nIn the coming videos, I will demonstrate\\nsome of these libraries that provide all of the code\\nfor each platform for you,\\nand I will show you\\nhow they will make your work much easier.\\n\\n\"}],\"name\":\"2. Combining Native with Multiplatform\",\"size\":54949650,\"urn\":\"urn:li:learningContentChapter:6062033\"},{\"duration\":751,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:6065005\",\"duration\":279,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Using Kotlin from Swift code\",\"fileName\":\"2724070_en_US_03_01_VT\",\"demo\":true,\"videoCreationMetadata\":{\"rawDurationSeconds\":392,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"Exercise Files > Chapte03 > 03-01\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":true,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to provide a function from your Kotlin code to your Swift code.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":10752082,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] The Kotlin native code generator was designed\\nto interoperate seamlessly with Objective C code,\\nApple's original language of choice.\\nHowever, most developers who write code today\\nfor Apple devices use the Swift programming language,\\nwhich offers more modern features than Objective C.\\nThis video demonstrates\\nhow you can call Kotlin functions from your Swift code,\\nand how you can handle Kotlin types from return variables.\\n\\nKotlin has top level functions\\nand properties that can be called from anywhere.\\nThese get mapped to Objective C\\nand to Swift by using the Kotlin file name.\\nFor example, a function,\\ncalled Expect Fund platform function,\\nand a file called Greeting KT would be called,\\ngreetingkt.platform function in Swift.\\nYou can simply call the function in Swift\\nby passing any appropriate arguments.\\nSo let's try creating a new platform function here\\nthat does not depend on compose multi-platform\\nor Jetpack compose.\\n\\nSo now we have to implement it for all of our platforms.\\nIt's already in web assembly.\\nAnd here for iOS, I'm going to implement it.\\nI'll put it on the IO dispatcher so\\nthat it can run without blocking the main thread.\\nCopy the same code here,\\nand then here, we'll launch this to the main dispatcher\\nso that we can use the main thread, which is required\\nto make UI updates on Android or iOS.\\n\\nThere we go.\\nSo now we have this new call platform func,\\nand we're going to go over to Xcode\\nand add it to our Swift code.\\nFirst. We should probably remove this from our shared code.\\nI've done this right here.\\nI made it commented out, and then I go over to Xcode.\\nSo just to show you here, if I start typing,\\ngreeting.kt, it auto completes it,\\nand if I put platform func, should find that as well.\\n\\nLooks like it hasn't built yet,\\nso I might need to temporarily hold off and build.\\nI'd say, greeting_ioskt.platformfunc.\\nAnd now it found it.\\nNow you're going to see that when it builds and runs,\\nthe simulator is going\\nto show the background changing\\nbetween teal and yellow again.\\nIf I remove this, run it again, it won't do that.\\n\\nSo you've just demonstrated how\\nto directly call our code\\nfrom the Swift code, for our Kotlin code.\\nYou'll notice that we can make calls directly\\nfrom Swift to Kotlin.\\nWhile this is impressive and looks easy,\\nthe hard part is usually designing the types\\nof return values, such that it's easy\\nto map from Kotlin types to Swift types.\\nIf you want to learn how\\nto do anything specific in Swift from Kotlin code,\\nI recommend looking up the language construct you're trying\\nto use within the Kotlin Swift interopedia.\\n\\nIt can answer any questions about what is supported out\\nof the box and how best to use it.\\nFor example, Kotlin seal classes\\nand Swift's enum classes are often compared\\nand they work quite similarly.\\nHowever, Kotlin seal classes aren't neatly translated\\ninto Swift's enums simply\\nbecause Kotlin code is interpreted as Objective C,\\nwhich has no similarly advanced concept.\\nHowever, there are a couple easier ways\\nto use Kotlin from Swift.\\n\\nFirst, a consulting company, called Touch Lab,\\ncreated a third party library called Skie.\\nThis library inspired an official Kotlin,\\nmulti-platform support library, called Swift Export.\\nThese solutions provide easier translations between Kotlin\\nand Swift, such as Seal classes and co-routines.\\nWe'll dig deeper into this, in the next video.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6062030\",\"duration\":281,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Making it easier with Swift export\",\"fileName\":\"2724070_en_US_03_02_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":366,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"Exercise Files > Chapte03 > 03-02\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Discover how to code a user interface entirely with SwiftUI calling Kotlin methods.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":10887894,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] In our previous video,\\nwe called our Kotlin code directly from Swift.\\nHowever, there are some small issues\\nthat may become annoying to Swift developers\\nhaving to use our Kotlin code.\\nWe discuss Kotlin Sealed classes as one example of a type\\nthat will be difficult to work with\\nin traditional Kotlin Multiplatform code.\\nIn this video, we'll discuss the solutions to make KMP code\\nmuch easier to integrate for Swift developers.\\nAfter KMP came out and developers discovered\\nsome minor difficulties with certain aspects\\nof the integration between Kotlin and Swift,\\na KMP consulting company called Touchlab\\nrealized that there could be a commercial opportunity\\nin making it all easier.\\n\\nIn fact, this is the same company\\nthat wrote much of the documentation for KMP.\\nThey wrote a product called Touchlab SKIE, S-K-I-E,\\nwhich used compiler plugins to rewrite the code interface\\nto be much easier to use along with Swift code.\\nThis would help developers use Sealed classes,\\nas Swift enums and Kotlin coroutine code\\nfrom either combine or async/await.\\nAfter a while, they decided to open source this product,\\nmaking a once costly library available for free.\\n\\nAnd today, you can use it for your own code.\\nHowever, even though Touchlab SKIE\\ncan solve these problems for you,\\nand it's a very viable solution,\\nthe core Kotlin team used the SKIE library\\nas inspiration to create an official library.\\nEven though it's still young\\nand could change in the coming months,\\nI recommend learning to work\\nwith the new official Swift Export Library for KMP.\\nWhile we could work with our existing project template,\\nit seems Swift Export and Compose Multiplatform\\naren't compatible just yet.\\n\\nSo, let's open a special Swift Export sample code instead,\\nand I'll explain it.\\nYou'll need to use Kotlin version 2.1.0 or newer\\nas I have here in the gradle/libs.versions.toml file.\\nYou'll also need to set experimental setting\\nin the gradle.properties file,\\nkotlin.experimental.swift-export.enabled=true.\\nThis setting will eventually become default,\\nbut we're adding it here today\\nto say that we want to use the new feature.\\n\\neven though some details may change.\\nExperimental language features in Kotlin\\ndon't mean that they're broken\\nor that they're going to blow up.\\nWe're signing onto the idea that any app that we write today\\nmay require code changes one day\\nif we upgrade the version of Kotlin,\\nand if the feature is implemented differently\\nin the final version of that language feature.\\nAfter doing that, we're going to need\\nto add a swiftExport block\\nto the project/shared/build.gradle.kts file\\nfor the shared code.\\n\\nHere we have the swiftExport Block.\\nJust be sure to use the quick fix when you create it\\nto import ExperimentalSwiftExportDsl OptIn\\nor none of this will work when we try to build.\\nAlso, make sure that the module name\\nmatches its old name, Shared in this case,\\nand the flattenPackage structure\\nshould mimic your project structure.\\nHere it's com.github.jetbrrains.swiftexport.\\nAt this point, you should gradle sync.\\n\\nYou can press the Elephant or the Sync Now button\\nif that appears,\\nand it should reimport the Gradle script\\nand pick up any changes you've made.\\nFinally, you may want to open the Project X code\\nand verify that the correct build phase is getting used.\\nThis is so that Swift Export gets called\\ninstead of exporting\\nour shared code framework to Objective-C.\\nNow let's look at the actual Kotlin code usages and X code.\\n\\nIf we open ContentView.Swift\\nand command click on useClassFromA here,\\nwe'll dive into the shared code framework.\\nI have to wait for it to build first.\\nThere it is, useClassFromA.\\nAs you can see here, the exported framework\\nis written in Swift instead of Objective-C\\nas it usually would.\\nFrom here, we can add any custom code we want,\\nincluding using Sealed classes\\nthat convert to enums from Kotlin to Swift.\\n\\nAlso, I'm confident that a solution will be found\\nto allow using Composed Multiplatform code eventually\\nwithin Swift Export modules.\\nUntil that time, we can still use Swift Export as of today\\nto provide business logic to our application.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6065000\",\"duration\":191,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"KMP together with SwiftUI\",\"fileName\":\"2724070_en_US_03_03_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":243,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"Exercise Files > Chapte03 > 03-03\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Find out how Swift Export makes calling Kotlin methods easier.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":10203822,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] In the last video, we learned one new way\\nto make the integration easier\\nbetween Kotlin and Swift.\\nIn this new video, we'll use Kotlin together with Swift UI.\\nSwift UI is Apple's recommended user interface framework.\\nIt's also declarative like Compose\\nand has a lot of the same nice usability features.\\nWhy would you want to work with Swift UI\\neven when Compose multi-platform is available?\\nMaybe your company already has a lot\\nof highly paid Swift UI developers for Apple products,\\nand they want to produce\\neven if it costs more\\nor has to be redone for an Android Compose app.\\n\\nMaybe you want to use existing Swift UI views\\nthat were custom designed\\nfor the problem that you're tackling.\\nWhatever the case is, there's plenty of support\\nfor using Kotlin together with Swift UI.\\nHere's a webpage that JetBrains provides\\nthat tells you how to use the two of them together.\\nExplains in good detail.\\nIt's a little bit painful, but it can be done.\\nYou can use Swift UI inside of Compose multi-platform.\\nHowever, Touch Lab has actually provided\\ntheir own support library to make it easier\\nto integrate Swift UI from within Compose.\\n\\nIt's called Compose Swift Bridge,\\nand you can check out the sample here.\\nI had to make some little tweaks to it.\\nSo you should check out the actual sample code\\nwe're providing to you in order to make sure\\nthat the Java tool chain is set up correctly\\nso that you can run it.\\nThis is a very big project.\\nIt may take a long time to build,\\nbut it very nicely demonstrates how easy it can be\\nto include Swift UI views\\nfrom within your Compose multi-platform code.\\nHere we can take a look at this map view right here,\\nand you can see there's this ExpectSwiftView annotation.\\n\\nThis is put there for use\\nby the Compose Swift Bridge Library,\\nwhich then goes through as a plugin\\nand will replace this stuff with a version that will work\\nto call Swift UI from inside of Compose very easily.\\nThey actually have several different versions.\\nThey get ut to work with Skie, S-K-I-E,\\nas well as other methods of integrating your views.\\nHere I have the project running\\nwith everything in Compose on Android,\\nand over here we have both a UI kit\\nas well as a Swift UI view here for the map view.\\n\\nAnd this is getting integrated, this native map view,\\ninto this shared code here.\\nSo since I have the same function, new title,\\nI can paste in actual coordinates of where LinkedIn is.\\nI can go ahead and do the same thing over here\\nwith the Android code as well.\\nAnd you'll notice everything works just fine\\neven though I'm using both Compose as well as Swift UI\\nat the same time.\\nSo there you go.\\nThe title isn't showing up,\\nbut that's because it's a different type of view,\\nand it's not showing titles at this moment.\\n\\nSo this is the Google Maps from Android,\\nand this is a different map view from Swift UI\\nthat's highly custom for iOS.\\nThat's Apple Maps, this is Google Maps.\\nIt's all just working natively\\nin exactly the way you'd want it to work.\\n\"}],\"name\":\"3. KMP and Swift\",\"size\":31843798,\"urn\":\"urn:li:learningContentChapter:6057320\"},{\"duration\":560,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:6063007\",\"duration\":184,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Recommended architecture with MVVM\",\"fileName\":\"2724070_en_US_04_01_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":205,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"Exercise Files > Chapte04 > 04\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":true,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to provide the oft-recommended MVVM architecture within a KMP project.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":5286115,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Presenter] Why is software architecture important?\\nI often joke, \\\"Never argue with an app developer.\\nWe're always changing our views.\\\"\\nArchitecture is important\\nbecause the user interfaces in our app\\nare constantly changing,\\nand it's vital to keep them separated from other layers\\nfor a variety of reasons.\\nEver since Microsoft introduced the Model-View-ViewModel\\nor MVVM architecture in 2005,\\nit has consistently been one\\nof the most popular app architectures.\\n\\nGoogle recommends it for Android apps.\\nMost iOS apps also implement it.\\nWe should talk about architecture and why it matters,\\nbut I don't intend to go\\nover all of the options in this course.\\nMVVM makes special sense\\nfor Kotlin Multiplatform development\\nin part because Google publishes\\nopinionated KMP library implementations of this architecture\\nfor both Android and iOS apps, and even desktop and others,\\nbut it is not the only option.\\nFor this section of the course,\\na key question you might have\\nis why is software architecture important?\\nA common answer everyone uses\\nis it makes testing your code easier.\\n\\nBy separating the view from the view model\\nand the rest of your data,\\nit's easier to verify\\nthat each step is producing the correct output\\nthat you would expect.\\nHowever, there is another reason specific\\nto multiplatform development.\\nStructuring your application\\nwill make it easier to verify your code's behavior\\nafter you decide which layers should be shared\\nand which should be customized for each platform.\\nYou want to be able to verify\\nthat all platforms produce the correct answer at each layer\\nregardless of the underlying library code.\\n\\nMost modern software architectures exist primarily\\nto separate the view\\nor the user interfaces from the logic code.\\nThis is important because views can change very often\\nwhenever the design changes,\\nbut the underlying logic\\ngenerally does not change very much,\\nand the logic result should be tested.\\nMVVM creates a simple binding from the model data\\nto the VM model\\nto the view that works very well\\nwith modern declarative user interface libraries\\nlike Compose and SwiftUI.\\n\\nMany useful support libraries have been written\\nto make MVVM easier to implement\\nin Kotlin Multiplatform apps.\\nIt is also important to note\\nthat using a view model makes it easier\\nto change decisions later\\nabout how to implement your user interface.\\nUntil a Compose Multiplatform came out,\\nmost Kotlin Multiplatform apps only use shared code\\nup to the view model layer.\\nBy having a clear separation between layers,\\nit makes it easier to later change your decisions\\nabout which code is shared at which layer\\nand which code is instead unique\\nand customized to each platform.\\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:2744002\",\"duration\":376,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Google ViewModel\",\"fileName\":\"2724070_en_US_04_02_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":587,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Discover how to use Google KMP ViewModel to provide platform-specific view models within an MVVM multiplatform project.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":17459520,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] To support compose multi-platform,\\nGoogle offers the common view model library as part\\nof its Jetpack series of libraries.\\nIn this video, we'll use Google's common view model\\nto share code across platforms.\\nFirst, we're going to go into our project, which I have here,\\nand we have to paste in the Gradle dependency\\nfor lifecycle view model compose\\ninto the dependency section for our app.\\n\\nAs you can see here, I already have it added\\nto my libs versions two ml file.\\nThis is the version number,\\nand here, I use the version number further down right here,\\nand referencing it here.\\nThat's the one.\\nYou have to correctly spell all of this.\\nWe're going to put a link in so\\nthat you can see the documentation for how to add this.\\nIt's right here.\\nYou're basically doing the same thing here,\\nexcept we're just using the Gradle version catalogs\\nto define it, right here.\\n\\nSo we've added the lifecycle view model compose,\\nas well as androidx-lifecycle-runtime-compose,\\nand androidx-lifecycle-viewmodel-android, okay?\\nAnd then we need to add these to our common build,\\nGradle KTS file.\\nSo we come down here, you can see,\\nAndroid has nothing special added,\\nbut we've added all these lifecycle,\\nlifecycle view model, lifecycle runtime compose,\\nlifecycle view model compose, all of them\\nto the common main shared dependencies.\\n\\nDidn't have to touch desktop, iOS,\\nor Android, just the common section.\\nAnd that takes care of that.\\nNow, we should start to create a common view model\\nfor a composed multi-platform project.\\nSo if I go in here, I did create it already,\\nbut we can talk about it, if you're doing this\\nfor your own projects,\\ndon't call it main view model, probably.\\nI mean, it's up to you.\\nI recommend choosing a descriptive file name appropriate\\nto whatever screen\\nor user interface level you're writing for.\\n\\nWe start by declaring a new class extending from view model,\\nwhich is defined as androidx-lifecycle-viewmodel,\\neven though it's a common shared code version\\nof the Android view model.\\nTo use best practices, we create a UI state.\\nThis is a data class typically,\\nand we would expose the UI state\\nwith a public version of the private variable.\\nYou're using the as state flow function.\\nSo we have a mutable state flow\\nand a immutable state flow here.\\n\\nThis creates a stream of updates which,\\neach change we make can be easily observed\\nby our composed code.\\nBecause we used a mutable state flow that we kept\\nas private, it can only be changed by methods\\ninside of our view model.\\nThis is important,\\nbut we can observe a public version instead\\nthat is not modifiable.\\nThis is helpful for encapsulation\\nto prevent external code from becoming dependent\\nupon the inner workings of the view model never changing.\\n\\nBecause let's be honest,\\nour change code is constantly changing,\\nwe're always changing our views.\\nNow let's modify our app KT code here\\nto depend upon our new common view model.\\nYou'll see we have a view model passed into our app,\\nand this is being created by a default value.\\nThis is a default variable.\\nSo this function here is a builder\\nthat creates a view model,\\nand we have to do this special version\\nof the view model function\\nbecause in Android, we can use injection\\nand have it handle it automatically.\\n\\nBut when we're doing this in any other platform,\\nwe don't have all of the components that we need\\nso that this block here has to define our view model.\\nYou could possibly inject it into this block,\\nbut this here has to be where it gets defined\\nfor a common view model.\\nAfter we've added it here, we can then make use of it.\\nHere, we're using the UI state collective state.\\nRemember, UI state, we created as the public,\\nnon-modifiable UI state for our view model.\\n\\nAnd the collective state function is very important\\nbecause it converts our data class here\\ninto a state's data class.\\nSo now, state is one of the core ideas\\nbehind compose, state allows us\\nto automatically observe changes as they occur\\nand update our UI in real time.\\nOkay?\\nFinally, we want to replace the code,\\nupdating the show content variable here.\\nSo we have this view model toggle showing content function\\nthat I defined, and this will update the UI state.\\n\\nThe UI state update function here\\nthat we're calling on our state flow allows us\\nto atomically update the value of our mutable state flow.\\nAnd here, we're using the copy function.\\nThis allows us to change one variable\\nwithout touching any other part.\\nWe don't have to define everything all over again.\\nWe can just say copy it,\\nchange this one parameter and nothing else.\\nAnd so this will autonomically make the update in a way\\nthat won't break when we're working on multiple thread.\\n\\nAnd then this will present the greeting if I go back here.\\nWhen we tap on the button, it will then change the value\\nof the show content variable here to then make this visible.\\nWe're not even using this anymore, so I can get rid of that.\\nSo we present our greeting using state value show content,\\nand then it uses state value greeting\\nto reflect the actual greeting.\\nSo state flow must be unwrapped with the value call,\\nas you see here, to obtain its current value.\\n\\nNow we can run our app\\nand see that the functionality has not changed,\\nbut now we're providing it with a view model that leads\\nto better architecture and better testability.\\nThere it is.\\n\"}],\"name\":\"4. Architecture\",\"size\":22745635,\"urn\":\"urn:li:learningContentChapter:6062034\"},{\"duration\":1248,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:6064006\",\"duration\":304,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Adding Ktor to your project\",\"fileName\":\"2724070_en_US_05_01_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":382,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"Exercise Files > Chapte05 > 05-01\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to integrate the Ktor client libraries into your first KMP app.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":13955843,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] These days, there's hardly a single app\\nthat doesn't need to talk to a network.\\nEven apps that used to only work offline\\nnowadays use the network to check for updates\\nor to send crash reports or analytics data.\\nAs a result, you'll very likely need a solution\\nfor talking to clients or servers over the internet.\\nFortunately, the company that originally made Kotlin\\nalso builds a multi-platform networking library\\nthat works for you as both a client and a server.\\n\\nIt's called Ktor, K-T-O-R,\\nand it supports the HTTP REST protocol\\nthat is most popular on the internet.\\nWe're going to make a good number of changes\\nto our example project in this section.\\nThese changes will make it possible\\nto handle network requests and responses\\nfrom Kotlin multi-platform code using the Ktor library.\\nLet's start from the example project for the section.\\nI'll describe each of the changes that I made in order.\\nFirst, we're going to make changes\\nto our Gradle configuration for the app.\\n\\nAgain, Gradle is the primary build system\\nKotlin uses for most apps.\\nYou need to tell Gradle\\nabout which library dependencies to include in your app.\\nYou start by updating the version catalog first,\\nwhich I have open here,\\nand then you can add the libraries from the version catalog\\nto the build.gradle.kts file.\\nIn order to use Ktor to make REST requests\\nand to parse the results\\nwith the Kotlinx serialization library,\\nwe're going to need to add five libraries.\\n\\nYou can see I added the version here for Ktor,\\nand I have five libraries down below here.\\nThese five libraries are: ktor-client-core,\\nktor-client-okhttp,\\nwhich is a very popular JVM HTTP library,\\nktor-client-darwin,\\nwhich Darwin is a Apple reference,\\nktor-client-content-negotiation,\\nand then, finally, ktor-serialization-json.\\n\\nWe need all of these.\\nAnd then we add as well a new plugin\\nfor Kotlinx serialization.\\nThe plugin will help serialize our types for us\\nto and from JSON, in this case.\\nWe'll also need to provide this build plugin.\\nWe need to provide the version catalog\\nwith the details it needs to access these libraries.\\nWe do so by providing a full module version or name here,\\nas well as a version reference to Ktor.\\n\\nYou can see they're sharing the same version here.\\nIf there were any reason why\\nyou would want a different version of any one of these,\\nyou would need to make a new version reference\\nor just cut this off and then put the version in here.\\nEither way.\\nBecause they're all the same version number,\\nI'm referencing Ktor five times here.\\nThe easy way to find these module names and version numbers\\nis to search for these libraries on GitHub\\nand to copy the module name from either the README file\\non the front page of the library or from its docs.\\n\\nSo we've already entered the names\\nand version numbers here\\nfor the five libraries in one plugin.\\nSo let's focus on the changes now\\nfor the build.gradle.kts file.\\nAgain, this is under composeApp.\\nIt's specific to our app.\\nHere we're looking at the build.gradle.kts file,\\nand we see that the plugins, the very last one here,\\nwe've added our Kotlinx serialization plugin.\\nThis has to be at the top of the file.\\nYou cannot put plugins later down.\\nIt's dependent on the order, and so this matters.\\n\\nThese are also dependent on order,\\nbut, generally speaking,\\nthey seem to not mind being in the wrong order\\nunless it's something that's very, very integral,\\nlike Kotlin, for example.\\nUsually, I just add new third-party libraries\\nto the end of the plugin block.\\nAs we come down here, under androidMain,\\nwe've added the one OkHttp library,\\nwhich provides our Android implementation.\\nDown here under commonMain, for our share code,\\nI added three libraries:\\nktor.client.core, ktor.client.content.negotiation,\\nand ktor.serialization.json, okay?\\nFinally, for iOS, we add the Darwin Library.\\n\\nAnd for desktopMain because we're using JVM for desktop,\\nI'm using the OkHttp library\\nthat works for both Android and for JVM generally.\\nThere we go.\\nSo next we want to make sure\\nthat we have the necessary permissions\\nto reach the internet.\\nThis is important, especially for Android,\\nbecause an Android app\\nwill not function without the necessary permission.\\nHere you can see I added the uses-permission:\\nandroid:name=\\\"android.permission.INTERNET.\\\"\\nIf you don't put that there, nothing will work,\\nand that is just normal on Android.\\n\\nAt this point, we're ready to set up our network models.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6065002\",\"duration\":249,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Modeling with Kotlinx-serialization\",\"fileName\":\"2724070_en_US_05_02_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":310,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Discover how to manage REST network requests when using Ktor in KMP.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":10415267,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Presenter] So after setting up our network client,\\nwe now need to define the models.\\nTo do so, we need to make them serializable.\\nYou'll remember earlier that we set up a build plugin\\nfor kotlinx serialization, as well as ctor libraries\\nfor json serialization and deserialization.\\nI think I'll show you here again.\\nThis is it, as well as at the top here.\\nIt needs both a plugin and the dependency.\\nSo what is Kotlin Externalization?\\nThis is an add-on library for Kotlin provided by JetBrains,\\nfor the purpose of converting data between formats\\nthrough the process of serialization and deserialization.\\n\\nHere, we're going to send Kotlin data classes\\nto our networking library, ctor,\\nwhich our serialization library\\nwill then convert into json to send over the wire.\\nWhen we receive a response back over the internet,\\ncome back as json.\\nWe'll want that JSON deserialized\\nback into our Kotlin data classes.\\nKotlinx serialization generates most of the code for us\\nto do this across KMP platforms.\\n\\nI use the Hacker News API to provide a simple example,\\nsince it does not require us to provide any authentication.\\nHowever, since their json API is polymorphic,\\nwe have to use a sealed interface to define our models.\\nI'll pull that up here very fast.\\nSorry, models here.\\nWe use the Serializable annotations\\nas well as the serial name,\\nand we have to have this null response\\nto handle situations where, for whatever reason,\\nwhat comes back is not of type story.\\n\\nAs you see here, we have this customized serializer,\\nwhich I wouldn't need otherwise,\\nexcept that the API has the capability to return\\nmultiple types of objects in a polymorphic way\\nas a generic data type.\\nSo we had to do some complicated stuff here.\\nFor our code example,\\nWe had to set a serial name for a type\\nto match it by name specifically.\\nNormally, this would be fine without it,\\nbut because of the case difference I had to do this.\\n\\nWe also created a special json content\\npolymorphic serializer,\\nwhich then handles the different types that are allowed\\nfor an item response from the Hacker News API.\\nWe then have to mark every one of these types here,\\nonce, twice, three times, as serializable\\nin order for the Kotlinx serialization build plugin\\nto generate the necessary code to handle serializing them.\\nYou'll notice our data class\\nfor story has all the json attributes here,\\nwhich are returned in the top stories HTTP response.\\n\\nIf we set the isLenient setting\\non our json for ctor library, right here,\\nthen we don't need to include every single one of them.\\nWe can get away with deserializing\\nto a much simpler data class\\nthat does not need to handle every attribute\\nreturned by the API.\\nThis can be very useful if your API\\nis adding new attributes regularly,\\nwhich might otherwise crash your app\\nwhen you're not handling them.\\nYou can be inconsistent as long as you have this set here.\\n\\nUnless they change the names, for example.\\nIt can also be helpful\\nto reduce the memory requirements here\\nfor storing data that we don't use.\\nLike, for example, if we don't need descendants or kids\\nor any of this to display our UI, we could just remove it,\\nand this would all be none the wiser\\nas long as we can pass both ways with their story objects.\\nYou've learned how to serialize kotlin data classes now,\\nto send them over the internet as json,\\nand to handle the json response as a data class.\\n\\nThis library, Kotlinx serialization,\\nalso handles other formats besides json,\\nwhich you can read about on the project webpage.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6064005\",\"duration\":312,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Making network requests\",\"fileName\":\"2724070_en_US_05_03_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":554,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to apply serialization through Kotlinx-serialization to convert JSON into Kotlin classes and back.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":13128673,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Now that we know a bit\\nabout serialization, we want to set up our API.\\nWe need to define an HTTP client.\\nThen we want to create the functions which use that client\\nto send requests and handle the responses.\\nSo let's take a look at this news API.\\nNow, typically we'll want\\nto create our client using dependency injection,\\nbut I wanted to keep this example very simple\\nand easy to read.\\nAt the top of the news API,\\nyou'll notice that we created a client variable.\\n\\nWe gave it the capability to handle JSON serialization\\nby installing the content negotiation module\\nwith the JSON block here.\\nWe are pretty printing and is lenient.\\nThese are totally optional,\\nbut again, as lenient means you don't have\\nto have every single attribute for it to work necessarily\\nunless it's there required.\\nAnd pretty print means that it's going\\nto add all the extra white space to make it easier to read.\\nAfter creating our models, we can write methods\\nto send HTTP requests and to handle responses.\\n\\nHere I wrote a getTopStories method.\\nThis is going to perform http get request.\\nAs you see here, get, client.get.\\nIt's referencing this client\\nand we're calling client.get with a URL string.\\nIt performs an HTTP get request\\nagainst the Hacker News API\\nto get a list of the top stories by their numeric IDs.\\nYou see we return list of long\\nand grabbing from the body from this URL.\\n\\nThen we take the first 10 IDs returns, storiesIDs.take10.\\nThis is a Kotlin stream API here.\\nOnly take the ones that are not null\\n'cause we don't want ones that are not stories,\\nif there were any.\\nAnd finally, return the details of each of the 10 stories\\nas a list, which we get from this URL.\\nSo we're actually making 11 requests here\\nand getting the bodies\\nand returning them as a list of story.\\nNext, let's take a look at our view model.\\n\\nWe made a couple of updates.\\nFirst, we of added a news API,\\nwhich is something we normally, again,\\nprovide via dependency injection.\\nSecond, we've added a suspend function,\\nwhich can run on a background thread\\nor in case like a Kotlin co-routine on a background thread.\\nThe suspend function then calls the news API\\nand updates our UI state with the result.\\nAgain, we're using this update method to atomically\\nupdate the contents of our UI state.\\n\\nAnd here we're calling this news API.\\nYou see here in the gutter, we have this call\\nthat tells you it's a suspend function call, which means\\nthat this is going to suspend execution\\nand it's going to come back later.\\nKeep waiting until it gets past it.\\nBut meanwhile, other code can still run.\\nThis is a function of Kotlin co-routines\\nto have suspend functions like this.\\nSo this will wait here again, jumping in\\nand out of the function, allowing things\\nto run while it gets the top stories from the internet.\\n\\nPrints the results of just the titles,\\nand then update our UI state and showing this content\\nand adding the top stories\\nto the top stories list in the UI state.\\nNow we should take a look at App.kt\\nand our changes to our composed multi-platform UI.\\nYou'll notice we've added a co-routine scope here,\\nwhich allows us to run the code in the background.\\nSo then we come down here.\\n\\nWhen you press the button,\\nit launches a co-routine from this default scope\\nand runs our view model code in the background.\\nSo we'll use the default dispatcher.\\nI would actually normally recommend using the IO dispatcher\\nfor anything that's internet-based, like network request,\\nbut you can get away with this a lot of the time.\\nFinally, we update the animated visibility section down here\\nto show a lazy column containing the titles\\nof the Top 10 Hacker News stories, as you see here,\\ninstead of what we previously showed,\\nwhich is just a static image\\nand some text from our shared code.\\n\\nSo I'm going to run it here on desktop, and I click that,\\nit spits out the current top 10 Hacker News stories.\\nLikewise, I should be able to do this on other platforms.\\nHere's an Android and iOS.\\nNow in practice, you're going to want to provide some kind\\nof error handling for this, possibly retry.\\nThis is just a very quick, dirty example.\\n\\nAnd as you can see, it's now working on all\\nof the platforms, we had Android, iOS, and desktop.\\nWhat you'll notice though from this code is\\nthat we did not have to define any platform specific code\\nother than providing a different client library for each one\\nof the platforms in our Gradle configuration.\\nIt's pretty cool, huh?\\n\"},{\"urn\":\"urn:li:learningContentVideo:2744001\",\"duration\":383,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Apollo GraphQL\",\"fileName\":\"2724070_en_US_05_04_VT\",\"demo\":true,\"videoCreationMetadata\":{\"rawDurationSeconds\":587,\"solutionVideo\":false,\"editingNotes\":\"editors, plz add url \\\"https://docs.github.com/public/fpt/schema.docs.graphql\\\" at 02:11. And add url \\\"https://github.com/settings/tokens\\\" at 04:47\",\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"Exercise Files > Chapte05 > 05-04\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":17607292,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] While most of the internet\\nis based upon REST, another protocol has also grown.\\nGraphQL was popularized by Facebook\\nfor managing complex APIs, which would normally\\nbe split between numerous microservices.\\nThe solution makes it much easier as a client\\nto interact with only one endpoint using customized requests\\nrather than making many requests\\nto multiple microservice hosts for the same thing.\\nIn Kotlin Multiplatform, the Apollo GraphQL Library\\nhas excellent support and it's easy to use.\\n\\nWe're going to integrate the Apollo GraphQL KMP client\\ninto our app for accessing the GitHub API.\\nFirst, we're going to add\\nthe library build plugin dependency\\nto our Gradle version catalog.\\nWe open libs.versions.toml.\\nThis is in our Gradle folder.\\nWe then add a versions entry for Apollo,\\na libraries reference for the runtime,\\nand finally, a plugins entry for the build plugin.\\n\\nNext we jump over to our app's build.gradle.kts file,\\nwhich is under composeApp,\\nand we add a plugin under the plugins block\\nat the top of the file,\\nthe runtime under a commonMain.dependencies,\\nand finally, an Apollo block.\\nHere we set the service name, set a package name.\\nThis affects the naming of the generated files.\\nThis affects the package that classes are generated in.\\n\\nAnd finally, we set the endpoint\\nfor our Apollo service,\\nas well as the schema file, where it's located.\\nAt this point, we need to download the schema for our graph.\\nWe need to go to this URL\\nto download the public schema for GitHub.\\nThe schema defines what queries and mutations\\nare available for us to perform requests against.\\nWe can use it to assemble our custom requests and mutations.\\nSo now we have to copy the schema file we've downloaded\\nto src, commonMain/graphql.\\n\\nAnd it's very important we have to rename it,\\nso the file extension is graphqls.\\nThis is the new schema extension.\\nAfter you've done this and you've put it in place\\nand you rebuild your app,\\nthen Apollo will generate code under commonMain\\nthat will allow you to access the schema\\nfrom both shared and platform-specific code.\\nAt this point, we should start writing our queries.\\nYou can put your queries and mutations\\nin the same directory as a schema file,\\nor you can put in a subdirectory.\\n\\nI recommend using a subdirectory.\\nThis helps you find your queries later\\nas well as your mutations\\nby the feature that they're associated with.\\nThe only difference between a query mutation\\nis that a query returns data from the API\\nwithout changing any, whereas a mutation\\nis meant to change the data remotely.\\nIt's like the difference between a GET request\\nand a POST or a PUT request when you're using REST.\\nAnd this is what a query looks like.\\nIf you haven't used GraphQL,\\nyou can look all this stuff up online\\nand learn how to create your own.\\n\\nBut I've created one here to search the top repos,\\ngrab the first 10,\\nsort them by the number of stars they have.\\nSo this is going to give me the 10 most popular repositories\\non GitHub by a number of stars that are also public.\\nBefore you're able to test and use your queries, though,\\nyou will need to authenticate\\nto the GitHub GraphQL API.\\nThis is going to require two steps.\\nFirst, you need to create\\nyour personal access token for the GitHub API.\\nThen you need to create an authentication interceptor,\\nwhich I did here for Apollo, and then apply it.\\n\\nThis is a temporary key, it'll go away.\\nTo create the token, simply go to this URL\\nand make sure that you grant it\\nthe appropriate public repo permission.\\nThe HDP interceptor has an example in our sample code\\nunder MainViewModel.\\nHere we're adding both an authorization interceptor\\nand a logging intercept as well.\\nTwo different interceptors in the list,\\nand we're creating our Apollo client here\\nand pressing the server URL here for it.\\n\\nNormally you would inject this via dependency injection.\\nSo now we can write this function here\\nto show our top repos.\\nYou'll notice it's a suspend function,\\nwhich is important in Kotlin\\nbecause the suspending function can be run\\non a Kotlin coroutine on another thread.\\nThis allows us to run a background request\\nwhile our app does not have its UI frozen,\\nwhich would be very bad,\\nespecially in say, a mobile app, for example.\\nIn a true MVVM app,\\nyou would want to go one level deeper than this\\nand actually call this function\\nfrom a repository class from the view model,\\nrather than just calling directly from the view model.\\n\\nSo also, we should set up our Apollo client,\\nwhich we do here, and we set the server URL\\nand we add the interceptor.\\nAnd then finally, we call the query, which we execute,\\nand we grab this data object here,\\ndataAssertNoErrors.search.\\nThat will return the list of the top repos.\\nAnd then finally, we update the _uiState.\\nAgain, this is an atomic operation.\\nIt's going to change the _uiState with the copy function\\nwhere we can update just two properties\\nwithout changing anything else.\\n\\nAnd we can now show the app running\\nas expected on each platform.\\nYou can see,\\nI just click that and wait.\\nAnd here, this is the top 10 GitHub repos on GitHub\\nsorted by stars.\\nHere's it working on Android.\\nAnd finally here we have it running on iOS.\\nSo we've learned how to communicate easily\\nacross the internet using both REST and GraphQL models\\nby writing only shared code.\\n\\nI hope you can quickly realize\\nthe power this provides to you as a programmer.\\n\"}],\"name\":\"5. Sharing Network\",\"size\":55107075,\"urn\":\"urn:li:learningContentChapter:6057321\"},{\"duration\":980,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:6063006\",\"duration\":339,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Adding SQLDelight to your project\",\"fileName\":\"2724070_en_US_06_01_VT\",\"demo\":true,\"videoCreationMetadata\":{\"rawDurationSeconds\":422,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"Exercise Files > Chapte06 > 06\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Find out how to bring SQLDelight into a KMP project for managing a database.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":15585216,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Narrator] Now that we know how to write\\nshared network code,\\nthe next logical step is to figure out\\nhow to store that information.\\nWe'd like a single database that works across all platforms,\\nwhich makes it simple to store and search for information.\\nWe can use this as a network cache,\\nas storage for data created by users,\\nor in any way we'd like.\\nFor Kotlin Multiplatform,\\nthe most popular and flexible option is SQLDelight,\\na KMP library written by the same engineers\\nwho built the Cash App.\\n\\nLet's start by adding SQLDelight, to our existing project.\\nFirst, we need to add the plugin\\nand database drivers for each platform.\\nWe do this in the gradle libs.versions.toml file.\\nEach of these database drivers provides everything you need\\nto both query and write data to an SQLite database\\non each supported platform using KMP code.\\nSo, let's look at the libs.versions.toml file.\\nWe'll add one plugin and three database drivers:\\nAndroid, native for iOS, and JVM for desktop.\\n\\nHere we put the version in.\\nWe add the Android driver, the coroutine extensions\\nfor working on background threads,\\nor that sort of thing, a native driver and JVM driver.\\nFinally, we add a plugin at the bottom.\\nThen we go over to our composeApp,\\nbuildgradle.kts file again.\\nWe add the plugin at the top.\\n\\nWe add the Android driver under androidMain.dependencies.\\nWe add the coroutine extensions\\nunder commonMain.dependencies.\\nWe're actually adding Linux datetime and Apollo datetime.\\nIt's useful because we needed it for the GraphQL,\\nbut we also need date time to handle\\nthe date and time types in our database.\\nFor iosMain, we add the native driver.\\nAnd then in desktopMain,\\nwe're adding the JVM driver.\\n\\nAll of that right here. Okay?\\nAnd then we come down here,\\nI'm creating one called cashDB,\\nand I'm sending a package name here.\\nSo, next we want to create the queries\\nthat we're going to need to use.\\nSo, here we have both TopRepos for GitHub,\\nand we have TopStorys for Hacker News.\\nSo, the TopRepos, we're going to create a table here.\\nThis is all SQL code.\\n\\nIf you're not familiar, you can look online\\nand learn how to write SQL.\\nAnd then we have created a selectALL function,\\nan upsert function, upsertFullRepo, and a delete function.\\nSQLight does actually have a native upsert function\\nin newer versions, but because not every platform\\nsupports the newest versions out of the box,\\nwe're going to simplify here\\nby using INSERT OR REPLACE instead.\\nLikewise, we're doing the same thing with TopStory.\\nSo we have a selectAll,\\nwhich will select star from TopStory, and order them.\\n\\nAnd then two upsert functions, and a delete function.\\nI'm demonstrating here\\nwith the two different upsert functions,\\nthat you can either allow the user\\nto pass in every value like this,\\nor you can have functions where these are pre-specified,\\nor you can have one where it simply takes all\\nof the values allowed for that database entry,\\nand it's a single question mark\\nthat fills all of them in for you.\\nVery simple.\\nSo, all of this is just SQL code,\\nand it's going to be used to generate source code\\nthat we can use from Kotlin Multiplatform.\\n\\nSo, then we can go over to create the actual functions.\\nIf I go into my common code here,\\nhere I have a expect fun createDriver function,\\nand then a createDatabase function.\\nSo, my createDatabase function\\nis what I would call from common code.\\nIt's using the createDriver function then\\nto return the CacheDB database.\\nAt that point then we have to, of course,\\ndefine the actual functions as you see here.\\n\\nFor desktop, we use the JdbcSqlightDriver\\nthat we've imported right here.\\nThen we have iOS. We have a native SQLight driver.\\nWe just named it test.db for the database file name.\\nAnd finally, on Android,\\nwe have to do something a little special\\nbecause Android requires context.\\nContext is a very powerful object in Android.\\nYou do not want to leak this object\\nbecause it uses a lot of memory.\\nHere we are referencing our app object.\\n\\nI had to create a special app object for our project\\nto provide the application context,\\nas you can see here.\\nThis is all special for Android.\\nIf you're not familiar with context,\\nit's something you always just need.\\nI prefer not doing this,\\nand instead using dependency injection here if you can.\\nBut here we've created our AndroidSqlightDriver.\\nThis will allow Android to access the database.\\nNow that we've added all the necessary dependencies\\nas well as methods to set up the database drivers,\\nwe will need to define any queries that we want to provide.\\n\\nSQLDelight provides some basic type safety\\nthat makes it easier to write these,\\nand I'll cover that in the next video.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6055290\",\"duration\":183,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Setting up your database and adding objects\",\"fileName\":\"2724070_en_US_06_02_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":212,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Develop code to create a database and its objects to store.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":7494289,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] So now that we have SQL Delight\\nset up in our code base,\\nwe need to make sure that the queries are\\ndefined for our database.\\nWe took a brief look at these in the last video.\\nI just wanted to go into a little more detail.\\nSo we had to create these two .SQ files\\nwithin the SQL Delight folder in common made.\\nEach file defines the SQL commands\\nto create the database Table and Fields.\\nPlus it defines any queries like select\\nor SQL methods to update the database, like inserts,\\nupdates, replaces, or if supported upserts.\\n\\nTake a look at the files I created here.\\nWhen we create the table, we set the field types\\nand their constraints.\\nThe first field is almost always the ID Field,\\nID Fields are special in databases.\\nNearly everything gets an ID\\nbecause it's the only way to link\\nor join data between objects reliably.\\nIn general, IDs are never allowed to be null,\\nand they almost always have the auto increment keyword.\\nThat means you can pass null to create an object\\nand it'll automatically set it to the next ID.\\n\\nAfter that, we set the names\\nand types for each field in that table.\\nString types are text, lungs are integer, doubles are real.\\nBinary types are blob.\\nIf you want special support for float into short types.\\nYou can also add special type adapter libraries\\nfor SQL Delight when you'd prefer not\\nto do manual type conversions.\\nAll these types can also have\\nthe special constraint, not null.\\nNot null, of course, means that\\nthere must always be a value passed\\nfor this variable or parameter.\\n\\nIt cannot be null.\\nSo this is useful in Kotlin\\nbecause then you don't have the question mark\\nand have to deal with null safety and optionals.\\nYou can create custom queries against database\\nby using the select keyword.\\nYou can add new items to the database with insert\\nand you can update existing items.\\nWith update, you can then delete from an item\\nfrom the database with delete, and this is taking an ID so\\nthat you can choose which one to delete.\\nYou can use upsert to either insert\\nor replace an item if it already exists.\\n\\nIf you're having trouble filling out the SQL statements\\nfor your models, I recommend looking up\\nexamples on the internet.\\nSQL can get quite complicated, especially for many\\nto many relationships or complex joins between objects.\\nOnce you've got the SQL right here in these two files,\\nSQL Delight will generate the code that takes\\nto make type safe calls to your database.\\nSQL Delight also supports transactions,\\nwhich is a way of performing multiple SQL operations\\nwhere if anyone fails, then all of it rolls back.\\n\\nIn the next video, we're going to take a look at using\\nthe generated queries from this code,\\nfrom these .SQ files in your project.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6065004\",\"duration\":178,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Creating queries\",\"fileName\":\"2724070_en_US_06_03_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":200,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to apply SQLDelight to creating queries against your database.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":7976060,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Earlier we added database models\\nfor our top story and top repo types.\\nThese SQ light files provide SQL delight\\nwith all the generated type safe code for queries\\nthat we'll be able to use in our project.\\nNow we're going to use that generated code.\\nThe first thing that you should do\\nis either rebuild your project\\nor run the generate SQL delight interface Gradle task.\\nThis is going to generate the code\\nto make queries against our new database models.\\n\\nAnd after we've run it, now that we have the generated code,\\nwe can add code to our view model to add the data\\nto our database and to query it.\\nSo normally in a complex app, it's not unusual\\nto have a repository class\\nthat will handle the complex caching strategy\\nbetween your network and your database,\\nand also, which isolates\\nthat complexity from your view model.\\nYou will also need a reference to your database class\\nin the view model.\\nOne would normally inject that\\nwith dependency injection, but we haven't covered that yet.\\n\\nSo for here now we're just going to add it directly here.\\nLet's add two methods for each of our models,\\ntop stories and top repos.\\nFor each, we're going to want a query method\\nto return each item in the database\\nand an insert method, which will attempt to upsert\\nthe new data from the network.\\nBeware that upserts referred to an SQ light data method\\nthat may be newer, may not be available\\nin the default database on each platform.\\n\\nAs a result, we're using insert update instead,\\nwhich is a little bit less efficient, but does the job.\\nFor each of these methods, this inserts top stories\\nand database, insert fake story and top repos from database.\\nWe're going to access the new classes available\\nfrom our database class\\nto directly call generated Kotlin methods.\\nThese classes and methods are named\\nbased upon the file names and the query names,\\nlike topRepoQueries.selectall,\\ntopStoryQueries.upsert.\\n\\nHere we have top story queries, upsert\\nand topStoryQueries.selectAll.\\nThese are all based upon the methods we created here.\\nSo to upsert the new stories\\nfrom the network into the database here,\\nwe call database.topStoryQueries.upsert for each story\\nand to query the top stories from each database,\\nwe need database.topStories.selectAll.\\n\\nWe've learned how to insert values into our database\\nand how to make queries against it.\\nIn the next video, we'll learn\\nhow you can use Kotlin Coroutine flows\\nto actually watch the database values in real time\\nand react to them as they update in our database.\\n\"},{\"urn\":\"urn:li:learningContentVideo:2744000\",\"duration\":280,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Going with the flow\",\"fileName\":\"2724070_en_US_06_04_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":515,\"solutionVideo\":false,\"editingNotes\":\"one pickup is recorded, plz cut the first video and pickup at 4:30\",\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":true,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":12804127,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] If you've used reactive coding methods,\\nyou'll find Kotlin coroutine flows immediately familiar.\\nMuch like observables and subjects in Rx flows offer a means\\nof watching a value as a stream of values\\nthat changes over time while we observe it.\\nIn the case of database programming flows allow us a mean\\nto watch values in our database\\nand to react immediately in the user interface\\nwhenever any value changes.\\n\\nSQL Delight offers the possibility\\nto query our database in a manner that observes the stream\\nof updated values as a Kotlin flow.\\nTo do this, we first need a new library.\\nWe added it already here,\\nbut that is SQL Delight coroutines, extensions.\\nSo we go into this Libs versions 2 ML file in the Gradle\\ndirectory and add this right?\\nIf we haven't already, we can then add it to the apps,\\nbuild Gradle KTS file again under\\ncompose app build Gradle KTS,\\nand here we go into Common Maine\\nand we add Libs SQL light, coroutines extensions.\\n\\nAt this point, we can simply Gradle sync\\nto make sure we have the library there\\nthat's either hit sync now or press the elephant.\\nAnd then we use the new function as flow, which allows us to\\nconvert our one-time database results instead into a\\nflow of results changing over time.\\nInstead of one list of top stories,\\nwe get a series of lists of top stories,\\neach one representing the new values in our database.\\n\\nNow we can add changes directly to our database\\nand then watch as they're immediately applied\\nand added to the user interface.\\nSo we're going to add a new text field\\nand a button to insert a fake story into our Hacker News\\ntop stories with a very high score so\\nthat it appears at the top.\\nThen we'll add an order bias score descending\\nto the top story thing here.\\nWhen we do our select, the order by score descending\\nand that will make certain\\nthat our new fake story appears on top.\\n\\nAnd then when we add our fake story, this will prove\\nthat we can write to our user interface\\nand instantly track the changes\\nand even animate them as they appear in our view.\\nSo I'm going to do that right now.\\nSo here I have click here\\nto get some top stories from the internet,\\nand here I can add a fake story\\nand then it appeared in real time, as you can see\\nbecause this down here is watching the database in real\\ntime as it changes.\\n\\nSo as you can see, it's not too difficult to add a database\\nto your multi-platform app\\nand you hardly need to write any platform\\nspecific code to use it.\\nYou only have to learn a little bit of SQL and Kotlin\\nand suddenly you can use a database anywhere.\\nHere it is in Android.\\nThere we go.\\nNote that if you're building for iOS,\\nyou might have to make one special change.\\n\\nI had to go in here, open the project,\\nyou click this line right here at the top, top row,\\nand then target, build settings, I'll type in linker,\\ngo to linking general other linker flags\\nand add in SQL light three with a plus sign,\\nminus L-S-Q-L-I-T-E-E three.\\nIf you add that, then you're not going to get any weird linker\\nerrors, which you might get otherwise with SQL Delight.\\n\\nAnd now we can actually run our project with iOS.\\nSo I'm going to get some top HN stories\\nand insert my own fake story.\\nThere we go. And as you can see, it added in real time,\\nsame way it works with Android and with desktop.\\nSo I can do it here on Android\\nand it added it right there, see?\\nSo make sure you remember\\nto add your linker flag if you run into a bunch\\nof linking errors.\\n\\n\"}],\"name\":\"6. Sharing Database\",\"size\":43850795,\"urn\":\"urn:li:learningContentChapter:6055291\"},{\"duration\":1779,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:6063005\",\"duration\":226,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Kermit for logging\",\"fileName\":\"2724070_en_US_07_01_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":352,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"Exercise Files > Chapte07 > 07-01\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":11737957,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Those of us who maintain apps for a living\\nknow that logging is important.\\nIt's often how we discover what's broken\\nor what happened behind the scenes\\nto results in an outcome.\\nHowever, we don't want all of our debugging logs\\ndumped to the console in a production app,\\nfor a lot of reasons.\\nInstead, if we intend to diagnose customer bugs and issues,\\nwe need them sent to a crash reporting solution\\nin the cloud.\\nTouch Lab's Kermit Library provides\\nthe solution for our apps.\\n\\nNamed after the pun, Kermit the Log,\\nKermit can hide or strip debug logs in production\\nand then send those logs instead\\nto a variety of different crash reporting solutions\\nfrom a Kotlin multi-platform app.\\nFor crash reporting solutions,\\nKermit has support for Google's Crash Lytics,\\nBug Snag and Sentry.\\nYou simply add the correct library dependency\\nto your project and you'll be able to integrate logging\\nwith these solutions.\\nLet's start as usual by adding the libraries\\nto the Libs version to ML file in the Gradle folder.\\n\\nSo first, we need to get Kermit,\\nthe latest version right now.\\nThen we need to add the library dependency\\nfor both Kermit and Kermit Crashlytics.\\nHere we go.\\nAnd that's it as far as the-\\nThose versions to a ml file is concerned.\\nNow we have to go back as usual to compose apps,\\nbuild Gradle KTS file.\\n\\nHere we have to add our Kermit dependencies.\\nSo you'll notice I have to add it here under Android main,\\nunder iOS main, but not under desktop,\\nas there's no desktop support right now\\nfor Crashlytics in Kermit.\\nI'm going to just use Kermit\\nin the common main folder however here\\nso that you can see that the actual logging support\\nto hide the logs in production will work across the board\\nfor any platform.\\n\\nSo if I sync now,\\nthat will then bring in our new dependencies.\\nActually using Kermit is simple.\\nAll we have to do is just add calls\\nto logger star methods throughout our code\\nto then send messages and stack traces\\nto our logging methods.\\nTo add logging to your crash supporting solution,\\nsimply call logger dot set log writer\\nwith the name of the appropriate log writer.\\nHere's some examples here.\\n\\nWe added some logger messages directly\\ninto our main vm model, right here.\\nEvery time we add something to the database,\\nwe add log messages that will show only in debug,\\nbut not in production.\\nIn production, it will go instead to\\nour crash reporting solution.\\nI'm going to then run my code right here.\\nCuz I'm running in debug\\nwe expect to see the logs\\nspit out right here.\\n\\nAs you can see, I have info top stories\\ninsert in a database right here\\nand that is coming from my logger.\\nThe line of code right here.\\nAnd if I were to add a top story,\\nthen we end up with another line there.\\nSo these log messages,\\nwe can sprinkle 'em throughout our code\\nand the production version of our app\\nwill not show these messages to somebody\\nif they run it with a tool like Log Cat, for example.\\nBut in production, it will also send them the message\\nto our crash reporting solution.\\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:6057316\",\"duration\":284,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Managing resources\",\"fileName\":\"2724070_en_US_07_02_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":601,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"Exercise Files > Chapte07 > 07-02\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to adapt KMP to managing string translations, plurals, and graphic and font assets.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":13387668,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] When it comes to developing an app\\nacross many different platforms,\\none simple area to reduce overhead\\nis to share different types of resources\\nbetween all of the apps.\\nWe can share translated strings for different languages,\\nincluding plain strings, strings with templates,\\nplurals, string arrays.\\nWe can include fonts to share\\nas well as image and file assets.\\nWe can also create different directories\\nfor alternate versions of resources\\ndepending upon qualifiers.\\n\\nFor example, you can have different strings\\nfor different languages\\nor use different images\\ndepending on day versus night mode theming.\\nYou would normally need to add\\nthe compose component resources dependency,\\nbut we've actually been using it all along.\\nYou'll notice that it's included as part of compose\\nwith the Compose Multiplatform plugin.\\nLet's start by adding the Comic Sans TrueType font.\\nWhat better way to troll all the font purists out there?\\nSo we will simply add the font file to commonMain,\\ncomposeResources, font folder,\\nand we put this TrueType font in there,\\nwhich everyone will recognize from its infamy,\\nand at that point,\\nwe can then create a compose FontFamily\\nbased upon that file,\\nso if I go over here to Fonts,\\nI have created a composable function\\nthat creates a FontFamily based on the Comic Sans font,\\nand this will work on every platform that we have here,\\nso finally, we can change the text\\nof one of our buttons in our app\\nto use the edgy new FontFamily,\\nso here we have the insert_story button to add a fake story,\\nwhich will now be in Comic Sans format,\\nso if I go here and run it,\\nyou see I now have a Comic Sans Insert a fake story,\\nand the same thing would happen\\nif I were to run it on Android, for example.\\n\\nAs you can see,\\nthe font has changed here to Comic Sans on Android,\\nand the same would apply for iOS,\\nso the original app we started from\\nalready included a vector image here\\nof the compose-multiplatform logo\\nin XML image drawable format.\\nThe vector drawable on Android\\nis a format very similar to SVG,\\nor Scalable Vector Graphics.\\nHowever, because Android\\ndoesn't natively support SVGs, exactly,\\nwe can support all of the platforms\\nfor everything that compose-multiplatform supports\\nif we use a vector-drawable format, like Android supports.\\n\\nWe can also use rasterized image formats\\nlike JPEG, PNG, bitmap, WebP, all of these work,\\nbut will work best\\nif you provide different images for each qualifier directory\\nso that you can support screens\\nwith different pixel densities.\\nOtherwise, you'll make blurry images\\nthat don't look very good.\\nPerhaps the most useful aspect\\nof sharing resources for multiplatform Kotlin projects\\nis to share translations.\\nHere we have a strings file where we have English text,\\nand then we have another one\\nwith everything translated by AI into Spanish.\\n\\nHopefully, these are fairly accurate.\\nI'm not worried if they're not because this is a example.\\nIn order to provide translations,\\nyou need to create a default strings file\\nfor your default language first.\\nWe're using English as our default right now,\\nso after you've created this,\\nthen you can create alternate directories\\nfor each language and locale\\nusing the resource qualifiers in the directory name.\\nIn this case, es is espa\u00f1ol,\\nso we have our Spanish translations,\\nso here we're translating our app into Spanish.\\n\\nWe need to create this values directory here,\\nand then the values-es and populate both of those,\\nso you copy the strings.xml file here,\\nand you change all these values\\nwithin the string tags into Spanish.\\nBe aware that, like, if you use AI to do translations,\\nthat it does make mistakes,\\nbut in this case, it's just good enough for testing,\\nand at this point,\\nwe can actually run our app in Spanish, for example,\\nand it should just work.\\n\\nAs you can see here,\\nthe application has been translated into Spanish\\nbased upon the strings\\nwe put in values-es/strings.xml.\\nAll of these are correctly shown here,\\nand the app still works.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6062032\",\"duration\":509,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"KOIN for dependency injection\",\"fileName\":\"2724070_en_US_07_03_VT\",\"demo\":true,\"videoCreationMetadata\":{\"rawDurationSeconds\":619,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"Exercise Files > Chapte07 > 07-03\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Find out how to use KOIN as a dependency injection solution for KMP.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":22941156,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Dependency injection is very popular\\namong experienced software developers.\\nIt offers improvements to the decoupling, testability,\\nand reusability of software components.\\nFor Kotlin Multiplatform,\\nthe most popular dependency injection solution\\nof choice is called Koin, with a K.\\nIt has a simple, easy to use DSL, domain specific language,\\nand can be used with annotations\\nto simplify adding it to your classes.\\n\\nLet's start by adding Koin to our project.\\nThen we should add dependency injection\\nto improve our existing code.\\nAs usual, we should add the actual library dependencies\\nto the project.\\nIf we go to gradle folder, libs.versions.toml,\\nwe add Koin version 4.0.4 is the current one right now,\\nmaybe newer when you look at it.\\nAnd then we add three actual libraries, koin-android,\\nspecific to Android, koin-compose-viewmodel,\\nfor injecting view models, and koin-core.\\n\\nWe don't end up needing a plugin for this.\\nSo when we go over here,\\nagain, we don't need a plugin.\\nWe add koin-android under androidMain.dependencies.\\nWe add koin-core and koin-composed-viewmodel\\nunder the commonMain.dependencies, and that's it there,\\nand there's nothing else to do in that file.\\nNext, we need to add the code to initialize Koin on startup.\\nWe need to run the startKoin command for each platform\\nwith all the modules and the logging configured.\\n\\nWhen producing multi-platform projects,\\nthere's a common Koin pattern\\nwhere the project will have a list of modules\\nincluding a common module and a platform module.\\nBy defining the platform module in shared code\\nas expect val platformModule, as we do here,\\nwe can define it differently for each platform.\\nFirst, let's identify common code modules\\nto add to the common module.\\nWe can add the MainViewModel with viewModelOf,\\nthe HTTP client, the NewsApi, the SQL driver,\\nand our database.\\n\\nEvery one of these can be added as a singleton, except\\nfor the view model, using the singleOf method.\\nThe view model has a special viewModelOf method\\nto use instead,\\nbecause it has to be injected differently.\\nNow that we have our common modules to find in a module,\\nto identify any platform specific modules to add,\\nat this point, there are none.\\nEvery library that we've used in this project\\nhas shared code provided for each platform,\\nbut it's good practice to have these modules ready.\\n\\nSo we're going to create an empty platform module\\nfor each platform.\\nHere's desktopMain,\\niOS,\\nand Android.\\nAt this point, we should wire up the Koin initialization.\\nAndroid needs special configuration\\ndue to Android's context, so we'll need\\nto create a custom Android application class\\nand wire up its onCreate in order to start Koin.\\n\\nWe'll first create an AndroidApp class\\nextending from Android's application class as we do here.\\nThen after overriding the onCreate here as I do,\\nwe also have to add this name parameter to our application.\\nThis ensures that our app is started up\\nusing this new custom application.\\nHere, we run startKoin. We pass in the androidLogger class.\\nWe pass androidContext with the application context.\\n\\nAnd we pass modules of appModule, which as you remember,\\nis a list of the common module with everything in it\\nand the platform module with everything in it.\\nAnd like I said, we have to make sure\\nthat we define our app here.\\nOtherwise, none of this code is going\\nto get used when we start our app.\\nNow we have to do the same kind of thing for iOS.\\nHowever, we have a initKoin class in shared code here.\\nThis can be reused for both iOS and desktop,\\nbasically for all platforms that don't need anything special\\nas far as context or the Android logger.\\n\\nHere, we just set the printLogger\\nfor everything debug and above,\\nand we pass the appModule again.\\nNow, if we go over to iOSApp.swift, I'm going\\nto wire it this way, I'm going\\nto add a UIApplicationDelegateAdaptor,\\nand create an AppDelegate,\\nso that I can then import ComposeApp.\\nComposeApp here is our XCFramework,\\nour shared library that I created, I'll show you.\\n\\nRight here, we created ComposeApp as the baseName,\\nand we made it static.\\nYou can do this a lot of ways,\\nbut here we have all of our iOS logic\\nfor shared code bound up into a shared framework\\ncalled ComposeApp.\\nSo here we import ComposeApp, and then that makes\\navailable the KoinSharedKt.doInitKoin method.\\nThis looks really ugly, but this is a builtin method\\nof the UI application delegate.\\nSo we are just adding a new function call\\nto something builtin that needs to be overridden.\\n\\nAnytime our application starts up, we initialize Koin.\\nNow we need to wire up each of the places\\nwhere we should be injecting our classes instead\\nof constructing them on the fly.\\nRemember in NewsApi, if go there,\\nwe were originally creating our client on the fly,\\nbut now we actually create our client here\\nwith the client KT method that does this.\\n\\nSo we can say singleOf client, and it'll reference this,\\nand we no longer need to do it on the fly here.\\nWe can just say, by inject.\\nAnd this is important, NewsApi needs\\nto subclass KoinComponent.\\nThis makes this inject method function.\\nIn MainViewModel, we should be injecting our NewsApi\\nby inject as well.\\nThis makes sure it's the same instance,\\nbecause we use singleOf, remember?\\nAnd the database, we were using this createDatabase call.\\n\\nNow we can just say by inject.\\nAs you can see here, we call createDatabase like this.\\nWe no longer need to have all the extra junk.\\nWe can simply have createDriver\\nand createDatabase as singles here,\\nand all of the magic happens in MainViewModel.\\nIt just finds it by doing CacheDB by inject.\\nAgain, I add KoinComponent here to our MainViewModel\\nso that we can inject to it.\\nFinally, we need to do one more thing.\\n\\nTo make everything work in compose,\\nand to be able to inject into compose,\\nget rid of that,\\nwe add a KoinContext surrounding the top level\\nof the entire compose app.\\nThis then allows me to inject things\\nwith things like KoinViewModel\\nor the call to get or call to inject.\\nRemember, I used to have to define my view model here\\nin the constructor with a default value.\\n\\nNow I can just inject it,\\nand it's going to always use the right view model.\\nThis right here, and that's all coming again from this.\\nAt this point, the app should now run on all platforms\\nand we're now properly using dependency injection\\nto share singletons instead\\nof passing in a brand new instance each time\\nthat could cause us terrible bugs down the road.\\nThis should make it more testable and much easier to use.\\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:6062028\",\"duration\":844,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Storing values in multiplatform-settings\",\"fileName\":\"2724070_en_US_07_04_VT\",\"demo\":true,\"videoCreationMetadata\":{\"rawDurationSeconds\":1242,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"Exercise Files > Chapte07 > 07-04\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to use Multiplatform-settings for storing values persistently in KMP.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":43708743,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] We've talked about how to persist data\\nby storing it into a database with custom SQL code.\\nHowever, many times we want to persist values\\nand apps, we don't need a complex database.\\nA simple key value store is enough for most purposes,\\nlike app settings or preferences, for these purposes,\\nthere's a very useful KMP library\\ncalled multi-platform settings.\\nIt's a common pattern in apps to have an onboarding screen\\nthat you only ever show once.\\n\\nYou may have app settings like choosing whether\\nto show dark mode or light mode.\\nIn these cases, it often doesn't make sense\\nto store the values in a database with all of the overhead\\nof making special database tables and queries.\\nThis is why settings exist, like user defaults on iOS\\nor shared preferences or data store on Android.\\nAdditionally, you might want\\nto encrypt certain settings if they contain sensitive values\\nlike your OAuth tokens or your encryption keys.\\n\\nSafe encryption and storage\\nof these values at rest demands safe\\nand effective solutions like key chain storage on iOS\\nor encrypted shared preferences on Android.\\nYou'll be happy to know that multi-platform settings\\nhelps you manage both cases\\nso that you can securely store both encrypted\\nand plain text settings across multiple platforms.\\nNote that if you don't need encrypted preferences,\\nthe KMP integration is far easier\\nusing the no ARG dependency for multi-platform settings.\\n\\nHowever, I'm going to show you the tricks needed\\nto set up your own custom factories\\nand use coins named dependencies\\nto inject two different versions of the same type,\\nboth encrypted and unencrypted settings\\ninto the same single settings repository class.\\nSo let's first go to Libs.versions,\\ntoml in the Gradle folder as we always do.\\nWe need to add the multi-platform settings dependency,\\nwhich I have the version here,\\nand I have the module here.\\n\\nYou're also going to need Android X security crypto KTX,\\nwhich I have the version here.\\nAnd here I have the module for the library.\\nSo the latter library for Android is technically deprecated\\nby Google, but it still remains the quickest way\\nto create encrypted preferences on Android.\\nData store should hopefully have something soon.\\nUntil then, this is how you do it.\\nFor desktop, we have one more solution,\\nwhich is we have the encryption\\nfor desktop credential storage.\\n\\nI have a version here and I have a version here.\\nIt's from Microsoft and it's for the JVM.\\nSo with those three libraries, then we should be set.\\nSo we can go over to the build.gradle KTS\\nin the composeApp folder,\\nand we have to add these libraries just as we did before.\\nThere's nothing to add up here for plugins.\\nAs we go down here we see Android security Crypto has been\\nadded to androidMain,\\nand we've added multi-platform settings to common Main\\nbecause it's our shared code.\\n\\niOS has a special case\\nbecause it uses the built-in key chain settings\\nfrom multi-platform settings.\\nWe do not need to add a special iOS main dependency\\nbecause it's built into the shared code.\\nOn Desktop Main, we add the credential storage JBM,\\nand we don't need to do anything down here.\\nThat's all taken care of.\\nJust need to add all the libraries\\nunder dependencies and we're good.\\nSo now we're going to add a settings repository class\\nto our shared code.\\n\\nI created one down here.\\nI made it a coin component, which again, this allows you\\nto inject into the class.\\nAnd here we're doing a special trick with coin injection.\\nWe're injecting name dependencies.\\nNow, if you have more than one way of injecting something\\nof the same type, you need to name them\\nbecause there's no other way to tell them apart.\\nSo here we're injecting them by name,\\nand if you look at the coin shared stuff,\\nyou see settings repository here.\\n\\nBut what you don't see is\\nhow we're getting plain text encrypted.\\nSo for each individual platform,\\nif I look at the coin shared platform module,\\nwe have a factory for settings that creates it by name,\\nencrypted and plain text.\\nSo for Android, we have encrypted settings factory,\\nwhich this get here is a way of saying that we want coin\\nto inject into it.\\nAnd what's happening here is this is looking\\nfor encrypted shared preferences\\nthat we're automatically going\\nto pass into the encrypted settings factory.\\n\\nLikewise here we set up shared preferences.\\nI create a plain text database for shared preferences\\nand then pass it into these shared preferences settings,\\nwhich is built into multi-platform settings.\\nBy the way, encrypted settings factory\\nis something I created here.\\nBasically it's still using shared preferences settings, but\\nbecause encrypted shared preferences actually\\ncreates an instance of shared preferences,\\nthey're both the same type.\\n\\nBoth the encrypted and the unencrypted version are\\nusing shared preferences.\\nThe difference here is how I created this with a master key\\nthat goes into your key chain in a way that all\\nof this is secure.\\nThis code down here is going to make sure\\nthat our shared preferences\\nand when you write them that they're encrypted.\\nOkay, going down to desktop, we had\\nto do some very special stuff.\\nHere I have this provide encrypted preferences settings\\nfunction that I got from open source.\\n\\nYou can check it out in the sample code,\\nbut this takes care of all of\\nthat using the Microsoft credential storage.\\nAnd for plain text,\\nwe just use a regular preferences settings\\nwith Java preferences, which are very common.\\nHere for iOS,\\nwe're doing key chain settings, which again,\\nthis is built into multi-platform settings\\nand it's user default settings, which is just\\nhow preferences or settings are normally done on iOS.\\n\\nAnd we pass in the standard user defaults.\\nThis is a platform function of iOS.\\nSo now that we've got all\\nof this dependency injection set up, each of them by name,\\nthen the logic will work in our injection\\nto these settings repository.\\nAnd this is shared code.\\nSo all of this here will allow us\\nto put the scene onboarding Boolean in there\\nin an unencrypted format.\\nBecause I'm using plain text settings, it'll allow us\\nto put the last name of the fake story text\\nso we can store the field value for next time\\nand it will store our auth token.\\n\\nThis isn't very useful right now\\nbecause I'm hard coding the auth token,\\nbut if you were getting a token from a server from REST,\\nthis would be a great way to store it\\nto keep it safe from prying eyes.\\nAnd then a finally, a clear function for both settings,\\ninstances that just calls duck clear on each\\nand this will wipe them all out.\\nSo now that I've created this settings repository,\\nI can inject it as well.\\nIf I go to app.kt here again, we have the coin context.\\nThat means we can inject into the top level composed class.\\n\\nAnd here we're using coin inject\\nto inject the settings repository directly\\ninto our composable function, our coin context.\\nThe fake story text here where I think you'd want to say,\\nremember, mutable state of fake story text\\nand then dismissed onboarding.\\nThis is just false, but what we're going to do is\\nwhen the user dismisses onboarding\\nor sees onboarding for the first time,\\nwe're automatically going to set it to true in the settings.\\n\\nYeah, here I'm setting the fake story text\\nwhen we press the button\\nto insert a fake story that then saves it.\\nAnd down here we're using settings.clear.\\nIf we haven't dismissed onboarding\\nand the value is false for has shown onboarding,\\nhere we have a launch effect that is going to set,\\nhas shown onboarding to true.\\nLaunch effect is again, just a way of using a co-routine\\nto run some code in our composable.\\nInstead of having to put views here, we can just run code.\\n\\nThis is a little confusing, the word unit.\\nWhen you put unit into launch effect, you're saying\\nthat I only ever want this to run once,\\nnot every time some value changes.\\nSo you could put a variable in here\\nand then every time that variable changes, it runs agaain.\\nThis is a way of saying I only want it to run one time.\\nWe've added all of our preferences, both encrypted\\nand unencrypted, and now if I run it,\\nclear sittings and run it again, you didn't see the message\\nbecause I already ran it, but here is the message\\nthat I've created that only appears one time.\\n\\nIf I run the app again, it's not going to appear.\\nAnd at this point I can type in something.\\nThis is a fake story\\nand if I go back, run it again, it should still say that.\\nThere we go.\\nSo we have our shared preferences being stored\\nin the Android app and jump over to, let's do desktop next.\\nAs you can see, desktop is the onetime message.\\n\\nAnd I can say, this is a fake story, insert.\\nAnd then if I rerun it, expect to see the same thing.\\nThere we go. That's desktop.\\nAnd here is an iOS. So an iOS, we have the one time message.\\nLet's say this is a fake story, insert a fake story.\\nRun it again. Stop and rerun.\\n\\nAnd it didn't show the one time message\\nand it kept the text.\\nSo all three of them now are storing settings\\nor preferences into a key value store,\\nstoring encrypted stuff in encrypted settings\\nand non-encrypted stuff in unencrypted settings.\\nNow let me just prove that this worked.\\nI'm going to go over to device manager\\nand here I can bring up the device explorer\\nlike this bigger go to data, data,\\nfind our app, the list,\\nand then shared preferences.\\n\\nIf you look at the plain text, this is\\nseen onboarding, true, fake story, this is a fake story.\\nEncrypted XML, you'll notice has all of this.\\nIf I go out to a running device here for a second\\nand make some requests, expect this to crash.\\nSo don't worry 'cause I didn't put a API key in there.\\nOkay, if I look at this now, it's opened up.\\nI'm go device explorer. Close that.\\nYou can look at the encrypted settings\\nand now you can see there's a new encrypted setting.\\n\\nThis one has the key name encrypted as well\\nas the value encrypted.\\nYou can see it's a symmetric cipher,\\nbut yeah, you can't read any of this.\\nThis is hopeless if you're a hacker.\\nSo you would have to get it the key,\\nwhich is stored in the key chain.\\nAnd so this is secure on Android.\\nOn iOS, it's a little bit harder to get at.\\nIf you're using the simulator, you go\\nto window, devices and simulators.\\nIf it's a device, you can just\\ndownload the entire container.\\nIf it's a simulator, you need to get this identifier\\nand go to a very specific directory,\\nwhich is going to be a pain.\\n\\nAnd I'm not going to say it's going to be quick or easy.\\nYou can look this stuff up online.\\nThe folder you want is going\\nto be under the hidden directory, the library,\\nunder your home directory, it's going to be library developer,\\ncore simulator devices,\\nand then the identifier you got here\\nwith data containers, data application,\\nthe app id, library preferences,\\nand then the applications bundle id.plist.\\nSo if you can find it,\\nyou can hunt for it with the terminal's fine command,\\nlooking for .plist files.\\n\\nThis file contains your unencrypted settings,\\nI can show you one right now.\\nSo this is an example where it's stored,\\nseen onboarding with the setting.\\nIt's hard to read, but it's there.\\nYou can see the settings are being stored.\\nThat's the unencrypted one.\\nThe encrypted one, you're going to have\\nto get even more fancy for.\\nI have the database browser for SQLite,\\nand here's the directory with the device id.\\nIt's going to be long and hard to get at.\\nYou need to look in the GenP folder,\\nonce you find the right database.\\n\\nAnd then go to this AGRP column,\\nfind your team ID and the full bundle ID here.\\nAnd then you go to the data column and tap into that.\\nAnd you can look over here and see that there\\nare SF Cipher texts, authentication codes\\nhidden here that you can't read.\\nSo just to show you, iOS has a hidden too.\\nI'm not going to bother going into desktop at this point,\\nbut you can also verify that that works correctly.\\nAt this point, congratulations,\\nyou can now handle storing both settings\\nand sensitive data storage,\\nboth from Kotlin multi-platform across multiple platforms.\\n\\nThis is again, super useful.\\nI hope you can make great use of it in your apps.\\n\"},{\"urn\":\"urn:li:learningContentVideo:6055288\",\"duration\":425,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Dates in Kotlinx-datetime\",\"fileName\":\"2724070_en_US_07_05_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":609,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"Exercise Files > Chapte07 > 07-05\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Find out how to provide reliable date math on every platform using Kotlinx-datetime.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":18909577,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Dates are hard.\\nThere's a joke that engineers, much like Microsoft Excel,\\nboth struggle to know when something is a date,\\nbut also the very nature of dates and times\\nis unbelievably complex.\\nMost regular people don't understand this,\\nbut there are so many examples.\\nTo get an idea, I recommend Googling,\\n\\\"Falsehoods engineers believe about time.\\\"\\nOnce you get basic date handling working,\\nyou then start to deal with time zones,\\nand then fractional time zones,\\nand once time zones seem all right,\\nyou then have to deal with daylight savings time,\\neven sometimes fractional daylight savings time\\nwithin the same time zone.\\n\\nOnce you've got your time working right,\\nyou'll be very lucky\\nif you never have to deal with historical times or dates\\nbefore the laws change what the times and dates mean.\\nThe point of this is all very simple.\\nNever ever roll your own date and time handling logic,\\nunless you absolutely have to.\\nIt's foolish\\nand is only ever going to make you very, very sad,\\nespecially when you have to support your code\\nand the serious mistakes that it causes.\\nIt's also recommended to rely upon\\nthe very best available date and time libraries available.\\n\\nIn Kotlin Multiplatform, there's a special library for this,\\ncalled Kotlinx-datetime.\\nSo we're going to add code to perform date math\\nand to show the date in different internationalized formats.\\nWithout the library we have access to,\\nthis task would be hard and you wouldn't know\\nwhether your code was dangerous and broken\\nuntil somebody traveled to a new time zone using your app,\\nor maybe they found daylight savings time\\ncaused the time to roll back.\\nAnd it wouldn't show the month and days swapped\\nin a way people would expect in their region.\\n\\nIn America, we prefer the month before the day,\\nwhile in Europe and much of the world,\\nprefers the day before the month.\\nIf you show these backwards, it can cause great confusion.\\nI will note to you that this library is a work in progress\\nand that it cannot implement\\ncertain low cal dependent things\\nthat we take for granted in the Java date, time libraries,\\nlike 12 hour time being handled automatically\\nwhen you're using your date formats.\\nThis is because a number of the Kotlin platforms\\ndo not yet have access\\nto the rather essential concept of locales.\\n\\nSo ISO date format will always work with this library,\\nbut it isn't ideal for a lot of use cases.\\nYou can also then manually construct\\nyour own custom date formats, as needed,\\nby handling each section of the date individually\\nin your common code.\\nSo for this, let's start, as usual,\\nby making sure we have the necessary dependencies.\\nWe need Kotlinx-datetime.\\nWe've got the version here, and the library here.\\n\\nYou may already have it added from previous exercises\\nbecause we had dates within our return values\\nfrom some of these network APIs,\\nwe added in the Apollo date, time support section.\\nNow let's add dates to our top hacker news stories.\\nSo we need to update topstory.sq under SQLDelights,\\nunder Common Main.\\nSo here we have a time, integer not null,\\nand we added a new method\\nthat should allow us to update the dates.\\n\\nWe're using the upsert method here, this one,\\nwhich has insert or replace in the top story.\\nAnd when we put a new time in here,\\nit's going to populate and replace the existing entry.\\nSo using this, we can go to main view model,\\nand we can create a new function.\\nAdd four hours.\\nSo here we're taking advantage of the date math capabilities\\nof our Kotlinx-datetime library.\\n\\nSo we're doing a select\\non a particular ID in top story queries.\\nSo I think I had to add that.\\nYou'll see there's a select star\\nwhere ID equals question mark\\nthat allows you to select not all of the stories,\\nbut just the one.\\nHere, we're doing select execute as one,\\nwhich then returns a single top story, based on the ID.\\nHere we do instant from epoch second,\\nso this is taking the time,\\nwhich is stored, in this case, in seconds since 1970,\\nand it's adding four hours to the time,\\nand then returning epoch seconds again.\\n\\nSo then finally, we do database top story queries, upsert.\\nThis is again, going to do an insert or replace.\\nYou could do an update instead,\\nwhich would be more recommended, in my opinion,\\nbut we're going to replace here,\\nand it's going to replace every single one of those\\nwith the new time inserted.\\nSo we have top story ID, top story type, top story by,\\nall of these are the same except for the time.\\nThis will change everything,\\nassuming that it all happens atomically on one thread.\\nSo if I run the code here,\\nI run desktop first.\\n\\nNow I have all these hacker news stories\\nwith the date and time, which as you can see,\\nif I go look at app Ducket, I changed this as well.\\nThe logic to show date and time. Here we go.\\nSo I create a by Unicode pattern, create this date format,\\nand I say instant from epoch seconds,\\nstep format, date format.\\nAnd then this allows me to show the date and time.\\nNow keep in mind,\\nwhen you're trying to do date formats with this library,\\nit doesn't handle 12 hour time, and that kind of sucks.\\n\\nIt's a work in progress, and when the locales are supported,\\nyou'll be able to do all the things you can do\\nat the Java Library.\\nGoing back to our thing here,\\nevery time I press one of these,\\nyou can see the time increases four hours\\nand the date will increase\\nwhen I go over the end of the day.\\nAnd this button was added for each story,\\nso you can mess with it.\\nThere's still ordered by score,\\nso you're not going to change the order by doing this,\\nbut you can at least see that the date math is correct.\\n\\nOkay?\\nWe can do the same thing now for Android.\\nAnd we can do it for iOS.\\nOkay, here we go.\\nAs you can see, dates roll over,\\nand date math is correctly handled.\\nSo I hope this helps you.\\nHopefully they soon figure out a way\\nto support locales across more platforms.\\nThat would be very nice so that you're not forced\\nto do JVM-specific solutions\\nor having to roll your own date and time formats\\nbased upon what is supported.\\n\\nI hope that was helpful.\\n\"}],\"name\":\"7. Quality of Life\",\"size\":87743945,\"urn\":\"urn:li:learningContentChapter:6057322\"},{\"duration\":63,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:6063004\",\"duration\":63,\"visible\":true,\"requiredForCertificateOfCompletion\":null,\"name\":\"Next steps\",\"fileName\":\"2724070_en_US_08_01_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":861,\"solutionVideo\":false,\"editingNotes\":\"outro was recorded in the studio as part of tetris. no complex editing needed for this simple outro, just some punch-ins and two URL overlays https://kotlinlang.org/docs/books.html (when Colin mentioned books) and https://www.linkedin.com/in/colinmlee/  (whne Colin mentioned his linkedin)\",\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Decide how to further grow and specialize with KMP by perusing topics outside the beginner level of this course.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2796320,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- Congratulations on completing this epic journey\\ninto the wild world of Kotlin Multiplatform.\\nI hope you found this course very helpful\\nas your first step down the road to mastery.\\nTo continue on your adventure,\\nI recommend watching the free YouTube videos\\nfrom recent Kotlin conferences.\\nThese have outstanding content from top engineers\\nat innovative companies.\\nTo learn more about the Kotlin language,\\nthere are a ton of resources.\\nConsider the book \\\"Kotlin in Action\\\",\\nwhich goes into great depth,\\nor just build something useful to you,\\nwhich is always a great way to learn.\\n\\nYou can also follow me on LinkedIn,\\nwhere I often share content\\nrelated to the newest innovations\\nin both Kotlin and Compose Multiplatform.\\nFollow me for tips, hot takes,\\nand posts that'll make your manager\\nthink you're researching something.\\nThank you for joining me.\\nI'm sure you're excited to use all that you've learned.\\nRemember, always celebrate responsibly.\\nFriends don't let friends push straight to production.\\n\"}],\"name\":\"Conclusion\",\"size\":2796320,\"urn\":\"urn:li:learningContentChapter:6065007\"}],\"size\":360117360,\"duration\":8727,\"zeroBased\":false},{\"course_title\":\"Exploring Ktor with Kotlin Multiplatform and Compose\",\"course_admin_id\":6004176,\"metadata\":{\"Locale\":\"en_US\",\"Course ID\":6004176,\"Project ID\":null,\"Course Name\":\"Exploring Ktor with Kotlin Multiplatform and Compose\",\"Course Name EN\":\"Exploring Ktor with Kotlin Multiplatform and Compose\",\"Activation Status\":\"ACTIVE\",\"Display to Public\":\"Yes\",\"Display to QA\":\"No\",\"Course Description\":\"In this hands-on course, Troy Miles\u2014an award-winning software engineer, speaker, and author\u2014explores the powerful combination of Ktor and Kotlin Multiplatform to build full-stack applications that share code across platforms. Step through the full process of creating a data-rich server application with Ktor, deploying it to AWS, and building cross-platform mobile clients using Kotlin Multiplatform with Jetpack Compose for Android and SwiftUI for iOS. Learn advanced techniques for handling large datasets, implementing API security, and creating efficient mobile UIs that communicate seamlessly with your backend. Plus, explore best practices for the security and performance of your applications.\",\"Course Short Description\":\"Learn how to build and deploy a complete cross-platform solution using Ktor for the server and Kotlin Multiplatform for mobile clients.\",\"Content Type\":\"TOOLS\",\"Localization Type\":\"ORIGINAL\",\"Original Course Locale\":null,\"Original Course ID\":null,\"Equivalent English Course\":null,\"Instructor ID\":\"2324017\",\"Instructor Name\":\"Troy A Miles\",\"Instructor Transliterated Name\":null,\"Instructor Short Bio\":\"Award-winning Software Engineer, Speaker, and Author\",\"Author Payment Category\":\"NON-LICENSED\",\"Delivery Mode\":\"ALL_AT_ONCE\",\"Series End Date\":null,\"Course Release Date\":\"2025-09-02\",\"Course Updated Date\":null,\"Course Archive Date\":null,\"Course Retire Date\":null,\"Replacement Course\":null,\"Has Assessment\":\"No\",\"Has Challenge/Solution\":\"Yes\",\"LIL URL\":\"https://www.linkedin.com/learning/exploring-ktor-with-kotlin-multiplatform-and-compose,https://www.linkedin.com/learning/exploring-ktor-with-kotlin-multi-platform\",\"Series\":\"One-Off\",\"Limited Series\":null,\"Manager Level\":\"Individual Contributor\",\"LI Level\":\"Intermediate\",\"LI Level EN\":\"Intermediate\",\"Sensitivity\":null,\"Internal Library\":\"Technology\",\"Internal Subject\":\"Programming Languages\",\"Primary Software\":\"Kotlin\",\"Media Type\":\"Video\",\"Has CEU\":\"No\",\"Has Exercise Files\":\"No\",\"Visible Duration\":5361.0,\"Visible Video Count\":41.0,\"Learning Objectives\":\"Build and deploy a Ktor server application to AWS that efficiently serves large datasets. ,Create a shared network layer using Kotlin Multiplatform that works on both Android and iOS. ,Develop a cross-platform mobile app that connects to your backend service using Jetpack Compose for Android and SwiftUI for iOS. ,Implement best practices for security and performance in both server and client applications.\",\"Contract Type\":\"PERPETUAL\",\"Certifications\":null,\"Framework Topic\":null,\"Automatic Caption Translations\":\"Global Captions\",\"Automatic Metadata Translations\":\"LiL Libraries, Global Metadata\",\"Gen AI Feature Flag\":null,\"Hands-On Practice\":null,\"Hands-On Practice Library\":null,\"Unlocked for Viva Learning\":\"Global Captions\",\"Free Course\":null,\"Certification Library\":null,\"Github Codespace\":null,\"Skills Count\":2,\"Skills\":\"Kotlin,Ktor\",\"Skills EN\":\"Kotlin,Ktor\",\"Content Manager\":\"Christa Lindley\",\"Acquisition Manager\":\"Christa Lindley\",\"Framework Subject\":null,\"Suppress Upsells\":null},\"sections\":[{\"duration\":36,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:4159012\",\"duration\":36,\"visible\":true,\"requiredForCertificateOfCompletion\":null,\"name\":\"Explore Ktor with Kotlin Multiplatform and Compose Multiplatform\",\"fileName\":\"6004176_en_US_00_01_VT\",\"demo\":true,\"videoCreationMetadata\":{\"rawDurationSeconds\":378,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Review what you'll build in the course: a cross-platform Astronomy Picture of the Day (APOD) app using Kotlin Multiplatform (KMP), Ktor, and Compose Multiplatform.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2412288,\"solution\":false,\"welcomeContent\":true,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- Do you ever look at mobile apps and wonder\\nhow teams build for both Android and iOS\\nwithout writing everything twice,\\nor wish you could create a single backend\\nthat serves data to any platform?\\nIn this LinkedIn Learning course,\\nwe'll build a complete cross platform app from the ground up\\nusing Kotlin's type safe, modern approach\\nto multi-platform development.\\nI'm Troy Miles.\\nI'm a software engineer, land surfer,\\nand all around tech nerd.\\nSo fire up Android Studio,\\nget ready to explore the Cosmos,\\nand let's build something amazing together.\\n\\n\"}],\"name\":\"Introduction\",\"size\":2412288,\"urn\":\"urn:li:learningContentChapter:4156013\"},{\"duration\":1022,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:4159011\",\"duration\":199,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Set up Kotlin Multiplatform (KMP) projects with a Ktor server\",\"fileName\":\"6004176_en_US_01_01_VT\",\"demo\":true,\"videoCreationMetadata\":{\"rawDurationSeconds\":289,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 01_01\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Review the structure of the project you'll build, which starts with a KMP template and includes preconfigured dependencies.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":7423404,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Welcome.\\nIn this first module, we're setting up the foundation\\nof our Kotlin multi-platform project,\\nwhich includes both a mobile frontend\\nand a Ktor-powered server backend.\\nWe'll start by examining the server setup,\\nhow we launch it, and how the major pieces come together.\\nLet's begin in Application.kt.\\nThis is our entry point for the server.\\nIf you've used Spring Boot or Express before,\\nthis is similar to your main function or index.js.\\n\\nIn Ktor, we created embedded server,\\nspecify the engine, here it's Netty,\\nand provide a port, host, and a reference\\nto the main application module.\\nWe're using System.getenv port\\nto allow overriding the port via environment variables,\\nthat makes it easier to deploy\\nto different environments later.\\nWhen the server starts,\\nit calls Application.module.\\n\\nThat's where the real setup happens.\\nWe configure Koin for dependency injection,\\ninitialize the database, and install a few plugins.\\nLet's walk through each of those steps.\\nFirst, Koin. We call Koin and pass in a few modules,\\nappConfigModule, databaseModule, and appModule.\\nThese are declared in separate files\\nand lets us cleanly define dependencies\\nlike configuration, database access, and services.\\n\\nNext is initializeDatabase.\\nThis connects us to our SQLite database using Exposed ORM.\\nWe are using HikariCP as our connection pool.\\nAnd this setup ensures our schema\\nis ready before any API calls are handled.\\nThen we configure several Ktor features.\\nThese are added using extension functions\\nlike configureSerialization, configureRouting.\\nEach one of these lives in a separate file,\\nmaking the code modular and testable.\\n\\nNotably, we also have configureBackgroundJobs.\\nThis function wires up recurring jobs,\\nlike fetching the astronomy picture of the day, APOD,\\nand cleaning up expired entries.\\nWe'll explore how that works in a later module.\\nOnce all that is initialized,\\nthe server logs its startup.\\nAnd we're ready to accept HTTP request.\\nIn the logs, you'll see lines\\nlike responding at http://0.0.0.0:8080,\\nindicating that everything is up and running.\\n\\nSo to recap, our server entry point is main,\\nwhich creates an embedded Netty server\\nand invokes the Application.module method.\\nInside that module, we install dependency injection,\\nset up our databases, and register plugins\\nthat handle serialization, error handling,\\nrouting, monitoring, and background jobs.\\nThis modular structure keeps our code clean,\\norganized, and ready for scaling.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4160009\",\"duration\":153,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Essential Ktor plugins\",\"fileName\":\"6004176_en_US_01_02_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":189,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 01_02\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to configure JSON serialization, error handling, and request logging for a production-ready server.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":6772446,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [InstruKtor] Now that the Ktor server is up and running,\\nlet's talk about the core plugins\\nthat make it actually useful.\\nThese plugins are where Ktor gets its flexibility\\nand they're the backbone of any serious Ktor application.\\nLet's start with content negotiation.\\nThis plugin allows a server to automatically serialize\\nand deserialize requests and response bodies.\\nWe've configured it with Kotlinx serialization,\\nwhich gives us a fast and type safe way to work with JSON.\\n\\nWith content negotiation in place,\\nwe can return Kotlin objects\\ndirectly from our route handlers, and Ktor will take care\\nof turning them into proper HTTP responses,\\nsame goes for request bodies.\\nKtor will handle deserialization for us.\\nNext is call logging.\\nThis adds structured request logging,\\nwhich is incredibly helpful for debugging and observability.\\nYou'll get logs like get - /API in your console,\\nwhich is great for tracking\\nhow your server is behaving.\\n\\nLet's just take a quick peek at that.\\nLet's go to the terminal\\nand actually do a request.\\nAnd if we come back here to the debugger,\\nwe see that we get the get - /API/APOD/today\\nin our logs.\\nAnother critical plugin is status pages.\\nThis one intercepts exceptions\\nand translates them into well-formed HTTP responses.\\n\\nInstead of returning a raw stack trace\\nor an internal server error,\\nwe can catch specific exceptions like not found exception\\nand respond with a meaningful message and status code.\\nAll of these plugins are configured in small focus files.\\nThat keeps our code base modular and easy to maintain.\\nEach plugin is installed in the application.module function.\\nTo sum it up, Ktor plugins handle a lot of the boring\\nbut necessary parts of web development, serialization,\\nlogging, error handling, compression.\\n\\nWe've wired them up in a clean, modular way\\nso our server is easy to extend and debug.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4156012\",\"duration\":278,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"NASA Astronomy Picture of the Day (APOD) API integration\",\"fileName\":\"6004176_en_US_01_03_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":365,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 01_03\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to create robust validation logic for API requests and implement effective error responses.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":12149988,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Now that our server is set up,\\nand the essential plugins are installed,\\nit's time to connect to the real world, literally.\\nIn this module, we'll integrate\\nwith NASA's Astronomy Picture of the Day API,\\nalso known as APOD.\\nThe key logic for this module\\nis in the APOD service and APOD routes files.\\nWe'll walk through how this service connects to NASA's API,\\ncaches responses locally in SQLite,\\nand exposes a clean, restful interface to our front end.\\n\\nLet's start at the high level.\\nThe APOD service is where the business logic lives.\\nIts job is to answer questions like, \\\"What's today's photo?\\nGive me a photo from last Wednesday.\\\"\\nIt can also return a random APOD or a paginated history.\\nHere's how that works.\\nWhen a client hits API APOD today,\\nKtor routes that request to the service.\\nSo we start here\\nat /api/apod/today,\\nand then it calls apodService.getTodayApod,\\nand that brings us here to getTodayApod.\\n\\nKtor routes that request to the service.\\nThe service checks the local SQLite database\\nusing apodDao.\\nIf the data is already cached,\\nwe serve it directly.\\nIf not, we make a request to the NASA API\\nand save the response locally before returning it.\\nSo here we are,\\nwe are going to do a check,\\nwe're going to get today's value.\\nIf it's not, if the cachedApod is not null,\\nwe can go ahead and just return it to whoever's calling us.\\n\\nIf not, we have to make a request out to NASA.\\nAnd if we get it,\\nwe go ahead and save it first and then return it.\\nOtherwise we get some sort of an error,\\nand here's our error message.\\nWhy cache it?\\nTwo reasons.\\nFirst, performance.\\nReading from our local database\\nis faster than reaching out over the internet.\\nSecond, resilience.\\nThe NASA API has rate limits,\\nand if we hit them,\\nour service gracefully falls back to cached data.\\nTypically yesterday's photo with a clear message\\nindicating it's a fallback.\\n\\nWe use similar flow for other endpoints.\\nFor API APOD date,\\nwe validate the format,\\ncheck the cache,\\nand if needed, fetch from NASA.\\nWe even guard against invalidate like future dates\\nor anything before June 16th, 1995\\nwhen the APOD program started.\\nThere is also API APOD random,\\nwhich fetches a random cached picture\\nor goes to NASA if needed.\\nAnd the APOD history\\nprovides paginated results\\nusing standard page and page size parameters.\\n\\nBut here's where it gets even smarter.\\nIf the cache is empty or looks stale,\\nwe don't just return a blank result,\\ninstead we proactively fill it.\\nThe service will automatically reach out to NASA\\nand pull in data going back as far as 30 days.\\nIt uses a rate limited loop and logs its progress.\\nThis gives us a reliable cache of recent history,\\neven if the server restarts\\nor gets deployed to a fresh environment.\\n\\nThe APOD API becomes a trusted upstream,\\nand we treat it with care,\\nthrottling requests, checking for errors,\\nand backing off when we get rate limited.\\nBy the end of this module,\\nyou've got a working API that talks to NASA,\\ncaches intelligently,\\nand exposes four clean endpoints:\\ntoday, date, random, and history.\\nAnd let's go ahead and do a quick test.\\n\\nSo this is the random API,\\nwe hit it.\\nAnd the best thing to look at\\nis just like the parts of the title.\\nWe see this as Galaxy Wars.\\nNow if we do another request to the same endpoint,\\nthis time we get NGC 6946\\nand NGC 6939.\\nSo that's working.\\nAnd if we take a look in our console,\\nwe can see these requests went out.\\nSo here's one for random,\\nhere's another one for random,\\nand here's another one for random.\\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:4159010\",\"duration\":245,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"APOD API endpoints with validation\",\"fileName\":\"6004176_en_US_01_04_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":344,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 01_04\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to apply custom serialization for efficient handling of complex data structures.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":9958771,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] By now,\\nour APOD API can return today's image,\\na specific date, a random photo, or a paginated history.\\nBut just because an API works doesn't mean it's reliable.\\nIn this module, we're going to tighten things up\\nwith validation and error handling.\\nThe goal here is to make the API safer for consumers,\\neasier to debug, and more robust under edge cases.\\nYou'll notice most of this logic lives in the APOD service\\nwith a few helpers in the route definitions.\\n\\nIf we take a closer look at the APOD date endpoint,\\nusers provide a date and a URL\\nand we try to return a corresponding APOD.\\nBut what happens if the date is malformed?\\nOr it's in the future?\\nOr it's before June 16th, 1995,\\nthe start of the APOD archive?\\nThat's where our validateDate function comes in.\\nIt lives inside of ApodService\\nand it needs to enforce three rules.\\n\\nFirst, the date must be a valid ISO date.\\nSecond, it can't be in the future.\\nAnd third, it has to be on or after June 16th, 1995.\\nLet's handle the first of those rules, but don't worry,\\nwe'll come back for the other two.\\nIf any condition fails,\\nwe throw an illegal argument exception.\\nThat exception bubbles up into our route handler,\\nwhich catches it and responds with a 400 bad request\\nalong with a helpful error message.\\n\\nIn fact, each route is wrapped in its own try-catch block.\\nSo here's the one for today.\\nWe can see that there is a try-catch block,\\nand here's the corresponding error,\\nand it will tell us what the error for that was.\\nThis allows us to catch specific errors,\\nlike validation issues,\\nas well as more general ones like network failures\\nor database problems.\\nWhen something goes wrong,\\nthe API responds with a clear HTTP status code\\nand an error response object.\\n\\nFor example,\\nif a user requests API APOD date Foobar,\\nwe respond with a 400\\nand the message invalid date format.\\nSo let's take a look at that.\\nThere's our Foobar.\\nOh wait, sorry, I didn't do what I said I was going to do.\\nSo here's the date one.\\n\\nAnd then we get the invalid date format.\\nUse the YYYY-MM-DD format.\\nWe apply similar logic to the history route.\\nIt accepts a page and a size.\\nLet's go to history.\\nIt accepts a page and a page size,\\nand we enforce bounds on both.\\nPage must be greater than zero,\\nand page size must be between one and 100,\\nand we can see that right there.\\n\\nAny violation gets a 400 response,\\nagain with detailed message.\\nThis approach follows a consistent pattern,\\nvalidate input early, log clearly,\\nand fail gracefully.\\nThat way our API doesn't just work,\\nit behaves predictably,\\nand users always get feedback that they can act on.\\nWe don't just rely on runtime checks.\\nThese validations are small, testable pieces of code.\\nYou can cover them with unit tests\\nor property-based testing,\\nand be confident they'll continue to behave correctly\\nas the app grows.\\n\\nTo sum up, validation isn't just about catching bugs,\\nit's about shaping the developer experience\\nfor whoever consumes our API.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4159009\",\"duration\":52,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Challenge: Enhanced date validation\",\"fileName\":\"6004176_en_US_01_05_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":54,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 01_05\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to implement comprehensive date validation that rejects future dates and pre\u2013APOD dates.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2095290,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"(upbeat music)\\n- [Instructor] Let's add some business rules\\nto our date validator.\\nRight now, we are only checking\\nthat the input is a valid date format.\\nIn this challenge, you'll add two additional checks.\\nThe date should not be in the future,\\nand it should not be before June 16th, 1995.\\nIf either of these rules fails,\\nthrow an error with a helpful message.\\nFor example, date cannot be in the future\\nor no apod available before 1995/06/16.\\n\\nYou can test your solution\\nby requesting a valid date, like 2022/12/25 should succeed.\\nA future date should fail.\\nAn early date like 1994/01/01 should also fail.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4161003\",\"duration\":95,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Solution: Enhanced date validation\",\"fileName\":\"6004176_en_US_01_06_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":115,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 01_06\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":3891560,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"(upbeat music)\\n- [Instructor] Hope you enjoyed this challenge.\\nHere's how I solved it.\\nThe existing validator already parses the date string.\\nI added two additional checks right after the parse step.\\nOne checks that the date is not after today.\\nSo we use local date now to get today's date.\\nWe check to see if the date\\nthat we are working with is after using the is after,\\nand then throw a date cannot be in the future message.\\n\\nAnd then the other one,\\nwe check to see if the date is\\nbefore\\n1995, 06, 16.\\nAnd if not, we say no APOD available before this APOD date.\\nSo let's go to the terminal.\\nLet's do one that should pass\\nso we get a response back.\\nLet's go to the future instead of 2022,\\nwe'll go to 2032\\nand run.\\nAnd we get a date cannot be in the future.\\n\\nAll right, well let's see if our time machine\\ncan take us to the past.\\nLet's go back to 1990\\nand we get a no APOD available before 1995, 06, 16.\\nAnd that's how I solved this challenge.\\nAnd remember, as always,\\nthere's a million ways to write a program.\\nSo, so long as yours passes a validation,\\nI'm sure you're probably fine.\\n\"}],\"name\":\"1. Getting Started with Ktor Server\",\"size\":42291459,\"urn\":\"urn:li:learningContentChapter:4156014\"},{\"duration\":803,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:4156011\",\"duration\":184,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"SQLite setup with Exposed object-relational mapping (ORM)\",\"fileName\":\"6004176_en_US_02_01_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":267,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 02_01\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to configure database tables for APOD data and cache metadata using Exposed ORM.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":7811309,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Now that we have a working Ktor server,\\npulling data from NASA's APOD API,\\nit's time to start storing that data locally.\\nIn this module, we'll hook up SQLite using JetBrains\\nas Exposed ORM.\\nYou might have noticed there's no DB in the project,\\nand that's on purpose.\\nWe don't check the database into version control.\\nIt gets created automatically at runtime\\nand lives in a folder called data.\\nThe file's casually named randomspace.db,\\nand you can ignore it most of the time.\\n\\nJust know the app creates and manages it for you.\\nAlso worth calling out, we're not storing any images.\\nThe database holds metadata about each photo,\\nthings like title, date, explanation,\\nand the URL where the picture is hosted on NASA servers.\\nWe establish a connection\\nto SQLite in the initializeDatabase function.\\nIt uses HikariCP, and this is going to be at the top,\\nto manage performance and concurrency,\\nand connects with the connection string\\nthat's passed to JetBrains Exposed,\\nwhich handles everything from there.\\n\\nExposed is Kotlin's type-safe SQL framework.\\nIt gives us a clean DSL,\\na domain-specific language for defining tables,\\ncolumns, and queries.\\nIf we take a look at ApodDao,\\nwe can actually see this domain-specific language.\\nSo this is actually\\nthe Kotlin domain-specific language, Exposed.\\nNo annotations, no fragile query strings,\\njust compile check structure.\\n\\nOur schema lives in the data access object layer.\\nFor example, ApodDao defines columns\\nlike title, date, mediaType,\\nmapping them to SQLite types like VARCHAR and TEXT.\\nEach of these maps directly to a property\\non the apod metadata object.\\nOn startup, we use schema create\\nto ensure that tables exist.\\n\\nIf the database file is missing, it's created automatically.\\nIf the schema is missing, it's initialized.\\nIt's one less thing to worry about when developing locally.\\nAnd since we're using SQLite,\\nwe don't need to spin up Postgre\\nor MySQL just to test our server.\\nThis makes development lightweight and portable.\\nLater, if we want to move\\nto a more scalable database, we can.\\nJust update to JDBC driver\\nand change the connectivity string.\\n\\nThe best part, everything is pure Kotlin,\\nso we get full support from the IDE plus compiler checks.\\nIt's safe, readable, and refactor-friendly.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4156008\",\"duration\":199,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Data access layer implementation\",\"fileName\":\"6004176_en_US_02_02_VT\",\"demo\":true,\"videoCreationMetadata\":{\"rawDurationSeconds\":337,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 02_02\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to build DAOs and a repository pattern for database operations with SQLite as cache storage.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":8561929,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Now that we've got SQLite wired up\\nand the schema initialization in place,\\nit's time to implement the data access layer.\\nThis is where we interact directly with the database.\\nIn this module, we'll define our DAO, data access object\\nclasses using JetBrains expose.\\nClasses like apod DAO and Cache metadata DAO,\\nthese classes are responsible for querying\\nand updating tables in the database.\\nEach one encapsulates logic for a specific table\\nand all interactions happen through them.\\n\\nLet's take a look at apod DAO.\\nThis class handles the apod metadata.\\nFirst, we define the table by subclass and table.\\nEach column is declared using exposes DSL,\\ndomain specific language.\\nWe use VARCHAR for strings, text for long form content,\\nand long for things like timestamps.\\nEach column gets a type and a constraint.\\nFor example, the date column is a VARCHAR 10,\\nand also the primary key.\\n\\nThat ensures each apod entry is unique by date,\\nwhich is how the real NASA archive works.\\nAfter the table is defined,\\nwe implement a set of query functions.\\nThese are methods the service layer calls\\nwhen it wants to read or write data.\\nFor example, get by date, get random,\\nand get paginated,\\nand finally, save.\\n\\nEach of these runs inside an exposed transaction block.\\nThat's important.\\nExpose requires transactions\\nto safely interact with the database.\\nYou can think of this as a cotton friendly wrapper\\naround the JDBC transaction management.\\nLet's take get by date as an example.\\nInside the transaction block,\\nwe query apod table using select.\\nIf a row is found,\\nwe map it to an apod response object using a custom\\nto apod extension function.\\n\\nSimilarly, the save function either inserts\\nor replaces an existing row.\\nWe use insert or replace to make sure\\nwe are not duplicating entries,\\nand we store the current timestamp in the fetch at column.\\nBy isolating all this logic in the DAO,\\nwe can keep the code base clean.\\nThe service layer doesn't care how we talk to the database.\\nIt just says, Hey, give me the apod for July 15th,\\nor save this new one.\\n\\nAnd the DAO takes care of the details.\\nThe same pattern applies to cache metadata DAO,\\nwhich handles simple key value pairs in a separate table.\\nThis is great for tracking things like\\nwhen the last cache maintenance job ran.\\nTo wrap up,\\nthe data access layer is where we do the actual querying.\\nIt is built entirely in Kotlin, Expose\\nand safe transaction handling.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4160007\",\"duration\":173,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Caching layer integration\",\"fileName\":\"6004176_en_US_02_03_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":265,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 02_03\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to add API key authentication to protect sensitive endpoints in your application.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":7385227,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] With the data layer in place,\\nwe now have all the tools we need to start caching\\nAPOD metadata locally.\\nIn this module, we're going to connect everything together\\nby adding a caching layer\\nbetween the NASA API and the database.\\nMost of the logic lives inside of the APOD service class.\\nThis service acts as the middleman and it decides\\nwhether to fetch from the local database\\nor call out to NASA.\\nLet's start with a get today APOD method.\\n\\nThis method first checks the local cache\\nby calling APODDao get by date.\\nIf that returns a result, we use it.\\nOtherwise, we fetch the APOD\\nfrom NASA using the NASA API client.\\nSo right here we go and we get the date.\\nIf it's not null,\\nwe go ahead and return this APOD that's been cashed.\\nOtherwise, we go ahead and fetch from the NASA API client.\\n\\nAnd once we get something,\\nwe go ahead and save it and return it.\\nAnd just in case any sort of error or exception happens,\\nthis whole thing is wrapped in a try-catch block.\\nWhat's nice about this design is that the API handler\\ndoesn't care where the data came from.\\nThe service extracts all of that,\\nwhich makes testing and maintenance much easier.\\nBut we've also added resiliency.\\nSuppose NASA's API is rate limited\\nor temporarily unavailable,\\nand that case we fall back\\nto yesterday's cash photo if it exists.\\n\\nAnd we clearly label the response as a fallback.\\nFor historical browsing the getAPOD history method\\nsupports pagination and returns a paginated response.\\nIf the database is empty,\\nit triggers a background cash fill from the last 30 days.\\nThat ensures we always have a minimum amount\\nof content available without overwhelming the API.\\nThe same pattern is used in get APOD by date\\nand get random APOD.\\n\\nIn both cases, we check the cash limit first\\nand only hit the network if necessary.\\nThis reduces latency, respects NASA's rate limits,\\nand keeps the app responsive even when offline.\\nAnd of course, every successful fetch\\ngets saved with a fetched at time stamp.\\nThis is handy for later cleanup or freshness checks.\\nThe caching layer is really the brain of the system.\\n\\nIt optimizes API calls, handles fallback behavior,\\nand keeps our database synced with the external data source.\\nWithout it, the app would be slower, more fragile,\\nand less user friendly.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4162002\",\"duration\":142,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Background jobs and scheduling\",\"fileName\":\"6004176_en_US_02_04_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":200,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 02_04\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to set up scheduled cache maintenance and data synchronization tasks.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":5869352,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] In this module,\\nwe're going to set up automated background jobs\\nthat help keep the cache up to date.\\nThese jobs run on a schedule\\nand take care of fetching new data\\nand cleaning out old records\\nso you don't have to do it manually.\\nYou'll find this logic in the run daily cache maintenance\\njobs method inside of Apod Service.\\nThis method runs as part of a background job\\nconfigured when the server starts up.\\nThe first thing the job does is try to fetch\\nand cache today's Apod.\\n\\nThis ensures that if the app missed it earlier, for example,\\ndue to downtime, it gets another chance.\\nThen it deletes old records from the database.\\nWe define a retention window using cached days property,\\ntypically 90 days.\\nAnything older than that gets removed\\nto keep the database lightweight.\\nAfter cleanup,\\nthe job checks whether any recent dates are missing.\\nFor example, maybe the Apod from July 4th failed\\ndue to a network hiccup.\\n\\nThe job looks for gaps and backfills those days\\nusing the same caching logic we wrote earlier.\\nTo keep track of when the job last ran,\\nwe use the cacheMetadataDao.\\nIt stores simple key value pairs like daily maintenance,\\nlast run, so we can check this info later if needed.\\nAll of this runs asynchronously using Kotlin co-routines,\\nwhich means it won't block the main thread\\nor slow down incoming API requests.\\n\\nWe also log every step, both successes and failures,\\nso we can monitor job health in production.\\nThis isn't a full-blown task scheduler.\\nWe're just using simple Kotlin code\\nand the server's built-in lifecycle hooks\\nto run the job once per day.\\nIf you need more advanced behavior like Kron expressions,\\nretries, or distributed execution, you could swap this out\\nfor something like Quartz or push it to a cloud task runner.\\n\\nBut for small to medium maps, this approach works great.\\nIt's fast, reliable, and simple to maintain.\\nAll of your core data stays fresh without needing manual\\nintervention or complex infrastructure.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4161002\",\"duration\":38,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Challenge: Log each cached APOD\",\"fileName\":\"6004176_en_US_02_05_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":50,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 02_05\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to implement a protected data service with a time-based caching strategy that refreshes data periodically while maintaining security.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":1532073,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"(upbeat music)\\n- [Instructor] Let's wrap up this chapter\\nwith something small but useful, visibility.\\nYour task is to log each time an apod is saved\\nto the database.\\nInside the save method, add a log line that includes\\nthe date, so we can track what's being cached and when.\\nThis helps during development\\nand also gives us a trail for debugging\\nif we ever need to investigate\\nwhy a certain entry is missing or stale.\\n\\nYou can test it by requesting any apod data\\nand watching for the log output.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4160008\",\"duration\":67,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Solution: Log each cached APOD\",\"fileName\":\"6004176_en_US_02_06_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":81,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 02_06\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2813530,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Here's how I approach this one.\\nWe already have a working save method\\nthat writes APOD entries to the database.\\nTo make caching behavior more visible,\\nI added a log message after each save.\\nThis message includes the date of the APOD,\\nso we can track exactly what's being cached and when.\\nThis kind of logging information is useful,\\nboth during development and production diagnostic.\\nYou can request a few APODs from the API\\nand as long as the server is writing to the log,\\nyou'll see confirmation\\nthat the cache is happening as expected.\\n\\nLet's take a little peek at this, go to the terminal.\\nWe get one APOD back.\\nGo to the debugging page\\nand we can see right here where it's returning APOD\\nfor 2022-12-15 from cache from the APOD service.\\nAnd that's all for this challenge.\\n\"}],\"name\":\"2. Data Storage and Caching\",\"size\":33973420,\"urn\":\"urn:li:learningContentChapter:4155010\"},{\"duration\":830,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:4156010\",\"duration\":157,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Enhanced error handling and status pages\",\"fileName\":\"6004176_en_US_03_01_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":223,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 03_01\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to implement comprehensive error handling for NASA API failures and database errors.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":6762652,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] In this module, we are going to improve\\nhow our servers handles errors.\\nRight now, if something goes wrong in a route or service,\\nthe error might bubble up\\nand trigger a generic response or worse, no response at all.\\nLet's make that better\\nby setting up structured error handling using Ktor's\\nstatus pages plugin.\\nThis gives us full control over how the server responds\\nto exceptions, both expected and unexpected.\\n\\nYou'll see configuration\\nin the configure status pages function.\\nThis is called from the application.module,\\nWhen the Server Starts Up.\\nInside status pages,\\nwe use exception handlers to catch specific exception types\\nand respond with appropriate HTTP status codes and messages.\\nFor example, when we throw an illegal argument exception,\\nthe server responds with a 400 bad request\\nand a JSON body that includes a helpful message.\\n\\nWe also have a catchall handler for generic durable errors.\\nThis ensures that if something unexpected happens\\nlike a null pointer or misconfigured DAO,\\nthe server won't crash.\\nInstead, it logs the error\\nand returns a 500 internal server error\\nwith a generic fallback message.\\nEach response is wrapped in a consistent format\\nusing the error response class.\\nThis class contains a message field\\nand optionally a stack trace in development mode.\\n\\nThat helps front end developers debug without leaking\\nsensitive details in production.\\nWe also added the HTTP status code extension KT file\\nto centralize status codes and messages.\\nThat keeps things consistent and reduces duplication.\\nIf we want to return the same 404 format\\nfor multiple routes,\\nwe can use a helper like not found\\ninstead of repeating code.\\nA small but powerful touch\\nis logging every handled error.\\n\\nThat way, we have visibility into the kinds of failures\\nusers are experiencing,\\nand we can prioritize which ones to fix or improve.\\nWith this in place, users always get a meaningful response.\\nDevelopers get better logs,\\nand the app behaves more predictably\\nunder failure conditions.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4159006\",\"duration\":168,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Advanced routing and request processing\",\"fileName\":\"6004176_en_US_03_02_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":277,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 03_02\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to add pagination, query parameters, and date range filtering to API endpoints.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":6905359,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Routing is the heart of any web server.\\nIt defines how requests get handled\\nand which logic responds to which path.\\nIn this module, we are going to refine our API routing\\nand explore techniques for writing clean,\\nscalable route handlers.\\nYou've already seen the basics in the APOD routes function\\nPaths like today, date, date, random history\\nare all registered in the API APOD.\\n\\nBut there's more going on here than just wiring up paths.\\nFirst, notice that each route handles its own validation\\nand exception handling.\\nThat's intentional.\\nWe want every endpoint to be resilient and self-contained.\\nFor example, slash date slash date checks\\nwhether the date parameter is present and valid\\nbefore calling into this service.\\nSecond, we use early returns to avoid deep nesting.\\n\\nIf the date is missing or invalid,\\nwe return a 400 bad request immediately.\\nThat keeps the code flatten and easier to read.\\nThird, we added an extension function called respond error.\\nThis wraps up error responses in a consistent JSON format\\nand ensures we don't duplicate response logic\\nthroughout the file.\\nEvery error response includes\\nthe HTTP status code and message.\\n\\nLet's talk a little bit about dependency injection.\\nThe APOD service instance is resolved\\nusing coin inject function.\\nThat lets us keep our route logic clean and testable.\\nWe're not manually wiring anything.\\nWe just declare what we need and let coin provide it.\\nWe also added an admin route\\n/api/admin/db-status.\\nThis lets us inspect the database directly.\\n\\nIt returns a JSON object with the list of tables,\\na success message, and some internal connection info.\\nIt's a handy tool\\nfor checking if the app is properly initialized,\\nespecially in staging or test environments under the hood.\\nIt uses a raw SQL query via exposed to list the table names.\\nEven though most of our app uses Safe Kotlin DSL,\\nthere are times when going straight to the SQL makes sense\\nand this is one of them.\\nWith these patterns in place, clean structure,\\nearly validation, inject services, and utility helpers,\\nyou've got a routing set up\\nthat's easy to expand, test and maintain.\\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:4158008\",\"duration\":145,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Performance monitoring and optimization\",\"fileName\":\"6004176_en_US_03_03_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":218,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 03_03\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to implement request timing metrics and database query optimization techniques.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":6016202,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Performance problems can sneak up on you,\\nespecially in a server that looks like it's working fine.\\nIn this module, we'll wire in basic monitoring and logging\\nso we can detect bottlenecks and understand\\nhow the app behaves under load.\\nFirst up is request logging.\\nIf you've checked out the configureMonitoring function,\\nyou'll see that we've installed Ktor's CallLogging plugin.\\nThis logs in incoming requests,\\nincluding method, path, and response time.\\n\\nYou'll see lines like 200 OK: GET - /api/apod/random in 7ms\\nprinted in the console.\\nThese logs are incredibly useful during development,\\nbut they also help in production.\\nIf users report slow responses or random timeouts,\\nrequest logs can tell you exactly\\nwhere the delays are happening.\\nWe've configured our Logger\\nusing slf4j, which works nicely with Ktor\\nand JetBrains Exposed.\\n\\nThat means database operations and background jobs\\ncan log to the same system with consistent formatting.\\nIf you want to go deeper,\\nconsider adding correlation IDs to each request.\\nThat allows you to trace a request\\nacross services, even down to specific database queries.\\nWe haven't added that here,\\nbut it's a common next step for larger applications.\\nAnother tip is to monitor your cache rate hit.\\n\\nIn the APOD service,\\nwe log whether an entry was returned from the cache\\nor fetched from the API.\\nThat tells us whether our caching strategy is working\\nand how often we're hitting external rate limits.\\nAnd speaking of caching,\\nour logs now show how many entries were added, skipped,\\nor cleaned during each maintenance job.\\nThat gives us visibility into how the system is evolving\\nday by day.\\n\\nYou don't need full observability\\nto start optimizing performance.\\nEven simple logging done consistently\\ncan help you identify trends,\\nisolate slow routes, and understand the cost\\nof different operations.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4160005\",\"duration\":132,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"API documentation and testing\",\"fileName\":\"6004176_en_US_03_04_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":179,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 03_04\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to create a comprehensive test suite using curl and Insomnia for all endpoints.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":5056335,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Even a great API is hard to use\\nif people don't know how to use it.\\nIn this module,\\nwe'll focus on documenting and testing our API endpoints,\\nso they're easy to understand, easy to explore,\\nand easy to validate.\\nWhile we haven't included OpenAPI\\nor Swagger in this project yet,\\nit's good practice to keep your endpoints well-structured\\nand self-describing.\\nThe API APOD routes use clear paths\\nand HTTP verbs.\\n\\n/today returns today's image,\\n/date date fetches a date,\\n/random gives you a surprise,\\nand /history supports pagination with page and page size.\\nFor manual testing,\\nwe've included an Insomnia workspace\\nunder the server/api-test/insomnia.\\nThis YAML file defines all the routes\\nand example requests you'll need\\nto explore the API from a REST client.\\n\\nInsomnia makes it easy\\nto simulate edge cases like requesting a missing date\\nor hitting the API without pagination parameters.\\nThese scenarios help you validate both our happy path\\nand our responses.\\nEach route returns consistent JSON,\\neven when something goes wrong.\\nFor example,\\ndates return a 400 with an error response object\\nthat includes a status and a message\\nthat helps front end developers handle errors\\nwithout guessing.\\n\\nIf you want to automate,\\nyou could write integration tests\\nusing Ktor's test application engine.\\nThat would let you simulate HTTP requests\\ninside a test environment,\\ncheck the response status,\\nand assert on the body.\\nWe haven't done that in this course,\\nbut the architecture supports it.\\nThe goal here is not to just make the API work,\\nbut to make it trustworthy.\\nClear routes, consistent errors, and easy testing tools\\nall contribute to a better experience for anyone using it,\\nincluding future you.\\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:4159008\",\"duration\":55,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Challenge: Date range filtering\",\"fileName\":\"6004176_en_US_03_05_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":57,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 03_05\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Build an APOD or gallery endpoint with date filtering, pagination, and popularity sorting.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2184482,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"(upbeat music)\\n- [Narrator] Let's make our API more flexible\\nby adding support for date-based filters.\\nYour task is to enhance the slash history endpoint\\nto accept two optional query parameters,\\nstart date and end date.\\nIf present, the results should include only entries\\nwithin that range.\\nYou'll need to validate that the start date\\nis not after the end date.\\n\\nIf it is, respond with a clear 400 error end message.\\nTo verify your changes,\\ntry calling slash api slash apod slash history.\\nQuestion mark start date equals a date\\nand end date equals another date.\\nYou should see only entries between those two dates.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4157011\",\"duration\":173,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Solution: Date range filtering\",\"fileName\":\"6004176_en_US_03_06_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":234,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 03_06\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":7752257,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"(bright rhythmic music)\\n(bright rhythmic music fading)\\n- [Instructor] How did you do?\\nHopefully, it went well for you,\\nand here's how I solved the challenge.\\nWe made a few changes to support date range filtering,\\none in the route, one in the service, and one in the DAU.\\nIn the route, we check for both startDate and endDate.\\nIf they're both present, we pass them to the service.\\nIf only one is provided,\\nwe return a 400 to keep the behavior clear.\\n\\nThe service method\\nnow also accepts optional start and endDates.\\nIf they're valid, we forward them to the DAO for filtering.\\nIf not,\\nwe throw an error that gets handled by the route layer.\\nWe gave our getPaginated method a suite upgrade\\nto handle date range filtering.\\nThink of it as teaching an old dog some new tricks,\\nwhile keeping all of its original charm.\\nOur method\\nlearned to accept startDate and endDate parameters,\\nlike giving it a calendar and saying, \\\"Hey,\\nonly show me the cool space stuff from this time period.\\\"\\nNow our method is like a helpful librarian who asks,\\n\\\"Do you want specific dates, or just everything?\\\"\\nWhen you ask for specific dates,\\nit carefully converts your date strings\\ninto proper localDate objects, runs a targeted count query,\\nhow many pictures do we have between these dates,\\nfetches the actual data with the same date filter,\\nstill keeping things sorted and properly paginated.\\n\\nWhen you want everything, the original behavior,\\nit happily grabs all the records like it always did.\\nThere's no change here.\\nThe same trustee select-all approach\\nthat's been working great.\\nBoth paths still use the same reliable offset math,\\npage-1 x pageSize, and limit offset combo.\\nSo your pagination stays buttery smooth,\\nwhether you're filtering by dates or not.\\nThe result your /history endpoint\\ncan now handle fancy date filtered requests,\\nlike passing its start and endDate,\\nwhile still being totally cool with regular old pagination.\\n\\nWin-win.\\nAnd so let's take a little look at this.\\nWe've got the server running in the back.\\nHere, we have a history\\nwith a startDate of 2025-07-01, 1st of July,\\nand endDate of 2025-07-10,\\nso we should get back 10 objects.\\nAnd if we scroll all the way to the bottom,\\nwe can see that the pageSize is 10, the totalItems is 10,\\nand we got one page.\\n\\nAnd we can see,\\nhere are some of these 10 objects that we return.\\nSo I hope again that it went well for you,\\nand if not, just take some time and study this code.\\n\"}],\"name\":\"3. Advanced API Features\",\"size\":34677287,\"urn\":\"urn:li:learningContentChapter:4162003\"},{\"duration\":675,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:4158009\",\"duration\":191,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"KMP project architecture\",\"fileName\":\"6004176_en_US_04_01_VT\",\"demo\":true,\"videoCreationMetadata\":{\"rawDurationSeconds\":255,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 04_01\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Explore the shared module structure and expect/actual patterns for platform-specific code.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":7981664,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Kotlin multi-platform lets us share logic\\nacross Android, iOS, and even the backend.\\nIn this module, we're going to break down the structure\\nof our KMP project\\nand walk through how it all fits together.\\nThere are three key modules,\\nshared, composeApp, and iosApp.\\nEach of these plays a specific role.\\nLet's start with shared.\\nThis is where most of our code lives,\\nthe business logic, networking layer,\\ncaching, and data models.\\n\\nIt's organized using src sets, like commonMain,\\nandroidMain, and iosMain.\\nCode in commonMain is shared by all platforms.\\nThe platform-specific folders let us add behavior\\nthat's unique to Android or iOS when needed.\\nThe shared module is compiled\\ninto an Android library for the Android app\\nand into a Kotlin-native framework for iOS.\\n\\nThat means, we only write our logic once.\\nBoth platforms can use it natively.\\nThen we have composeApp.\\nThis is the Android UI layer.\\nIt depends on shared and builds a Jetpack Compose interface\\nfor the user to browse APOD metadata.\\nBecause Compose is still only Android only,\\nthis module stays platform specific,\\nbut everything it depends on,\\nlike repository models comes from shared.\\n\\nBy the way, newsflash, iOS is now able to use Compose.\\nIt's still in an experimental stage,\\nbut hopefully by the time this course comes out,\\nit will be fully 1.0.\\nWe are using it.\\nAnd finally, there's iosApp.\\nThis is the Xcode project and Swift UI interface for iOS.\\nIt includes the generated Kotlin framework\\nfrom the shared module,\\nwhich means we can call shared Kotlin code\\ndirectly from Swift.\\nIn this setup, iosCode focuses only\\non UI and lifecycle.\\n\\nNo network or database logic lives here.\\nThis structure is designed to maximize code reuse\\nwithout sacrificing platform-native UX.\\nBackend logic, data models, business rules,\\nand caching live in shared.\\nUI and platform-specific hooks\\nstay in their respective modules.\\nKMP gives us the flexibility\\nto write platform-specific code only when we need to.\\nIf a particular feature requires native APIs,\\nlike biometric authentication or camera access,\\nwe can implement it in androidMain and iosMain,\\nwhile still keeping the interface shared\\nthrough expect actual declarations.\\n\\nThe big advantage is consistency.\\nBoth platforms use the same models, the same repository,\\nand the same logic for things like pagination,\\nvalidation, and formatting.\\nThat means fewer bugs, less duplication, and easier testing.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4163002\",\"duration\":169,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Shared data models and constants\",\"fileName\":\"6004176_en_US_04_02_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":218,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 04_02\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to create platform-agnostic data structures and constants in the shared module.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":6027111,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] In this module, we are going to focus\\non what goes into the shared module,\\nand more specifically, how we define shared models\\nand constants that work across all platforms.\\nShared models are the foundation of a clean,\\nKotlin multi-platform architecture.\\nThey let us define data ones\\nand use it everywhere, on iOS, on Android,\\nand even the backend if we want to.\\nYou'll find most of these live in shared, source,\\ncommonMain, and Kotlin.\\n\\nThat's the directory where we define platform-agnostic code.\\nInside you'll see data classes like ApodResponse,\\nPaginatedResponse, and ErrorResponse.\\nThese are used for everything,\\nparsing JSON, communicating between services,\\nand shaping what we send back to the UI.\\nBecause they live in commonMain,\\nwe can safely serialize and deserialize them\\non both Android and iOS using the same logic.\\n\\nWe're using kotlinx.serialization here,\\nwhich gives us fast and type-safe way\\nto encode and decode data.\\nEvery model is annotated with @Serializable,\\nand we can control things\\nlike default values and field names\\nusing Kotlin standard syntax.\\nOne benefit of sharing these models is consistency.\\nWhen Android and iOS both rely\\non the same ApodResponse structure,\\nwe avoid subtle bugs\\ncaused by mismatched field names, null ability issues,\\nand platform-specific assumptions.\\n\\nIn addition to models,\\nwe can also define constants here,\\nlike the default pagination size,\\nallow date formats, API limits,\\nand even human-readable error message\\nthat can all live in commonMain.\\nIf any constants do need to vary by platform,\\nsay, base URL for networking or file path for caching,\\nwe can handle that with expect actual mechanism.\\nBut most of the time a single shared constant is enough.\\n\\nThis separation of data and logic make testing easier too.\\nBecause the models live in a pure Kotlin module,\\nwe can test them on JVM\\nor in common test code,\\nno emulator, simulator, or device required.\\nShared data models and constants are where structure starts.\\nThey're easy to overlook,\\nbut they're what makes true code reuse possible\\nin a KMP project.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4155009\",\"duration\":135,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Dependency injection setup\",\"fileName\":\"6004176_en_US_04_03_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":217,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 04_03\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to configure Koin for shared dependencies across all platforms.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":5436673,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] In this module, we are going\\nto set up dependency objection for our shared code.\\nIf you're coming from Android or server-side Kotlin,\\nyou might already be familiar\\nwith DI frameworks like Dagger, Hilt, or Coin.\\nWe're using Coin.\\nThe idea behind DI is simple.\\nInstead of creating dependencies manually in each class,\\nwe define how to build them in one place\\ncalled the module.\\nOpen shared modules,\\nyou'll see a function called shared module.\\n\\nThis is where we define all singletons\\nand factories for our shared code base.\\nLet's walk through a few examples.\\nFirst, we provide our APOD repository as a singleton\\nThat means it's created once and reused everywhere.\\nWe also define how to create the APOD service\\nand database classes,\\npassing any required parameters into each constructor.\\nWe're keeping things clean by splitting modules.\\nShared services go in one module\\nwhile platform specific ones like Android's contacts\\nor iOS delegates are defined separately in Android main\\nor iOS main.\\n\\nIf we switch to the Android module for a second,\\nyou'll find Platform Android KT.\\nThis file defines a platform module,\\nwhich includes any platform specific dependencies.\\nThen in main activity, we initialize Coin.\\nThe iOS side works similarly.\\nWhat's powerful about this setup\\nis that the shared code never needs to know\\nwhat platform it's running on.\\n\\nIt just asks for what it needs, like an APOD repository,\\nand Coin provides the right instance.\\nThis decouples creation from usage,\\nmakes unit testing simple\\nand sets the stage\\nfor replacing implementations\\nif we want to test offline behavior or simulate errors.\\nThat's dependency injection in Kotlin\\nmulti-platform using Coin.\\nSimple, flexible, and 100% testable.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4157010\",\"duration\":66,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Challenge: Platform-specific logging\",\"fileName\":\"6004176_en_US_04_04_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":65,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 04_04\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to implement cross-platform logging using expect/actual with Android Log, NSLog, and SLF4J.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2648729,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"(bright music)\\n- [Instructor] We've been logging events\\non the server for a while now,\\nbut what about shared code?\\nIn this challenge, we're going to extend logging support\\nto our shared Kotlin multi-platform module\\nstarting with Android.\\nThe goal is to let common code write log messages\\nwithout knowing which platform it's running on.\\nYou'll start by defining an expect class in commonMain\\nwith two functions, one for info level logs,\\nand one for error level logs.\\n\\nThen implement the actual class in androidMain\\nusing Android's Log.i and Log.e functions\\nto write to Logcat.\\nOnce that's in place, call your logger from a shared class\\nor service to confirm it works.\\nYou should see the output in Logcat when you run the app.\\nThis is a great way to get familiar\\nwith platform-specific declarations\\nin Kotlin Multiplatform.\\nAnd once you've got Android version working,\\nit'll be easy to add support for iOS\\nand other platforms later.\\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:4156009\",\"duration\":114,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Solution: Platform-specific logging\",\"fileName\":\"6004176_en_US_04_05_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":135,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 04_05\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to create multiplatform HTTP client configuration for shared networking code.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":4971482,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"(bright upbeat music)\\n- [Instructor] How'd you do?\\nWere you able to get logging working in shared code?\\nHopefully, you found an approach\\nthat felt clean and makes sense to you.\\nThere are different ways you could solve this,\\nbut here's how I tackled it.\\nI started by defining an expect class called PlatformLogger\\nin shared code.\\nNotice that it has the expect before it.\\nThen, I created the platform-specific versions\\nin jvmMain.\\n\\nHere, we're using println and System.err.println.\\nAlso in androidMain,\\nhere we used the Log.i and Log.e.\\nAnd finally, iosMain,\\nwhere we use NSLog to print it out.\\nOnce that was in place,\\nI called the logger from my shared service code.\\nNow, what I actually do is a little different.\\nI said, let's put this into\\nour actual MainActivity.\\n\\nSo here we get a message that says,\\n\\\"Hey, MainActivity launched.\\\"\\nNow, the same logging call works no matter what.\\nSo if I take a look inside right now,\\nI do have the Android app running in the background.\\nIt's been running for a bit.\\nIf I take a look in Logcat\\nand I look for MainActivity launched,\\nwe can see it right here.\\nNow, if you run your app now\\nand trigger a few API calls,\\nyou should see those log messages show up in Android Logcat\\nor an Xcode console\\ndepending on which platform you're testing.\\n\\nThis is a great pattern to use\\nanytime you want shared code to talk to the host,\\nand it keeps things clean and testable.\\nNice job getting through this one.\\n\"}],\"name\":\"4. Kotlin Multiplatform Foundations\",\"size\":27065659,\"urn\":\"urn:li:learningContentChapter:4157012\"},{\"duration\":712,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:4159007\",\"duration\":104,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Ktor client setup\",\"fileName\":\"6004176_en_US_05_01_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":158,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 05_01\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to build shared repositories using coroutines and Flow for cross-platform data access.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":3870830,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] In this module, we're going to set up\\nthe shared HTTP client that both Android and iOS\\nwill use to talk to the Ktor server.\\nThis will live entirely in our shared code module\\nand use Ktor client\\nto handle network calls in a multi-platform friendly way.\\nThis is where we configure our client.\\nWe're using Ktor's multi-platform HTTP client,\\nwhich works across Android, iOS, and JVM out of the box.\\n\\nInside the create client function,\\nwe install several useful plugins.\\nFirst is content negotiation.\\nThis handles automatic JSON serialization\\nand deserialization using Kotlinx serialization.\\nThat means we can send and receive\\ntyped Kotlin data models\\nwithout writing any manual parsing code.\\nNext is the logging plugin.\\nThis logs HTTP traffic,\\ngreat for debugging requests and responses.\\n\\nYou'll see requests URLs, headers,\\nand responses log to the console\\ndepending on the log level.\\nYou can customize this configuration per environment.\\nFor example, during development, the client can point\\nto local hosts in production,\\nit can target a remote server.\\nWe manage this through dependency injection\\nusing a base URL that's injected via coin.\\nThe results is a flexible, shared HTTP client\\nthat works seamlessly across both Android and iOS\\nwith support for structured logging, timeouts,\\nand automatic JSON handling.\\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:4155008\",\"duration\":148,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Repository pattern with shared code\",\"fileName\":\"6004176_en_US_05_02_VT\",\"demo\":true,\"videoCreationMetadata\":{\"rawDurationSeconds\":188,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 05_02\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to implement ViewModels and use cases that work across Android and iOS platforms.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":5767839,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Now that we've configured\\nour shared KTor client,\\nlet's build on top of it using the repository pattern.\\nThe goal here is to abstract away the details\\nof the network access behind a clean, testable interface.\\nThis is our main entry point\\nfor fetching data from the server,\\nAPOD entries, histories, and so on.\\nWe define a simple interface for the repository,\\nwhich includes methods like get today's APOD,\\nget a APOD by date, get APOD history.\\n\\nEach of these corresponds to a server endpoint,\\nbut the details of how the request is made\\nare hidden inside the implementation.\\nThe implementation of APOD repository uses the\\nKTor client we set up in the last module.\\nWe pass it via Constructor Injection using Koin,\\nwhich keeps things clean and decoupled.\\nEach method sends a GET request using client dot get\\nand maps the results directly\\ninto a shared Kotlin data class,\\nlike APOD response or paginated response.\\n\\nBecause we're using Kotlin X serialization,\\nwe don't need to write any parsing logic.\\nOne nice touch is inside the repository,\\nif a request fails, we catch the exception,\\nand throw a structured error like network exception\\nor a not found exception.\\nThat keeps the error logic out of the UI,\\nand makes unit testing much easier.\\nAnother benefit of the repository pattern is testability.\\n\\nIn our tests, we can inject a fake\\nor mock implementation of APOD repository\\nand simulate success or failure\\nwithout making a real network call.\\nThe UI doesn't need to know how the data is fetched.\\nIt just asks for the repository for today's APOD\\nor a list of entries and gets back a clean Kotlin object.\\nThis separation makes the code base easier to reason about\\nand maintain across platforms.\\n\\nIn short, the repository acts as a glue\\nbetween the shared HTTP clients and the rest of the app.\\nIt's the layer that turns raw HTTP responses\\ninto real data our features can use.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4159005\",\"duration\":152,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Shared business logic\",\"fileName\":\"6004176_en_US_05_03_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":192,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 05_03\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to add comprehensive error handling with proper Result types and meaningful error messages.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":6146804,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Now that we've built a clean repository\\ninterface over our network layer,\\nlet's talk about shared business logic.\\nWhere decisions get made, caching strategies are applied\\nand platform agnostic rules are enforced.\\nMost of this logic lives in APOD service.\\nYou've already seen this class on the server,\\nbut in the shared client code,\\nwe're using the same name for consistency.\\nThis is the class that coordinates request\\nbetween the repository and the rest of the app.\\n\\nLet's walk through what it does.\\nWhen you call today APOD, the service checks if the results\\nis already cashed if not,\\nit fetches the repository and stores the result locally.\\nThe same thing happens for historical data.\\nThis pattern lets us reuse results, reduce network calls,\\nand improve offline support, all in shared code.\\nWe also implement fallback behavior here.\\n\\nFor example, if the request for today's image fails,\\nwe can fall back to yesterday's result.\\nAssuming we have a cache,\\nthat's a great way to make the app\\nfeel more reliable without extra effort from the UI.\\nWe also use this layer to centralize validation.\\nFor instance, when we fetch by date,\\nthe service checks that the date is valid\\nin the past and after the APOD program started.\\nThat's not UI logic. It's not networking logic.\\n\\nIt belongs right here in the business layer.\\nBy isolating these decisions in the shared module,\\nwe avoid duplicating them on each platform.\\nAndroid and iOS both benefit from the same logic\\nand future platforms will too.\\nAnd of course, this layer is fully testable.\\nYou can pass a fake repository\\nand test how the service reacts to different conditions,\\nempty results, failed requests, invalid inputs,\\nall without hitting a network or UI.\\n\\nThink of this service as the smart middle layer.\\nIt doesn't talk directly to the network.\\nIt doesn't care about the UI.\\nIt just makes decisions,\\nwhen to fetch how to cash and what to return.\\nKeeping that logic and shared code means\\nwe're not just sharing code, we're sharing behavior,\\nand that's what makes Kotlin multi-platform so powerful.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4159004\",\"duration\":163,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Challenge: Repository error handling\",\"fileName\":\"6004176_en_US_05_04_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":195,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 05_04\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to set up navigation and platform integration for Compose Multiplatform apps.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":7740152,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"(bright music)\\n- [Instructor] Right now, our app is a little too quiet\\nwhen things go wrong.\\nA drop network connection, a crash server,\\nthe app just fails silently, no error,\\nno retry, no explanation.\\nOur users deserve better than that confusing, empty screen.\\nSo right now, everything works. We can click on this.\\nWe go to the details, come back.\\nNow, let's stop the app.\\n\\nLet us go to server config.\\nWe are going to intentionally break the network connection.\\nSo now, server mode is equal to broken.\\nIt just needs to be something that isn't working.\\nYou can also just change that string itself.\\nAnd now, we're going to restart everything.\\nAll right, so here on the APOD gallery,\\nif I click it, nothing happens.\\n\\nThe screen is completely empty.\\nNow, just in case you think there's a bug someplace else,\\nif we go to the today screen, we notice that we get a fail\\nto load today's picture, no internet connection.\\nAnd we have a try again button,\\nwhich will go out and eventually time out\\n'cause there is no internet.\\nIn this challenge,\\nyou will implement comprehensive error handling\\nto surface network errors in the UI\\nso users see helpful feedback when something breaks.\\n\\nThe underlying error detection is already there.\\nIn the repository layer, you just need to connect it\\nto the user interface.\\nYour task is to add user-friendly error handling\\nto the home screen that today's screen\\nis working correctly and serves as your guide.\\nStudy how it handles errors\\nand apply the same pattern to the home screen\\nthat is missing this functionality.\\nTo test your implementation, open server config\\nand change server mode from working to broken.\\n\\nThis will simulate network failures.\\nNavigate to the home screen, click the refresh\\nand see the silent failure, empty screen. No feedback.\\nThen implement error handling,\\nfollowing the today's screen pattern\\nand confirm that helpful error messages\\nwith retry buttons appear instead.\\nOnce you verified your error handling\\nworks across all screens, restore this server to working\\nand ensure normal operation continues seamlessly.\\n\\nApps shouldn't fail silently.\\nLet's make sure yours doesn't. Have fun with this challenge.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4155007\",\"duration\":145,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Solution: Repository error handling\",\"fileName\":\"6004176_en_US_05_05_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":228,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 05_05\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to build list and detail screens using Material 3 design and shared Compose components.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":6316941,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"(bright music)\\n- [Instructor] How did you approach\\nimplementing error handling for your APOD app?\\nThe key to solving this challenge\\nwas using the today screen as your guide.\\nThe today screen already demonstrates\\nthe complete error handling pattern\\nwith its error field in today UI state.\\nThe on failure block in load today APOD,\\nand the error display UI that shows helpful messages\\nwith retry buttons on the today screen.\\n\\nTo fix the home screen, you needed to add an error field\\nto home UI state, then include an on failure block\\nin load APOD history.\\nThe final step was adding the error display UI\\nthat checks for empty lists and error states,\\nshowing the user a clear message\\nand retry button instead of leaving them\\nwith an empty screen.\\nThis approach transforms the silent failures\\ninto clear communication with users.\\n\\nInstead of having mysterious empty screens,\\nthe user now sees exactly what went wrong\\nand have a clear path to retry their actions.\\nSo if we go ahead, and first off,\\nlet me make sure you see\\nthat we are in broken mode right now.\\nWe are on APOD gallery.\\nSo here is the home screen\\nand we have an error loading data.\\nLikewise, if we go to the today page,\\nwhich was working before,\\nwe see that there's an error message here as well.\\n\\nNow, if I go ahead and fix this,\\nwell, first let me stop the app,\\nand let's go ahead and fix it\\nby committing in and committing out.\\nAnd if we do a retry, bam, now we see it.\\nRemember to restore your server mode back\\nto working in the server config\\nso that your app functions normally again.\\n\\nAnd we can also just cruise around\\nand see some cool pics.\\n\"}],\"name\":\"5. Shared Network Layer\",\"size\":29842566,\"urn\":\"urn:li:learningContentChapter:4159013\"},{\"duration\":575,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:4160006\",\"duration\":102,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Compose UI architecture\",\"fileName\":\"6004176_en_US_06_01_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":167,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 06_01\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to connect Compose UI to a shared repository and implement dependency injection.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":4029169,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Now that we have built a shared network\\nand business layer, it's time to put it to work in the UI.\\nIn this chapter,\\nwe're focusing in on composed UI side of things,\\nstarting with architecture.\\nOpen up the compose app module.\\nThis is where our composed multi-platform UI code lives.\\nThe architecture here follows the MVVM pattern.\\nWith unit directional data flow,\\nstate flows down from the view models,\\nevents bubble up from the UI.\\n\\nTake a look at APOD view model\\nto see how the view model talks to the repository\\nand emits state through state flow.\\nInside the view model,\\nwe use Kotlin routines to fetch data and update state.\\nWhen something goes wrong, say a network error.\\nWe update the state to reflect the error\\nand the UI reacts accordingly.\\nThis keeps the business logic out of the composable.\\nTake a look at the today screen,\\nto see how UI renders whatever state it receives\\nand sends users events back to the view model.\\n\\nThis pattern helps us stay organized as apps grow,\\nyou can swap out the repository, mock the data and previews,\\nor handle UI events consistently.\\nAnd because all of this is built\\nwith composed multi-platform,\\nit works the same whether you're tapping\\non an Android phone or running an iOS simulator.\\nAs you move into more advanced modules,\\nthis architecture will help keep the UI predictable,\\ntestable, and maintainable.\\n\\nIt's all Kotlin all the way down.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4155006\",\"duration\":99,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"APOD display screens\",\"fileName\":\"6004176_en_US_06_02_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":145,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 06_02\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to organize business logic with use cases and maintain clean architecture patterns.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":4315250,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] In this module, we're building the screens\\nthat display astronomy picture\\nof the day entries using Jetpack composed multi-platform.\\nStart with today's screen.\\nThis screen uses APOD view model\\nthat loads today's APOD via the shared repository\\nand exposes the state as state flow.\\nWe collect this state in composable using collect as state.\\nThe UI shows a title, the image,\\nand an explanation.\\n\\nImages are loaded using async image,\\nwhich supports multi-platform image loading\\nand caching across Android and iOS.\\nWhen there is an error\\nor the user is offline,\\nwe display helpful messages\\nwith retry buttons instead of crashing.\\nThe state model drives this with flags like is loading,\\nerror and APOD data to control what the UI shows.\\nNext look at home screen.\\n\\nFor the APOD history list,\\nit displays a scrollable list of cards each showing a title,\\nthumbnail, and date.\\nThis screen supports pagination using lazy loading\\nwith a load more trigger.\\nWhen the user scrolls near the end, we call view model\\nto fetch the next page.\\nBoth screens are powered by the same shared business logic,\\nso they behave identically regardless of platform.\\nThese screens give us clean, responsive building blocks\\nfor displaying APOD content across all platforms.\\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:4157009\",\"duration\":105,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Client integration\",\"fileName\":\"6004176_en_US_06_03_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":138,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 06_03\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Wire up the missing detail view to complete the Find screen\u2019s user flow and make View Full Picture fully functional.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":4599057,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Now, let's connect\\nthe shared client with our composed UI,\\nso everything flows smoothly.\\nUser tabs, API calls, local caching,\\nand UI state updates.\\nLook at Apod View Model to see how it acts\\nas the bridge between the composed UI\\nand the shared repository.\\nWhen initialized, it calls repository methods\\nand emits state via state flow.\\nThe composable collects this state using collect as state\\nand renders whatever it receives,\\nloading spinners, errors or data.\\n\\nThe view model also handles user events.\\nWhen the user pulls to the refresh,\\nwe call methods like refresh,\\nwhich reruns the network calls and updates the state.\\nNo need to touch the UI code,\\njust update the flow.\\nCheck out home screen to see this pattern in action.\\nThe view model loads paginated data\\nand exposes a list of entries with flags like,\\nis loading and has more data.\\nWhen the composable detects scrolling to the end,\\nit calls, load more items\\nand the view model updates the state.\\n\\nThe separation keeps things testable and consistent.\\nThe view model doesn't know about compose\\nand the UI doesn't know about HTTP calls or caching.\\nWe use App Module with Coin to inject the repository,\\nmaking it easy to mock and test.\\nBy connecting the shared client\\nthrough lightweight view models,\\nwe've created a robust, platform-independent app flow\\nthat's portable, testable, and easy to extend.\\n\\n\"},{\"urn\":\"urn:li:learningContentVideo:4157008\",\"duration\":103,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Use cases and clean architecture\",\"fileName\":\"6004176_en_US_06_04_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":144,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 06_04\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":4030058,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] In this module,\\nwe're structuring shared code around use cases\\nto help scale your app without things getting tangled\\nas it grows.\\nLook in the domain use case package\\nfor classes like GetApodByDateUseCase.\\nEach class defines one job, fetch today's Apod,\\nfetch by date, or fetch paginated history.\\nThey don't know about compose or view models.\\nThey just expose a function and return a result.\\n\\nThese use cases take dependencies\\nthrough constructor parameters,\\nusually a repository, and apply business rules,\\nlike validation or filtering.\\nWe wire them up using Coin and AppModule,\\nmaking them easy to reuse across different screens.\\nCheck out how ApodViewModel becomes much thinner.\\nIt calls use cases, collects results, and emits state.\\nThis keeps presentation logic and business logic separated,\\nwhich is the foundation of clean architecture.\\n\\nAnother benefit is testability.\\nYou can write fast unit tests\\nfor each use case in isolation,\\nmocking the repository, and asserting correct behavior.\\nAnd because use cases are pure Kotlin,\\nthey live entirely in the shared module.\\nSo Android and iOS use identical business logic.\\nThis architecture might feel like a lot at first,\\nbut it pays off as the app grows.\\nWhen you need to add features or fix bugs,\\nyou know exactly where the logic lives.\\n\\nWe've connected everything from the UI\\nto the network with clean separation\\nand clear responsibilities at each step.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4160004\",\"duration\":64,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Challenge: Complete the FindScreen navigation\",\"fileName\":\"6004176_en_US_06_05_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":77,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 06_05\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how Compose Multiplatform automatically generates an iOS framework without iOS-specific code.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2524431,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"(upbeat music)\\n- [Instructor] The find screen can search Apods\\nand show results, but there's one thing missing.\\nWhen the user taps view full picture nothing happens yet.\\nThe button is there but it doesn't lead anywhere.\\nYou're task is to wire up that detail view.\\nWhen tapped, the button should show the full Apod image,\\ntitle and explanation along with a back button\\nto return to search.\\n\\nTry searching a date like 2025-07-16.\\nTap the button.\\nAnd make sure everything flows smoothly.\\nSearch, view, back, repeat.\\nLook at how today's screen handles detailed navigation\\nand feel free to reuse components.\\nA bit of local state is all you need\\nto manage the transition.\\n\\nLet's complete the flow\\nand make the experience feel polished.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4160003\",\"duration\":102,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Solution: Complete the FindScreen navigation\",\"fileName\":\"6004176_en_US_06_06_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":113,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 06_06\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to configure iOS app settings, build targets, and app icons in Xcode.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":4183460,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"(upbeat music)\\n- [Instructor] How did you tackle this challenge?\\nThe solution centers on introducing local navigation state\\nto toggle between search view and detail view\\nwithin the find screen.\\nA simple Boolean state variable\\ncontrols which UI is displayed:\\nfalse for search, true for detail view.\\nLook at find screen to see the conditional\\nthat decides which UI to render.\\nThis pattern keeps both views in the same composable,\\navoiding complex navigation setups.\\n\\nNow, for us, if we take a look at App.kt,\\n(laughs) that's what I like to call it,\\nyou can see here's the find screen,\\nand then here's something called details screen.\\nAnd if we look inside of the find screen,\\nwe see that there's an onApodClick,\\nand that if so, it navigates to a route called details.\\nNow, the fun thing about this is\\nis that this is the same route\\nthat the home screen uses.\\nSo there's a, you click on something,\\nyou get a navigation controller,\\nyou navigate to the details screen.\\n\\nThe detail view uses a standard scaffold\\nwith top app bar and back button.\\nTapping the back button resets the state to show search.\\nTapping the view full picture\\nsets the state to display detail.\\nThis highlights an important principle in Jetpack Compose.\\nFor simple self-contained flows,\\nlocal state is often the cleanest solution.\\nIt keeps transition smooth,\\ncode easy to follow, and the design maintainable.\\n\\n\"}],\"name\":\"6. Compose Multiplatform UI\",\"size\":23681425,\"urn\":\"urn:li:learningContentChapter:4157013\"},{\"duration\":623,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:4163001\",\"duration\":112,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Understanding iOS generation\",\"fileName\":\"6004176_en_US_07_01_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":138,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 07_01\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to build an iOS framework and run the app in the Xcode simulator alongside the Android emulator.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":4355414,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] In this module,\\nwe're going to explore\\nhow Compose Multiplatform runs\\nnatively on iOS.\\nYou've already seen\\nhow shared code works on Android.\\nOn iOS, it's even more seamless.\\nWe're using the exact\\nsame Compose UI code.\\nWe're at the tip of the spear here.\\nUnlike traditional Kotlin Multiplatform\\nthat generates frameworks for Swift,\\nwe're running Compose directly on iOS.\\nThat means no Swift code,\\nno framework generation,\\njust Kotlin.\\n\\nPure Kotlin and Compose\\nall the way down.\\nLook at the iOS app module structure.\\nSo here we are,\\nhere's the iOS structure.\\nYou'll notice it contains\\nonly one Swift file.\\nAnd quite frankly,\\nthis file doesn't do very much.\\nThe same home screen, today's screen,\\nAPOD view model\\nthat power your Android app,\\nare running natively on iOS\\nthrough Compose Multiplatform.\\n\\nWhen you build iOS,\\nKotlin/Native compiles your Compose code\\ninto a native iOS binary.\\nThe Compose runtime handles\\nall the iOS-specific details,\\ntouch events, navigation,\\nmemory management,\\nwhile your business logic\\nand UI stay identical across platforms.\\nThis approach eliminates\\ntraditional pain points\\nof cross-platform development.\\nNo API translation layers,\\nno platform-specific UI code to maintain,\\nno synchronization issues\\nbetween iOS and Android implementation.\\n\\nThe results is true code sharing\\nat every level.\\nYour view models,\\nrepositories, UI components,\\nand even navigation logic work\\nidentically on both platforms.\\nIt's all Kotlin, all Compose everywhere.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4159003\",\"duration\":159,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Xcode project configuration\",\"fileName\":\"6004176_en_US_07_02_VT\",\"demo\":true,\"videoCreationMetadata\":{\"rawDurationSeconds\":188,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 07_02\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Learn how to test your complete app's functionality on both the Android emulator and the iOS simulator.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":6523956,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] In this module,\\nwe'll get your composed multi-platform app\\nrunning on the iOS simulator without ever opening Xcode.\\nThe beauty of composed multi-platform is\\nthat you can develop, build,\\nand test your iOS app entirely from Android studio.\\nMake no mistake though, you still need Xcode.\\nOnly, it just runs in the background.\\nLook at your run configurations.\\nYou'll see iOS simulator options alongside\\nyour Android targets.\\nSo if we do a dropdown here,\\nwe can see that there's an iOS app here.\\n\\nThere's a compose app, which is Android,\\nwhich even can run tests from here and other things.\\nGradle handles everything, compiling Kotlin native,\\npackaging the app, launching the simulator,\\nand installing your app.\\nThe same APOD view model and today's screen\\nthat you've been testing on Android\\nwill appear on the iOS simulator.\\nThe iOS simulator runs your actual composed UI code,\\ntap interaction, scroll, navigate,\\neverything behaves like a native iOS app\\nbecause it is a native iOS app, just written in Kotlin\\nand composed instead of Swift and Swift UI.\\n\\nIf you need to debugs iOS specific behavior,\\nyou can use the same debugging tools\\nyou use for Android, set break points.\\nIn fact, let's go ahead and click on one of these pictures\\nand you notice there's a break point\\nand we ended up in the picture details page.\\nOkay, so let's go ahead and let that finish running.\\nWe go back, we go to today.\\nOh, and look, we've hit our break point again\\nat picture detail screen.\\nSo we're doing a lot of code sharing here.\\n\\nIf we go ahead and let that run one more time,\\nand I think that you've guessed what's going to happen.\\nSo we type in a date, we say find the picture,\\nwe say view full picture,\\nand we end up once again at the picture details page.\\nSet break points in APOD repository or home screen,\\nand they'll work on iOS too.\\nThey share code base means they share debugging experience.\\n\\nFor network testing, remember to update server config\\nto use the correct IP address for the iOS simulator.\\nIt can reach your development server\\njust like the Android emulator can.\\nThis streamlined workflow means you can iterate quickly\\nacross both platforms without context switching\\nbetween IDEs or learning platform specific tools.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4156007\",\"duration\":115,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Running on iOS simulator\",\"fileName\":\"6004176_en_US_07_03_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":148,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 07_03\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":5183250,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] While your Compose UI\\nruns identically on both platforms,\\nthere are some platform specific behaviors\\nworth understanding.\\nLook at platform Android and platform iOS.\\nSo, we've got 'em here standing side by side.\\nThis is how we handle platform differences.\\nThe base URL configuration varies\\nbetween emulator and device, iOS and Android.\\nBut the networking logic in APOD repository stays the same.\\nNavigation adjusters differ slightly as well.\\n\\niOS users expect swipe back navigation\\nwhile Android users expect a back button.\\nCompose Multi-platform\\nhandles these differences automatically,\\nproviding the appropriate navigation experience\\nfor each platform.\\nSystem integration points like status bars, safe areas,\\nkeyboard handling are managed by the Compose Runtime.\\nYour home screen and today's screen\\nautomatically adapt to iOS design guidelines\\nwithout any platform-specific code.\\n\\nImage loading through AsyncImage\\nworks identical on both platforms,\\nbut iOS has different caching behaviors\\nand memory management.\\nThe APOD View model doesn't need to know\\nabout these differences.\\nThe underlying implementation handles platform optimization.\\nError handling and APOD repository\\nproduces the same results on both platforms,\\nbut iOS may show slightly different network error messages\\nat the system level.\\n\\nYour app's error handling logic remains consistent.\\nThe key insight is that while platforms have differences,\\nCompose Multi-platform abstracts them away.\\nYou write your business logic once in APOD View model\\nand your UI once in today's screen,\\nand both platforms get the optimal experience.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4160002\",\"duration\":109,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Challenge: Cross-platform verification\",\"fileName\":\"6004176_en_US_07_04_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":138,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 07_04\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Review your completed project and explore advanced KMP topics for further learning.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":5332380,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"(upbeat music)\\n- [Instructor] Now that you have composed multi-platform\\nrunning on both Android and iOS,\\nyour challenge is to verify that behavior\\nis truly consistent across platforms.\\nThis isn't just about checking\\nwhether the app compiles and runs.\\nIt's about confirming that your shared logic\\nin Apod view model and Apod repository\\nbehaves identically, no matter which platform calls it.\\n\\nStart by testing the same user flows on both platforms.\\nLoad today's Apod, browse history, search by date,\\ncheck that data returned is identical,\\nerrors are handled the same way,\\nand caching behavior is consistent.\\nUse server config\\nto simulate network failures on both platforms.\\nSet server mode to broken and verify\\nthat both Android and iOS\\nshow the same error messages and retry behaviors.\\n\\nYour error handling should be identical\\nbecause it's the same Apod view model code.\\nTest pagination in the home screen on both platforms.\\nScroll to the bottom, trigger loads.\\nConfirm the same number of items\\nload with the same data.\\nThe Apod repository pagination logic\\nshould work identically.\\nTry edge cases like invalid dates in the same search screen,\\nnetwork timeouts, and app backgrounding.\\n\\nSince you're using the same Kotlin code for everything,\\nthe behavior should be consistent.\\nThis verification builds confidence\\nthat your shared codebase truly delivers\\non the promise of write once, run everywhere functionality.\\n\"},{\"urn\":\"urn:li:learningContentVideo:4161001\",\"duration\":128,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Solution: Cross-platform verification\",\"fileName\":\"6004176_en_US_07_05_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":148,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"exerciseFileDisplayText\":\"branch 07_05\",\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":false,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":5933226,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"(upbeat music)\\n- [Instructor] How did you verify\\nconsistent behavior across platforms?\\nThe key was testing\\nthe same flows\\nand confirming identical results\\nfrom your shared APOD view model,\\nand APOD repository.\\nIn software development,\\nthere is still some manual testing.\\nThis testing is\\nfor high value user flows that\\nyou want to guarantee are not broken,\\nsuch as someone making\\na purchase in your store app\\nor someone booking an appointment\\nin your calendar app.\\n\\nTesting success cases first,\\nboth platforms returned\\nidentical data when calling\\nthe same repository methods.\\nThe APOD repository hits\\nthe same endpoints\\nand processes responses identically.\\nSo the today screen\\nand the home screen displayed\\nthe same content.\\nFor error scenarios,\\nusing server config\\nto break the network showed that\\nboth platforms handled failures identically.\\nThe same error messages appear,\\nthe same retry logic triggers,\\nand the same fallback behavior occurs\\nbecause it's all shared Kotlin code.\\n\\nPagination testing in\\nhome screen confirmed\\nthat scrolling behavior\\nand data loading work\\nthe same way on both platforms.\\nThe APOD view model manages state identically\\nand Compose handles UI rendering consistently.\\nEdge case testing revealed\\nthat input validation, network timeout,\\nand error recovery are all behaving\\nthe same way across platforms.\\nThis consistency comes from having\\nzero platform-specific business logic.\\n\\nEverything lives in the shared Kotlin.\\nThe verification confirms\\nthat Compose Multiplatform delivers\\ntrue code sharing.\\nNot just shared models or networking,\\nbut shared UI,\\nshared state management,\\nand shared user experience.\\nBoth platforms run\\nthe exact same application logic,\\njust compiled for different targets.\\n\"}],\"name\":\"7. iOS Integration\",\"size\":27328226,\"urn\":\"urn:li:learningContentChapter:4163003\"},{\"duration\":85,\"entries\":[{\"urn\":\"urn:li:learningContentVideo:4159002\",\"duration\":85,\"visible\":true,\"requiredForCertificateOfCompletion\":true,\"name\":\"Next steps and course summary\",\"fileName\":\"6004176_en_US_08_01_VT\",\"demo\":false,\"videoCreationMetadata\":{\"rawDurationSeconds\":115,\"solutionVideo\":false,\"handoutGraphicsIncluded\":false,\"assignedBy\":\"urn:li:member:-1\",\"includesPickups\":false,\"challengeVideo\":false,\"hasSlides\":false,\"graphicsIncluded\":true,\"assignedTo\":\"urn:li:member:-1\",\"includesAlternateFootage\":false},\"description\":\"Review your completed project and explore advanced KMP topics for further learning.\",\"captionsStatus\":\"AVAILABLE\",\"cdnStatus\":\"AVAILABLE\",\"size\":2186640,\"solution\":false,\"welcomeContent\":null,\"challenge\":false,\"assetStatus\":\"COMPLETE\",\"transcript\":\"- [Instructor] Congratulations on building\\na truly multi-platform app with Compose multi-platform.\\nWe started with a Ktor server connected to NASA's APOD API,\\nbuilt a shared repository layer\\nand created view models that work across platform.\\nThen we built Compose UI\\nthat runs natively on both Android and iOS.\\nNo platform specific UI code required.\\nYou've seen how APODViewModel, TodayScreen and HomeScreen\\nwork identically on both platforms.\\n\\nThe same error handling, the same navigation,\\nthe same user experience, all from shared Kotlin\\nand compose code.\\nThis represents the future of cross-platform development.\\nInstead of maintaining separate code bases\\nor dealing with bridge layers, you write code once in Kotlin\\nand Compose and deploy it everywhere.\\nWhat's next, deploy your server.\\nAdd features like offline support or user preferences,\\nand consider expanding to desktop or web targets.\\n\\nCompose multi-platform gives you the foundation\\nto reach any platform while maintaining\\na single cohesive code base.\\nThanks for learning with me.\\nYou've experienced the cutting edge\\nof multi-platform development,\\ntrue code sharing from business logic\\nall the way up to the UI layer.\\n\"}],\"name\":\"Conclusion\",\"size\":2186640,\"urn\":\"urn:li:learningContentChapter:4156015\"}],\"size\":223458970,\"duration\":5361,\"zeroBased\":false}]}"